[ { "title": "프로그래머스 게임 맵 최단거리", "url": "/posts/programmers-gamemap/", "categories": "PS, implements", "tags": "programmers, implements, level2", "date": "2022-06-26 20:02:23 +0900", "snippet": "프로그래머스 게임 맵 최단거리풀이 시작점을 기준으로 bfs 돌려서 큐에 넣을 때마다 거리 + 1씩 해줘서 넣어주면 끝 ! 풀이 시간 25분 ide 사용 x내가 푼 풀이import java.util.*;class Pos{ int x; int y; public Pos(int y, int x) { this.y = y; this.x = x;}}class Solution { static int dx[] = {0, 0, -1, 1}; static int dy[] = {-1, 1, 0, 0}; static int visited[][]; public int solution(int[][] maps) { return bfs(maps,new Pos(0,0)); } public static int bfs(int[][] maps, Pos start){ Queue&amp;lt;Pos&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(start); visited = new int[maps.length][maps[0].length]; visited[start.y][start.x] = 1; while(!queue.isEmpty()){ Pos cur = queue.poll(); for(int i=0; i&amp;lt;4; i++){ int nextY = cur.y + dy[i]; int nextX = cur.x + dx[i]; if(nextX &amp;gt;=0 &amp;amp;&amp;amp; nextX &amp;lt; maps[0].length &amp;amp;&amp;amp; nextY &amp;gt;=0 &amp;amp;&amp;amp; nextY &amp;lt; maps.length){ if(visited[nextY][nextX] == 0 &amp;amp;&amp;amp; maps[nextY][nextX]==1){ visited[nextY][nextX] = visited[cur.y][cur.x] + 1; queue.add(new Pos(nextY, nextX)); } } } } return (visited[visited.length-1][visited[0].length-1] == 0) ? -1 : visited[visited.length-1][visited[0].length-1]; }}" }, { "title": "프로그래머스 [1차] 다트 게임", "url": "/posts/programmers-dart/", "categories": "PS, implements", "tags": "programmers, implements, level1", "date": "2022-06-25 06:44:23 +0900", "snippet": "프로그래머스 1차 다트 게임내가 푼 풀이import java.util.*;class Solution { public static int solution(String dartResult) { int answer = 0; int score = 0; int idx = 0; ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for(int i=0; i&amp;lt;dartResult.length(); i++){ char c = dartResult.charAt(i); if(c==&#39;1&#39; &amp;amp;&amp;amp; dartResult.charAt(i+1) ==&#39;0&#39;){ score = 10; i++; } else if(c &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; c &amp;lt;= &#39;9&#39;){ score = c - 48; } else if(c == &#39;S&#39;) { list.add(score); idx++; } else if(c == &#39;D&#39;) { list.add((int)Math.pow(score, 2)); idx++; } else if(c == &#39;T&#39;) { list.add((int)Math.pow(score, 3)); idx++; } else if(c == &#39;*&#39;) { if(idx &amp;gt; 1) list.set(idx-2,list.get(idx-2)*2); list.set(idx-1,list.get(idx-1)*2); }else if(c == &#39;#&#39;){ list.set(idx-1,-list.get(idx-1)); } } for(int num : list) answer+=num; return answer; }}" }, { "title": "프로그래머스 정수 내림차순으로 배치하기", "url": "/posts/programmers-string/", "categories": "PS, implements", "tags": "programmers, implements, level1", "date": "2022-06-25 06:44:23 +0900", "snippet": "프로그래머스 정수 내림차순으로 배치하기풀이 소요 시간 약 5분내가 푼 풀이import java.util.*;class Solution { public long solution(long n) { String str = Long.toString(n); PriorityQueue&amp;lt;String&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;(Collections.reverseOrder()); for(int i=0; i&amp;lt;str.length(); i++) pq.add(Integer.toString(str.charAt(i)-48)); String ans =&quot;&quot;; while(!pq.isEmpty()) ans+= pq.poll(); return Long.parseLong(ans); }}" }, { "title": "프로그래머스 제일 작은 수 제거하기", "url": "/posts/programmers-min/", "categories": "PS, implements", "tags": "programmers, implements, level1", "date": "2022-06-25 02:35:23 +0900", "snippet": "프로그래머스 제일 작은 수 제거하기풀이 소요 시간 약 7분내가 푼 2가지 풀이import java.util.*;class Solution { public static int[] solution(int[] arr) { ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); PriorityQueue&amp;lt;Integer&amp;gt; queue = new PriorityQueue&amp;lt;Integer&amp;gt;(); for(int num : arr){ list.add(num); queue.add(num); } list.remove(list.indexOf(queue.poll())); if(list.size() == 0) list.add(-1); return list.stream().mapToInt(Integer::intValue).toArray(); }}class Solution { public static int[] solution(int[] arr) { int min = arr[0]; int idx = 0; if(arr.length==1) return new int[]{-1}; int answer[] = new int[arr.length-1]; for(int i=1; i&amp;lt;arr.length; i++){ if(arr[i] &amp;lt;= min ){ min = arr[i]; idx = i; } } for(int i=0; i&amp;lt;idx; i++) answer[i] = arr[i]; for(int i=idx+1; i&amp;lt;arr.length; i++) answer[i-1] = arr[i]; if(answer.length == 0) answer[0] = -1; return answer; }}" }, { "title": "프로그래머스 두 개 뽑아서 더하기", "url": "/posts/programmers-collatz/", "categories": "PS, implements", "tags": "programmers, implements, level1", "date": "2022-06-25 02:35:23 +0900", "snippet": "프로그래머스 두 개 뽑아서 더하기풀이 소요 시간 약 5분내가 푼 풀이import java.util.*;class Solution { public int[] solution(int[] numbers) { Arrays.sort(numbers); ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for(int i=0; i&amp;lt;numbers.length-1; i++){ for(int j=i+1; j&amp;lt;numbers.length; j++){ int sum = numbers[i] + numbers[j]; if(!list.contains(sum)) list.add(sum); } } return list.stream().sorted().mapToInt(Integer::intValue).toArray(); }}" }, { "title": "프로그래머스 모의고사", "url": "/posts/programmers-exam/", "categories": "PS, implements", "tags": "programmers, implements, level1", "date": "2022-06-24 21:26:23 +0900", "snippet": "프로그래머스 모의고사풀이 간단한 구현 문제 ArrayList -&amp;gt; 배열로 전환할 떄 list.stream().mapToInt(Integer::intValue).toArray(); 사용내가 푼 풀이import java.util.*;class Solution { public int[] solution(int[] answers) { int one[] = {1, 2, 3, 4, 5}; int two[] = {2, 1, 2, 3, 2, 4, 2, 5}; int three[] = {3, 3, 1, 1, 2, 2, 4, 4, 5, 5}; int count[] = new int[3]; for(int i=0; i&amp;lt;answers.length; i++){ if(one[i%one.length] == answers[i]) count[0]++; if(two[i%two.length] == answers[i]) count[1]++; if(three[i%three.length] == answers[i]) count[2]++; } Integer arr[] = {count[0],count[1], count[2]}; Arrays.sort(arr,Collections.reverseOrder()); ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for(int i=1; i&amp;lt;=3; i++){ if(arr[0] == count[i-1]) list.add(i); } return list.stream().mapToInt(Integer::intValue).toArray(); }}" }, { "title": "프로그래머스 완주하지 못한 선수", "url": "/posts/programmers.participate/", "categories": "PS, implements", "tags": "programmers, implements, level1", "date": "2022-06-24 20:28:23 +0900", "snippet": "프로그래머스 완주하지 못한 선수풀이 처음에 ArrayList로 담아서 contains로 접근헀지만 몇몇 케이스가 시간 초과가 나와 HashMap으로 다시 풀었다. 소요 시간 약 20분 내가 푼 풀이import java.util.*;class Solution { public String solution(String[] participant, String[] completion) { HashMap&amp;lt;String, Integer&amp;gt; hash = new HashMap&amp;lt;&amp;gt;(); String answer = &quot;&quot;; for(String name : participant) hash.put(name, hash.getOrDefault(name,0) + 1); for(String name : completion) hash.put(name, hash.get(name)-1); for(String name : hash.keySet()){ if(hash.get(name) != 0) answer = name; } return answer; }}" }, { "title": "프로그래머스 로또의 최고 순위와 최저 순위", "url": "/posts/programmers-rotto/", "categories": "PS, implements", "tags": "programmers, implements, level1", "date": "2022-06-24 14:04:23 +0900", "snippet": "프로그래머스 로또의 최고 순위와 최저 순위풀이 간단한 구현 문제 소요 시간 약 5분 내가 푼 풀이import java.util.*;class Solution { public int[] solution(int[] lottos, int[] win_nums) { int correct = 0; int zeroCnt = 0; for(int i=0; i&amp;lt;win_nums.length; i++){ for(int j=0; j&amp;lt;lottos.length; j++){ if(lottos[j] == 0 &amp;amp;&amp;amp; i == 0){ zeroCnt++; continue; }else if(lottos[j] == win_nums[i]) correct++; } } int[] answer = new int[2]; int min = (7-correct &amp;gt;=6)? 6 : 7-correct; answer[1] = min; correct += zeroCnt; int max = (7-correct &amp;gt;= 6)? 6 : 7-correct; answer[0] = max; return answer; } }" }, { "title": "백준 침투", "url": "/posts/back-13565/", "categories": "PS, DFS-BFS", "tags": "backjoon, DFS, BFS, silver2", "date": "2022-06-23 18:50:23 +0900", "snippet": "백준 침투풀이bfs를 통해 해결할 수 있는 문제import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;class Pos{ int x; int y; public Pos(int y, int x){ this.y = y; this.x = x; }}public class Main { public static ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); public static boolean visited[][]; public static int dx[] = {0, 0, -1, 1}; public static int dy[] = {-1, 1, 0, 0}; public static boolean ans = false; public static void main(String args[]) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); visited = new boolean[N][M]; for(int i=0; i&amp;lt;N; i++) list.add(new ArrayList&amp;lt;&amp;gt;()); for(int i=0; i&amp;lt;N; i++){ st = new StringTokenizer(br.readLine()); String str = st.nextToken(); for(int j=0; j&amp;lt;M; j++){ list.get(i).add(str.charAt(j) - 48); } } for(int i=0; i&amp;lt;M; i++){ if(list.get(0).get(i) == 0) bfs(new Pos(0, i), N, M); } if(ans) System.out.println(&quot;YES&quot;); else System.out.println(&quot;NO&quot;); } public static void bfs(Pos start, int N, int M){ Queue&amp;lt;Pos&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(start); visited[0][start.x] = true; while(!queue.isEmpty()){ Pos cur = queue.poll(); if(cur.y == N-1){ ans = true; return; } for(int i=0; i&amp;lt;4; i++) { int nextY = cur.y + dy[i]; int nextX = cur.x + dx[i]; if (nextX &amp;gt;= 0 &amp;amp;&amp;amp; nextX &amp;lt; M &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt; N) { if (!visited[nextY][nextX] &amp;amp;&amp;amp; list.get(nextY).get(nextX) == 0) { visited[nextY][nextX] = true; queue.add(new Pos(nextY, nextX)); } } } } }}" }, { "title": "백준 숨바꼭질", "url": "/posts/back-6118/", "categories": "PS, DFS-BFS", "tags": "backjoon, DFS, BFS, silver1", "date": "2022-06-23 04:01:23 +0900", "snippet": "백준 숨바꼭질풀이bfs를 돌려서 깊이를 세어서 중복되는 위치의 수와 가장 낮은 위치를 출력해 주기만 하면되는 전형적인 그래프 문제첫 제출은 2차원 배열을 사용해서 그런지 메모리 초과가 나왔는데 ArrayList로 해결import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;public class Main { public static int depth[]; public static boolean visited[]; public static ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; map = new ArrayList&amp;lt;&amp;gt;(); public static int max; public static void main(String args[]) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int nodeNum = Integer.parseInt(st.nextToken()); int edgeNum = Integer.parseInt(st.nextToken()); visited = new boolean[nodeNum+1]; depth = new int[nodeNum+1]; for(int i=0; i&amp;lt;=nodeNum; i++) map.add(new ArrayList&amp;lt;&amp;gt;()); for(int i=0; i&amp;lt;edgeNum; i++){ st = new StringTokenizer(br.readLine()); int a = Integer.parseInt(st.nextToken()); int b = Integer.parseInt(st.nextToken()); map.get(a).add(b); map.get(b).add(a); } bfs(1); ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); int dup = 0; for(int i=1; i&amp;lt;depth.length; i++){ if(max == depth[i]){ list.add(i); dup++; } } Collections.sort(list); int minIdx = list.get(0); System.out.print(minIdx + &quot; &quot; + depth[minIdx] + &quot; &quot; + dup); } public static void bfs(int start){ Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(start); visited[start] = true; depth[start] = 0; while(!queue.isEmpty()){ int cur = queue.poll(); for(int num : map.get(cur)){ if(num!=0 &amp;amp;&amp;amp; !visited[num]){ queue.add(num); visited[num] = true; depth[num] = depth[cur]+1; max = depth[num]; } } } }}" }, { "title": "프로그래머스 비밀지도", "url": "/posts/programmers-treasure/", "categories": "PS, implements", "tags": "programmers, implements, level1", "date": "2022-06-23 03:05:23 +0900", "snippet": "프로그래머스 비밀지도풀이 간단한 구현 문제 소요 시간 약 10분 다른 사람의 풀이를 보니 머리가 띵했다.. 이렇게도 풀 수 있구나 .. 내가 푼 풀이import java.io.IOException;import java.util.ArrayList;class Solution { public static String[] solution(int n, int[] arr1, int[] arr2) { ArrayList&amp;lt;String&amp;gt; list1 = new ArrayList&amp;lt;&amp;gt;(); ArrayList&amp;lt;String&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;(); for(int i=0; i&amp;lt;arr1.length; i++){ list1.add(toBinary(arr1[i], n)); list2.add(toBinary(arr2[i], n)); } String[] answer = new String[n]; for(int i=0; i &amp;lt; list1.size(); i++){ StringBuilder sb = new StringBuilder(); for(int j=0; j&amp;lt;list1.size(); j++) { if (list1.get(i).charAt(j) == &#39;1&#39; || list2.get(i).charAt(j) ==&#39;1&#39;) sb.append(&quot;#&quot;); else sb.append(&quot; &quot;); } answer[i] = sb.toString(); } return answer; } public static String toBinary(int num, int pow){ StringBuilder sb = new StringBuilder(); while(num&amp;gt;0){ sb.insert(0,Integer.toString(num%2)); num /= 2; } if(pow &amp;gt; sb.length()){ for(int i=sb.length(); i&amp;lt; pow; i++) sb.insert(0,&quot;0&quot;); } return sb.toString(); }}다른 사람 풀이class Solution { public String[] solution(int n, int[] arr1, int[] arr2) { String[] result = new String[n]; for (int i = 0; i &amp;lt; n; i++) { result[i] = Integer.toBinaryString(arr1[i] | arr2[i]); } for (int i = 0; i &amp;lt; n; i++) { result[i] = String.format(&quot;%&quot; + n + &quot;s&quot;, result[i]); result[i] = result[i].replaceAll(&quot;1&quot;, &quot;#&quot;); result[i] = result[i].replaceAll(&quot;0&quot;, &quot; &quot;); } return result; }}" }, { "title": "프로그래머스 실패율", "url": "/posts/programmers-failedRatio/", "categories": "PS, Sort", "tags": "programmers, sort, level1", "date": "2022-06-11 03:52:23 +0900", "snippet": "프로그래머스 실패율풀이 개인적으로 지금까지 푼 프로그래머스 문제 중 제일 오래 걸렸다 예외 잡느라 -_-… 정렬은 많이 약하구나 느꼈고 정렬도 많이 연습해야 겠다 소요 시간 약 1시간 30분import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;class Solution { public static int[] solution(int N, int[] stages) { int[] answer = new int[N]; Arrays.sort(stages); Map&amp;lt;Integer, Double&amp;gt; stageRatio = new HashMap&amp;lt;&amp;gt;(); for(int i=1; i&amp;lt;=N; i++){ int curStageNum = 0; int noClear = 0; if(i &amp;gt; stages[stages.length-1] ) stageRatio.put(i, 0.0); else{ for (int j = 0; j &amp;lt; stages.length; j++) { if (stages[j] &amp;gt;= i) curStageNum++; if (stages[j] == i &amp;amp;&amp;amp; stages[j] &amp;gt;= i) noClear++; } stageRatio.put(i, (double) noClear / (double) curStageNum); } } List&amp;lt;Integer&amp;gt; keySetList = new ArrayList&amp;lt;&amp;gt;(stageRatio.keySet()); Collections.sort(keySetList, (o1, o2) -&amp;gt; (stageRatio.get(o2).compareTo(stageRatio.get(o1)))); int cnt = 0; for(var a: keySetList) answer[cnt++] = a; return answer; }}" }, { "title": "프로그래머스 신규 아이디 추천", "url": "/posts/programmers-newId/", "categories": "PS, DFS-BFS", "tags": "programmers, implements, level1", "date": "2022-06-10 18:01:23 +0900", "snippet": "프로그래머스 카카오 신규 아이디 추천1단계 new_id의 모든 대문자를 대응되는 소문자로 치환합니다.2단계 new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.3단계 new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.4단계 new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.5단계 new_id가 빈 문자열이라면, new_id에 &quot;a&quot;를 대입합니다.6단계 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다. 만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.7단계 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.풀이 IDE 환경에서는 StringBuilder의 isEmpty() 메서드가 돌아 가지만 프로그래머스에서는 돌아가지 않아서 length 함수로 문자열이 비어 있는지 확인 하였다. 소요 시간 약 25분 import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;class Solution { public String solution(String new_id) { new_id = new_id.toLowerCase(); StringBuilder sbNew_id = new StringBuilder(new_id); for(int i=0; i&amp;lt;sbNew_id.length(); i++){ char curChar = sbNew_id.charAt(i); // new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다. if( !(curChar &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; curChar &amp;lt;=&#39;z&#39;) &amp;amp;&amp;amp; curChar !=&#39;-&#39; &amp;amp;&amp;amp; curChar != &#39;_&#39; &amp;amp;&amp;amp; curChar != &#39;.&#39; &amp;amp;&amp;amp; !(curChar &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; curChar &amp;lt;=&#39;9&#39;)){ sbNew_id.deleteCharAt(i); i --; } } // new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다. for(int i=0; i&amp;lt;sbNew_id.length()-1; i++){ if(sbNew_id.charAt(i) == &#39;.&#39; &amp;amp;&amp;amp; sbNew_id.charAt(i+1) == &#39;.&#39;){ sbNew_id.deleteCharAt(i); i--; } } // new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다. if(sbNew_id.charAt(0) == &#39;.&#39;) sbNew_id.deleteCharAt(0); else if(sbNew_id.charAt(sbNew_id.length()-1) == &#39;.&#39;) sbNew_id.deleteCharAt(sbNew_id.length()-1); // new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다. if(sbNew_id.length() == 0) sbNew_id.append(&quot;a&quot;); // new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다. // 만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다 if(sbNew_id.length() &amp;gt;= 16) sbNew_id = sbNew_id.delete(15,sbNew_id.length()+1); if(sbNew_id.charAt(sbNew_id.length()-1) == &#39;.&#39; ) sbNew_id.deleteCharAt(sbNew_id.length()-1); //new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다. if(sbNew_id.length() &amp;lt;= 2){ char last = sbNew_id.charAt(sbNew_id.length()-1); for(int i=sbNew_id.length(); i&amp;lt;3; i++){ sbNew_id.append(last); } } String answer = sbNew_id.toString(); return answer; }}" }, { "title": "프로그래머스 신고 결과 받기", "url": "/posts/programmes-report/", "categories": "PS, implements", "tags": "programmers, level1", "date": "2022-06-09 23:35:23 +0900", "snippet": "프로그래머스 신고 결과 받기풀이 소요 시간 약 30분class Solution { public static int[] solution(String[] id_list, String[] report, int k) { HashMap&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); // 신고당한 횟수 String stopUser [] = new String[id_list.length]; // 정지 당해야할 유저 HashMap&amp;lt;String, ArrayList&amp;lt;String&amp;gt;&amp;gt; user_rpList = new HashMap&amp;lt;&amp;gt;(); int cnt = 0; int[] answer = new int[id_list.length]; // 유저별 신고 당한 횟수 담는 맵 초기화, 유저가 신고한 아이디 리스트 초기화 for(var id : id_list) { map.put(id, 0); user_rpList.put(id, new ArrayList&amp;lt;&amp;gt;()); } // 유저별 신고 당한 횟수 Loop: for(int i=0; i &amp;lt; report.length; i++){ boolean check = false; StringTokenizer st = new StringTokenizer(report[i],&quot; &quot;); String user = st.nextToken(); String rp_user = st.nextToken(); var tmp = user_rpList.get(user); // 신고한 유저의 신고 목록 ArrayList for(var name: tmp) { if(name.equals(rp_user)) // 만약 이미 신고를 했었으면 목록에 추가하지 않고 건너뛰기 continue Loop; } user_rpList.get(user).add(rp_user); map.replace(rp_user, map.get(rp_user)+1); } // 신고 당한 횟수가 정지 기준을 넘으면 정지처리 for(int i=0; i&amp;lt;id_list.length; i++) { if (map.get(id_list[i]) &amp;gt;= k) stopUser[cnt++] = id_list[i]; } // 자기가 신고한 게정이 몇개 정지 되었는지 개수를 샘 for(int i=0; i&amp;lt; id_list.length; i++){ var tmp = user_rpList.get(id_list[i]); for(var name : tmp){ for(int j=0; j&amp;lt; stopUser.length; j++){ if(name.equals(stopUser[j])){ answer[i]++; } } } } return answer; }}" }, { "title": "프로그래머스 카카오 프렌즈 컬러링 북", "url": "/posts/programmers/", "categories": "PS, DFS-BFS", "tags": "programmers, DFS, BFS, level2", "date": "2022-06-09 23:35:23 +0900", "snippet": "프로그래머스 카카오 프렌즈 컬러링 북풀이 bfs를 이용하여 해결 소요 시간 약 20분 class Pos{ public int x; public int y; public Pos(int y, int x){ this.y = y; this.x = x; }}class Solution { int dx[] = {0, 0, -1, 1}; // 상 하 좌 우 int dy[] = {-1, 1, 0, 0}; boolean visited[][]; PriorityQueue&amp;lt;Integer&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;(Collections.reverseOrder()); public int[] solution(int m, int n, int[][] picture) { int numberOfArea = 0; int maxSizeOfOneArea = 0; visited = new boolean[m][n]; for(int i=0; i&amp;lt;m; i++){ for(int j=0; j&amp;lt;n; j++){ if(visited[i][j] == false &amp;amp;&amp;amp; picture[i][j] != 0){ numberOfArea++; bfs(i, j, picture[i][j], picture); } } } maxSizeOfOneArea = pq.poll(); int[] answer = new int[2]; answer[0] = numberOfArea; answer[1] = maxSizeOfOneArea; return answer; } public void bfs(int y, int x, int sig, int [][] picture){ Queue&amp;lt;Pos&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(new Pos(y,x)); visited[y][x] = true; int len = 1; while(!queue.isEmpty()){ Pos tmp = queue.poll(); int curX = tmp.x; int curY = tmp.y; for(int i=0; i&amp;lt;4; i++){ int nextY = curY + dy[i]; int nextX = curX + dx[i]; if(nextX &amp;gt;= 0 &amp;amp;&amp;amp; nextX &amp;lt; picture[0].length &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt; picture.length){ if(picture[nextY][nextX] == sig &amp;amp;&amp;amp; visited[nextY][nextX] == false){ visited[nextY][nextX] = true; len++; queue.add(new Pos(nextY,nextX)); } } } } pq.add(len); }}" }, { "title": "특정 거리의 도시 찾기 (18352)", "url": "/posts/back-18352/", "categories": "PS, DFS-BFS", "tags": "backjoon, DFS, BFS, silver2", "date": "2022-05-26 15:28:23 +0900", "snippet": "특정 거리의 도시 찾기 (18352)풀이 출발 노드 기준으로 bfs를 돌리면서 거리를 배열에 기록해주면 된다.import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); }}public class Main { static int n; // 정점 수 static int m; // 엣지 수 static int k; // 최소 거리 static int x; // 출발 정점 static ArrayList&amp;lt;Integer&amp;gt; list[]; static int dis[]; static boolean visited[]; public static void main(String args[]) throws IOException { FastScanner sc = new FastScanner(); n = sc.nextInt(); m = sc.nextInt(); k = sc.nextInt(); x = sc.nextInt(); list = new ArrayList[n+1]; dis = new int[n+1]; visited = new boolean[n+1]; for(int i=0; i &amp;lt;= n; i++) list[i] = new ArrayList&amp;lt;&amp;gt;(); for(int i=0; i&amp;lt;m; i++){ int a = sc.nextInt(); int b = sc.nextInt(); list[a].add(b); } bfs(x); boolean isExist = false; for(int i=1; i&amp;lt;=n; i++){ if(dis[i] == k) { System.out.println(i); isExist = true; } } if(!isExist) System.out.println(&quot;-1&quot;); } public static void bfs(int start) { Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(start); visited[start] = true; while(!queue.isEmpty()){ int cur = queue.poll(); for(var next : list[cur]){ if(!visited[next]){ visited[next] = true; queue.add(next);~~~~~~ dis[next] = dis[cur] +1; } } } }}" }, { "title": "효율적인 해킹(1325)", "url": "/posts/back-1325/", "categories": "PS, DFS-BFS", "tags": "backjoon, DFS, BFS, silver1", "date": "2022-05-26 15:28:23 +0900", "snippet": "효율적인 해킹(1325)풀이 이번 문제는 메모리 초과떠서 어지러웠다.. 2차원 배열을 Arraylist로 바꾸어서 해결하니까 통과 하였다.import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); }}public class Main { static int n; // Computer size static int m; // Edge size static ArrayList&amp;lt;Integer&amp;gt; computer[]; static int countVisit []; static boolean visited[]; static int cnt = 0; static Vector&amp;lt;Hacking&amp;gt; pq = new Vector&amp;lt;&amp;gt;(); public static void main(String args[]) throws IOException { FastScanner sc = new FastScanner(); n = sc.nextInt(); m = sc.nextInt(); computer = new ArrayList[n+1]; countVisit = new int[n+1]; for(int i=1; i&amp;lt;=n; i++) computer[i] = new ArrayList&amp;lt;&amp;gt;(); for(int i=0; i&amp;lt;m; i++){ int a = sc.nextInt(); int b = sc.nextInt(); computer[a].add(b); } for(int i=1; i&amp;lt;=n; i++){ cnt = 1; bfs(i); } for(int i=1; i&amp;lt;=n; i++) pq.add(new Hacking(i,countVisit[i])); Collections.sort(pq, new Comparator&amp;lt;Hacking&amp;gt;() { public int compare(Hacking p1, Hacking p2) { if(p1.cost &amp;gt; p2.cost) { return -1; } else if(p1.cost == p2.cost) { return Integer.compare(p1.num, p2.num); } else { return 1; } } }); int max = pq.get(0).cost; for(int i=0; i&amp;lt;pq.size(); i++){ if(max != pq.get(i).cost) break; System.out.print(pq.get(i).num + &quot; &quot;); } } public static void bfs(int start){ visited = new boolean[n+1]; Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(start); visited[start] = true; while(!queue.isEmpty()){ int cur = queue.poll(); for(var next : computer[cur]){ if(!visited[next]){ visited[next] = true; queue.add(next); countVisit[next]++; } } } }}class Hacking{ int num; int cost; public Hacking(int num, int cost){ this.num = num; this.cost = cost; }}" }, { "title": "단지 번호 붙히기(2667)", "url": "/posts/back-2667/", "categories": "PS, DFS-BFS", "tags": "backjoon, DFS, BFS, silver1", "date": "2022-05-25 17:55:23 +0900", "snippet": "단지 번호 붙히기(2667)풀이 bfs를 통해 상하 좌우를 살피면서 그룹에 속한 집을 세주면 된다.import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); }}class Point{ int x; int y; public Point(int x, int y){ this.x = x; this.y = y; } public int getX(){ return this.x; } public int getY(){ return this.y; }}public class Main { static int arr[][]; static boolean visited[][]; static int dx[] = {0, 0, -1, 1}; // 상, 하, 좌, 우 static int dy[] = {-1, 1, -0, 0,}; static Vector&amp;lt;Integer&amp;gt; ans = new Vector&amp;lt;&amp;gt;(); public static void main(String args[]) throws IOException { FastScanner sc = new FastScanner(); int n = sc.nextInt(); // 가로 세로 arr = new int[n][n]; visited = new boolean[n][n]; for(int i=0; i&amp;lt;n; i++){ String str = sc.next(); for(int j=0; j&amp;lt;n; j++) arr[i][j] = str.charAt(j) - &#39;0&#39;; } int cnt = 0; for(int i=0; i&amp;lt;n; i++) { for(int j=0; j&amp;lt;n; j++){ if(arr[i][j] == 1 &amp;amp;&amp;amp; !visited[i][j]){ bfs(n, j, i); cnt++; } } } System.out.println(cnt); Collections.sort(ans); for(var num : ans) System.out.println(num); } public static void bfs(int n, int pointX, int pointY) { Queue&amp;lt;Point&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(new Point(pointX, pointY)); visited[pointY][pointX] = true; int cnt = 1; while(!queue.isEmpty()){ Point cur = queue.poll(); for(int i=0; i&amp;lt;4; i++) { int nextX = cur.getX() + dx[i]; int nextY = cur.getY() + dy[i]; if(nextX &amp;gt;= 0 &amp;amp;&amp;amp; nextX &amp;lt;n &amp;amp;&amp;amp; nextY &amp;gt;=0 &amp;amp;&amp;amp; nextY &amp;lt; n &amp;amp;&amp;amp; !visited[nextY][nextX] &amp;amp;&amp;amp; arr[nextY][nextX] == 1){ visited[nextY][nextX] = true; queue.add(new Point(nextX,nextY)); cnt++; } } } ans.add(cnt); }}" }, { "title": "미로 탐색(2178)", "url": "/posts/back-2178/", "categories": "PS, DFS-BFS", "tags": "backjoon, DFS, BFS, silver1", "date": "2022-05-24 00:09:23 +0900", "snippet": "미로 탐색(2178)풀이 상하 좌우를 살피면서 bfs를 통해 이동한 횟수를 적어주고 목적지까지의 이동한 횟수를 출력해주면 된다.import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); }}class Point{ int x; int y; public Point(int x, int y){ this.x = x; this.y = y; } public int getX(){ return this.x; } public int getY(){ return this.y; }}public class Main { static int arr[][]; static boolean visited[][]; static int dx[] = {0, 0, -1, 1}; // 상, 하, 좌, 우 static int dy[] = {-1, 1, -0, 0,}; static int distance[][]; public static void main(String args[]) throws IOException { FastScanner sc = new FastScanner(); int n = sc.nextInt(); // 세로 int m = sc.nextInt(); // 가로 arr = new int[n][m]; visited = new boolean[n][m]; distance = new int[n][m]; for(int i=0; i&amp;lt;n; i++){ String str = sc.next(); for(int j=0; j&amp;lt;m; j++) arr[i][j] = str.charAt(j) - &#39;0&#39;; } bfs(n, m); System.out.println(distance[n-1][m-1]); } public static void bfs(int n, int m) { Queue&amp;lt;Point&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(new Point(0,0)); visited[0][0] = true; distance[0][0] = 1; while(!queue.isEmpty()){ Point cur = queue.poll(); for(int i=0; i&amp;lt;4; i++) { int nextX = cur.getX() + dx[i]; int nextY = cur.getY() + dy[i]; if(nextX &amp;gt;= 0 &amp;amp;&amp;amp; nextX &amp;lt;m &amp;amp;&amp;amp; nextY &amp;gt;=0 &amp;amp;&amp;amp; nextY &amp;lt; n &amp;amp;&amp;amp; !visited[nextY][nextX] &amp;amp;&amp;amp; arr[nextY][nextX] == 1){ distance[nextY][nextX] = distance[cur.getY()][cur.getX()] + 1; visited[nextY][nextX] = true; queue.add(new Point(nextX,nextY)); } } } }}" }, { "title": "연결 요소의 개수(11724)", "url": "/posts/back-11724/", "categories": "PS, DFS-BFS", "tags": "backjoon, DFS, BFS, silver2", "date": "2022-05-23 18:37:23 +0900", "snippet": "연결 요수의 개수 (11724)풀이 방문하지 않은 노드들을 bfs 돌려 연결된 그룹의 수를 세주면 된다.import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); }}public class Main { static int arr[][]; static boolean visited[]; public static void main(String args[]) throws IOException { FastScanner sc = new FastScanner(); int n = sc.nextInt(); // 정점 int m = sc.nextInt(); // 간선 int cnt = 0; arr = new int[n+1][n+1]; visited = new boolean[n+1]; for(int i=0; i&amp;lt;m; i++){ int a = sc.nextInt(); int b = sc.nextInt(); arr[a][b] = 1; arr[b][a] = 1; } for(int i=1; i&amp;lt;=n; i++){ if(!visited[i]) { bfs(i, n); cnt++; } } System.out.println(cnt); } public static void bfs(int start, int n) { Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(start); while(!queue.isEmpty()){ int cur = queue.poll(); for(int i=1; i&amp;lt;=n; i++){ if(arr[cur][i] == 1 &amp;amp;&amp;amp; !visited[i]){ visited[i] = true; queue.add(i); } } } }}" }, { "title": "섬의 개수", "url": "/posts/back-4963/", "categories": "PS, DFS-BFS", "tags": "backjoon, DFS, BFS, silver2", "date": "2022-05-23 17:52:23 +0900", "snippet": "촌수 계산(2644)풀이 알고리즘 과목 수강할때 비슷한 문제를 풀어봐서 금방 해결하였다. 육지이고 방문하지 않은 위치를 기준으로 bfs를 하는데 상, 하, 좌, 우, 대각선을 전부 확인하면 된다. import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); }}class Point { int w; int h; public Point(int w,int h) { this.w = w; this.h = h; } public int getW() { return this.w; } public int getH() { return this.h; }}public class Main { static int arr[][]; static boolean visited[][]; static int dx[] = {0, 0 ,-1, 1, -1, 1, -1, 1}; // 상, 하, 좌, 우, 상좌, 상우, 하좌, 하우 static int dy[] = {-1, 1, 0, 0, -1, -1, 1, 1 }; public static void main(String args[]) throws IOException { FastScanner sc = new FastScanner(); while(true) { int w = sc.nextInt(); // 가로 int h = sc.nextInt(); // 세로 int cnt = 0; if(w == 0 &amp;amp;&amp;amp; h == 0) break; arr = new int[h][w]; visited = new boolean[h][w]; for(int i=0; i&amp;lt;h; i++) for(int j=0; j&amp;lt;w; j++) arr[i][j] = sc.nextInt(); for(int i=0; i&amp;lt;h; i++) { for (int j = 0; j &amp;lt; w; j++) { if(arr[i][j] == 1 &amp;amp;&amp;amp; !visited[i][j]) { visited[i][j] = true; bfs(new Point(j,i), w, h); cnt ++; } } } System.out.println(cnt); } } public static void bfs(Point p, int w, int h) { Queue&amp;lt;Point&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(p); while(!queue.isEmpty()){ Point tmp = queue.poll(); int curW = tmp.getW(); int curH = tmp.getH(); for(int i=0; i&amp;lt;8; i++){ int nextW = curW + dx[i]; int nextH = curH + dy[i]; if(nextW &amp;gt;=0 &amp;amp;&amp;amp; nextW &amp;lt; w &amp;amp;&amp;amp; nextH &amp;gt;=0 &amp;amp;&amp;amp; nextH &amp;lt; h){ if(arr[nextH][nextW] == 1 &amp;amp;&amp;amp; !visited[nextH][nextW]){ visited[nextH][nextW] = true; queue.add(new Point(nextW,nextH)); } } } } }}" }, { "title": "촌수 계산", "url": "/posts/back-2644/", "categories": "PS, DFS-BFS", "tags": "backjoon, DFS, BFS, silver2", "date": "2022-05-23 03:48:23 +0900", "snippet": "촌수 계산(2644)풀이 bfs를 통해 깊이를 세주면 된다.import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); }}public class Main { static int arr[][]; static boolean visited[]; static int depth[]; public static void main(String args[]) throws IOException { FastScanner sc = new FastScanner(); int n = sc.nextInt(); // 전체 사람 수 (정점 수) int findX = sc.nextInt(); int findY = sc.nextInt(); int m = sc.nextInt(); // 부모 자식 관계 수 (간선 수) arr = new int[n+1][n+1]; visited = new boolean[n+1]; depth = new int[n+1]; for(int i=0; i&amp;lt;m; i++){ int a = sc.nextInt(); int b = sc.nextInt(); arr[a][b] = 1; arr[b][a] = 1; } bfs(findX, n); if(depth[findY] == 0) System.out.println(&quot;-1&quot;); else System.out.println(depth[findY]); } public static void bfs(int start,int n) { Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(start); while(!queue.isEmpty()){ int pos = queue.poll(); for(int i=1; i&amp;lt;=n; i++){ if(!visited[i] &amp;amp;&amp;amp; arr[pos][i] == 1){ queue.add(i); visited[i] = true; depth[i] = depth[pos] + 1; } } } }}" }, { "title": "유기농 배추", "url": "/posts/back-1012/", "categories": "PS, DFS-BFS", "tags": "backjoon, DFS, BFS, silver2", "date": "2022-05-23 02:56:23 +0900", "snippet": "유기농 배추(1012)풀이 bfs를 통해 연결된 그룹의 수를 세어주면 된다.import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); }}class Pos { public int x; public int y; public Pos(int x, int y) { this.x = x; this.y = y; } public int getX() { return this.x; } public int getY() { return this.y; }}public class Main { static int arr[][]; static boolean visited[][]; static int checkX[] = {0, 0, -1, 1}; // 상, 하, 좌, 우 static int checkY[] = {-1, 1, 0, 0}; static int M; static int N; static int K; public static void main(String args[]) throws IOException { FastScanner sc = new FastScanner(); int T = sc.nextInt(); // Test Case for (int j = 0; j &amp;lt; T; j++) { Queue&amp;lt;Pos&amp;gt; cabbage = new LinkedList&amp;lt;&amp;gt;(); int cnt = 0; M = sc.nextInt(); // 세로 길이 N = sc.nextInt(); // 가로 길이 K = sc.nextInt(); // 배추가 심어져 있는 수 arr = new int[M][N]; visited = new boolean[M][N]; for (int i = 0; i &amp;lt; K; i++) { int a = sc.nextInt(); // 세로 int b = sc.nextInt(); // 가로 cabbage.add(new Pos(b, a)); // 배추가 심어져 있는 위치 arr[a][b] = 1; } while (!cabbage.isEmpty()) { Pos tmp = cabbage.poll(); int x = tmp.getX(); int y = tmp.getY(); if(arr[y][x] == 1 &amp;amp;&amp;amp; !visited[y][x]) { bfs(x, y); cnt++; } } System.out.println(cnt); } } public static void bfs(int x, int y) { Queue&amp;lt;Pos&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(new Pos(x, y)); while (!queue.isEmpty()) { Pos Cur = queue.poll(); int curX = Cur.getX(); int curY = Cur.getY(); visited[y][x] = true; for (int i = 0; i &amp;lt; 4; i++) { int dx = curX + checkX[i]; int dy = curY + checkY[i]; if (dx &amp;gt;= 0 &amp;amp;&amp;amp; dx &amp;lt; N &amp;amp;&amp;amp; dy &amp;gt;= 0 &amp;amp;&amp;amp; dy &amp;lt; M) { // 범위를 벗어나지 않고 if (arr[dy][dx] == 1 &amp;amp;&amp;amp; !visited[dy][dx]) { queue.add(new Pos(dx, dy)); visited[dy][dx] = true; } } } } }}" }, { "title": "백준 dfs와 bfs", "url": "/posts/back-1206/", "categories": "PS, DFS-BFS", "tags": "backjoon, DFS, BFS, silver2", "date": "2022-05-22 00:01:23 +0900", "snippet": "백준 dfs와 bfs풀이bfs, dfs 구현만 해주면 되는 문제 dfs (깊이 우선 탐색)을 통해 방문 하는 노드의 수 세주기 bfs (너비 우선 탐색)을 통해 방문 하는 노드의 수 세주기import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.Stack;import java.util.StringTokenizer;class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); }}public class Main{ static int map[][]; static int visited[]; static int n; static int m; static int max = 1000; public static void main(String args[]) throws IOException{ FastScanner sc = new FastScanner(); n = sc.nextInt(); // 정점 m = sc.nextInt(); // 간선 int start = sc.nextInt(); // 시작점 map = new int[n+1][n+1]; for(int i=0; i&amp;lt;m; i++){ int a = sc.nextInt(); int b = sc.nextInt(); map[a][b] = 1; map[b][a] = 1; } visited = new int[max+1]; dfs(start); System.out.println(); for(int i=1; i&amp;lt;=max; i++){ visited[i] = 0; } bfs(start); } static void bfs(int point){ Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(point); visited[point] = 1; System.out.print(point); while(!queue.isEmpty()) { int x = queue.poll(); for(int i=1; i &amp;lt;= n; i++) if(visited[i] == 0 &amp;amp;&amp;amp; map[x][i] == 1){ queue.add(i); System.out.print(&quot; &quot; + i); visited[i] = 1; } } } static void dfs(int point){ Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); stack.push(point); visited[point] = 1; System.out.print(point + &quot; &quot;); while(!stack.isEmpty()){ for(int i=1; i&amp;lt;=n; i++){ if(map[point][i] == 1 &amp;amp;&amp;amp; visited[i] == 0){ stack.push(i); visited[i] = 1; dfs(i); } } stack.pop(); } }}" }, { "title": "운동 일지 1", "url": "/posts/Day1/", "categories": "Daily", "tags": "daily", "date": "2022-03-23 19:48:00 +0900", "snippet": "런닝 - Day12022-03-22런닝 - Day22022-03-23런닝 - Day32022-03-24런닝 - Day42022-03-25런닝 - Day52022-03-26런닝 - Day62022-03-27런닝 - Day72022-03-28 팔굽혀 펴기 윗몸 일으키기 런닝 컴네 인강 컴구 인강 컴네 정리2022-04-01데통 정리2022-04-02데통 정리 스페인어2022-04-03데통 인강2022-04-04컴구조 인강2022-04-05해킹 및 바이러스오픈 HW 강의2022-04-06해킹 및 바이러스컴네 인강컴구조 인강컴구조 과제스페인어 인강프로그래밍 튜터2022-04-06스페인어 강의오픈 HW 강의컴네 정리프로그래밍 튜터2022-04-08해킹 및 바이러스 정리프로그래밍 튜터2022-04-09패밀리 랜드 갔지만 사람 너무 많아서 포기하고 담양가서 떡갈비 먹고죽녹원 가서 이이남 스튜디오에서 작품 구경하면서 아이스크림 먹고수완 롯데마트에서 술 사고 에어비앤비2022-04-10컴네 인강해킹 및 바이러스2022-04-11스페인어 정리해킹 및 바이러스 챕터 3 까지 정리 완료컴구조 실강기말 아두이노 부품 조사2022-04-12스페인어 정리인강옷 쇼핑2022-04-13 s스페인어 인강 및 정리해킹 및 바이러스 인강컴구조 인강컴네 리딩오픈 HW 과제프로그래밍 튜터2022-04-14해킹 및 바이러스 정리 챕터 4스페인어 리딩프로그래밍 튜터2022-04-20해킹 및 바이러스 시험스페인어 복습컴퓨터구조 공부컴네 8주차 인강부터 들어야함" }, { "title": "한줄 일기 - 개인정보처리방침", "url": "/posts/%ED%95%9C%EC%A4%84-%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EB%B0%A9%EC%B9%A8/", "categories": "Android", "tags": "", "date": "2022-03-19 20:01:00 +0900", "snippet": "&amp;lt; 한줄일기 &amp;gt;(&#39;https://sey2.githun.io&#39;이하 &#39;한줄일기&#39;)은(는) 「개인정보 보호법」 제30조에 따라 정보주체의 개인정보를 보호하고 이와 관련한 고충을 신속하고 원활하게 처리할 수 있도록 하기 위하여 다음과 같이 개인정보 처리방침을 수립·공개합니다.○ 이 개인정보처리방침은 2022년 3월 19부터 적용됩니다.제1조(개인정보의 처리 목적)&amp;lt; 한줄일기 &amp;gt;(&#39;https://sey2.githun.io&#39;이하 &#39;한줄일기&#39;)은(는) 다음의 목적을 위하여 개인정보를 처리합니다. 처리하고 있는 개인정보는 다음의 목적 이외의 용도로는 이용되지 않으며 이용 목적이 변경되는 경우에는 「개인정보 보호법」 제18조에 따라 별도의 동의를 받는 등 필요한 조치를 이행할 예정입니다.1. 재화 또는 서비스 제공콘텐츠 제공을 목적으로 개인정보를 처리합니다.제2조(개인정보의 처리 및 보유 기간)① &amp;lt; 한줄일기 &amp;gt;은(는) 법령에 따른 개인정보 보유·이용기간 또는 정보주체로부터 개인정보를 수집 시에 동의받은 개인정보 보유·이용기간 내에서 개인정보를 처리·보유합니다.② 각각의 개인정보 처리 및 보유 기간은 다음과 같습니다.1.&amp;lt;재화 또는 서비스 제공&amp;gt;&amp;lt;재화 또는 서비스 제공&amp;gt;와 관련한 개인정보는 수집.이용에 관한 동의일로부터&amp;lt;준영구&amp;gt;까지 위 이용목적을 위하여 보유.이용됩니다.보유근거 : 정보주체동의관련법령 :예외사유 :제3조(정보주체와 법정대리인의 권리·의무 및 그 행사방법)① 정보주체는 한줄일기에 대해 언제든지 개인정보 열람·정정·삭제·처리정지 요구 등의 권리를 행사할 수 있습니다.② 제1항에 따른 권리 행사는한줄일기에 대해 「개인정보 보호법」 시행령 제41조제1항에 따라 서면, 전자우편, 모사전송(FAX) 등을 통하여 하실 수 있으며 한줄일기은(는) 이에 대해 지체 없이 조치하겠습니다.③ 제1항에 따른 권리 행사는 정보주체의 법정대리인이나 위임을 받은 자 등 대리인을 통하여 하실 수 있습니다.이 경우 “개인정보 처리 방법에 관한 고시(제2020-7호)” 별지 제11호 서식에 따른 위임장을 제출하셔야 합니다.④ 개인정보 열람 및 처리정지 요구는 「개인정보 보호법」 제35조 제4항, 제37조 제2항에 의하여 정보주체의 권리가 제한 될 수 있습니다.⑤ 개인정보의 정정 및 삭제 요구는 다른 법령에서 그 개인정보가 수집 대상으로 명시되어 있는 경우에는 그 삭제를 요구할 수 없습니다.⑥ 한줄일기은(는) 정보주체 권리에 따른 열람의 요구, 정정·삭제의 요구, 처리정지의 요구 시 열람 등 요구를 한 자가 본인이거나 정당한 대리인인지를 확인합니다.제4조(처리하는 개인정보의 항목 작성)① &amp;lt; 한줄일기 &amp;gt;은(는) 다음의 개인정보 항목을 처리하고 있습니다.1&amp;lt; 재화 또는 서비스 제공 &amp;gt;필수항목 : 사진선택항목 :제5조(개인정보의 파기)① &amp;lt; 한줄일기 &amp;gt; 은(는) 개인정보 보유기간의 경과, 처리목적 달성 등 개인정보가 불필요하게 되었을 때에는 지체없이 해당 개인정보를 파기합니다.② 정보주체로부터 동의받은 개인정보 보유기간이 경과하거나 처리목적이 달성되었음에도 불구하고 다른 법령에 따라 개인정보를 계속 보존하여야 하는 경우에는, 해당 개인정보를 별도의 데이터베이스(DB)로 옮기거나 보관장소를 달리하여 보존합니다.1. 법령 근거 :2. 보존하는 개인정보 항목 : 계좌정보, 거래날짜③ 개인정보 파기의 절차 및 방법은 다음과 같습니다.1. 파기절차&amp;lt; 한줄일기 &amp;gt; 은(는) 파기 사유가 발생한 개인정보를 선정하고, &amp;lt; 한줄일기 &amp;gt; 의 개인정보 보호책임자의 승인을 받아 개인정보를 파기합니다.2. 파기방법전자적 파일 형태의 정보는 기록을 재생할 수 없는 기술적 방법을 사용합니다제6조(개인정보의 안전성 확보 조치)&amp;lt; 한줄일기 &amp;gt;은(는) 개인정보의 안전성 확보를 위해 다음과 같은 조치를 취하고 있습니다.1. 내부관리계획의 수립 및 시행개인정보의 안전한 처리를 위하여 내부관리계획을 수립하고 시행하고 있습니다.2. 개인정보에 대한 접근 제한개인정보를 처리하는 데이터베이스시스템에 대한 접근권한의 부여,변경,말소를 통하여 개인정보에 대한 접근통제를 위하여 필요한 조치를 하고 있으며 침입차단시스템을 이용하여 외부로부터의 무단 접근을 통제하고 있습니다.3. 비인가자에 대한 출입 통제개인정보를 보관하고 있는 물리적 보관 장소를 별도로 두고 이에 대해 출입통제 절차를 수립, 운영하고 있습니다.제7조(개인정보 자동 수집 장치의 설치•운영 및 거부에 관한 사항)한줄일기 은(는) 정보주체의 이용정보를 저장하고 수시로 불러오는 ‘쿠키(cookie)’를 사용하지 않습니다.제8조 (개인정보 보호책임자)① 한줄일기 은(는) 개인정보 처리에 관한 업무를 총괄해서 책임지고, 개인정보 처리와 관련한 정보주체의 불만처리 및 피해구제 등을 위하여 아래와 같이 개인정보 보호책임자를 지정하고 있습니다.▶ 개인정보 보호책임자성명 :박세영직책 :개발자직급 :없음연락처 :010-2024-2978, casio2978@naver.com,※ 개인정보 보호 담당부서로 연결됩니다.▶ 개인정보 보호 담당부서부서명 :담당자 :연락처 :, ,② 정보주체께서는 한줄일기 의 서비스(또는 사업)을 이용하시면서 발생한 모든 개인정보 보호 관련 문의, 불만처리, 피해구제 등에 관한 사항을 개인정보 보호책임자 및 담당부서로 문의하실 수 있습니다. 한줄일기 은(는) 정보주체의 문의에 대해 지체 없이 답변 및 처리해드릴 것입니다.제9조(개인정보 열람청구)정보주체는 ｢개인정보 보호법｣ 제35조에 따른 개인정보의 열람 청구를 아래의 부서에 할 수 있습니다.&amp;lt; 한줄일기 &amp;gt;은(는) 정보주체의 개인정보 열람청구가 신속하게 처리되도록 노력하겠습니다.▶ 개인정보 열람청구 접수·처리 부서부서명 :담당자 :연락처 : , ,제10조(권익침해 구제방법)정보주체는 개인정보침해로 인한 구제를 받기 위하여 개인정보분쟁조정위원회, 한국인터넷진흥원 개인정보침해신고센터 등에 분쟁해결이나 상담 등을 신청할 수 있습니다. 이 밖에 기타 개인정보침해의 신고, 상담에 대하여는 아래의 기관에 문의하시기 바랍니다.1. 개인정보분쟁조정위원회 : (국번없이) 1833-6972 (www.kopico.go.kr)2. 개인정보침해신고센터 : (국번없이) 118 (privacy.kisa.or.kr)3. 대검찰청 : (국번없이) 1301 (www.spo.go.kr)4. 경찰청 : (국번없이) 182 (ecrm.cyber.go.kr)「개인정보보호법」제35조(개인정보의 열람), 제36조(개인정보의 정정·삭제), 제37조(개인정보의 처리정지 등)의 규정에 의한 요구에 대 하여 공공기관의 장이 행한 처분 또는 부작위로 인하여 권리 또는 이익의 침해를 받은 자는 행정심판법이 정하는 바에 따라 행정심판을 청구할 수 있습니다.※ 행정심판에 대해 자세한 사항은 중앙행정심판위원회(www.simpan.go.kr) 홈페이지를 참고하시기 바랍니다.제11조(개인정보 처리방침 변경)① 이 개인정보처리방침은 2022년 3월 19부터 적용됩니다.② 이전의 개인정보 처리방침은 아래에서 확인하실 수 있습니다.예시 ) - 20XX. X. X ~ 20XX. X. X 적용 (클릭)예시 ) - 20XX. X. X ~ 20XX. X. X 적용 (클릭)예시 ) - 20XX. X. X ~ 20XX. X. X 적용 (클릭)" }, { "title": "코틀린 기본 문법 (함수)", "url": "/posts/basic4/", "categories": "Kotlin, basic", "tags": "kotlin", "date": "2022-03-08 17:06:00 +0900", "snippet": "funfun double(x: Int): Int{ return 2 * x }함수 정의는 fun 키워드를 사용한다.함수 사용val result = double(2)함수 호출Stream().read()함수 파라미터는 Pascal notation 을 써서 정의한다.각 파라미터는 type 이 정의되어야 한다.fun powerOf(number: Int, exponent: Int) { /*...*/ }파라미터함수 파라미터는 argument 가 생략 된 경우에 할당되는 해당 파라미터의 기본 값을 가질 수 있다.fun read(b: Array&amp;lt;Byte&amp;gt;, off: Int = 0, len: Int = b.size) { /*...*/ } 본 값은 type 과 값 사이에 = 를 사용하여 정의한다.overriding method 는 항상 base method 와 같은 기본 파라미터 값을 쓴다.기본 파라미터 값을 가진 method 를 overriding 할 때는 기본 값 할당 표현을 생략할 수 있다.open class A { open fun foo(i: Int = 10) { /*...*/ } } class B : A() { override fun foo(i: Int) { /*...*/ } }함수의 인자 항목에서 기본 값이 있는 파라미터가 기본 값이 없는 파라미터 보다 앞에 위치하면, 기본 값은 named arguments (아래에서 설명) 로 함수를 호출할 때만 쓰이게 된다.fun foo(bar: Int = 0, baz: Int) { /*...*/ } foo(baz = 1) // The default value bar = 0 is used함수의 인자 항목에서 기본값을 가진 파라미터 뒤에 위치한 마지막 인자가 lambda 인 경우, named argument 나 outside the parentheses 로 전달 될 수 있다.fun foo(bar: Int = 0, baz: Int = 1, qux: () -&amp;gt; Unit) { /*...*/ } foo(1) { println(&quot;hello&quot;) } // Uses the default value baz = 1 foo(qux = { println(&quot;hello&quot;) }) // Uses both default values bar = 0 and baz = 1 foo { println(&quot;hello&quot;) } // Uses both default values bar = 0 and baz = 1함수 호출 시 파라미터의 이름을 사용할 수 있다.fun reformat(str: String, normalizeCase: Boolean = true, upperCaseFirstLetter: Boolean = true, divideByCamelHumps: Boolean = false, wordSeparator: Char = &#39; &#39;) { /*...*/ }기본 argument와 사용할 때reformat(str)기본 값을 사용하지 않을 때reformat(str, true, true, false, &#39;_&#39;)보기 좋게reformat(str, normalizeCase = true, upperCaseFirstLetter = true, divideByCamelHumps = false, wordSeparator = &#39;_&#39; )일부 argument만 지정할 때reformat(str, wordSeparator=&quot;_&quot;)함수가 positional and named arguments 와 함게 호출되면,모든 positional arguments 는 첫번째 named argument 앞에 위치헤야 한다.예를들어 f(1, y = 2) 는 맞지만, f(x = 1, 2) 은 틀리게 된다.Variable number of arguments (vararg, 아래에서 설명은 spread operator 를 사용하여 named 형식으로 전달될 수 있다.fun foo(vararg strings: String) { /*...*/ } foo(strings = *arrayOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) Single-expression functions함수가 single expression 을 리턴할 때에는 { } 는 생략될 수 있고 함수의 바디는 = 뒤에 위치한다fun double(x: Int): Int = x * 2컴파일러가 expression에서 리턴 타입을 유추 할 수 있는 경우에는 return type 생략 가능fun double(x: Int) = x * 2함수의 block body가 있는 경우에는 항상 return type을 명시해야하며,그렇지 않으면 Unit을 리턴하는 것으로 간주한다.코틀린에서 block body가 있는 함수는 return type을 유추하지 않는데,이는 함수의 코드가 복잡하거나 return type을 명확히 판단할 수 없기 때문이다.Variable number of arguments (Varargs)함수의 파라미터 마지막에는 vararg로 표시될 수 있는데, 여러개의 argument를 함수에 전달 할 수 있게 해준다.fun &amp;lt;T&amp;gt; asList(vararg ts: T): List&amp;lt;T&amp;gt; { val result = ArrayList&amp;lt;T&amp;gt;() for (t in ts) // ts is an Array result.add(t) return result } val list = asList(1, 2, 3)varargs 함수를 호출할 때 asList(1,2,3) 처럼 argument를 하나씩 전달하거나,이미 array가 있고 그 내용을 함수에 전달하고 싶을때는 spread operator *를array의 prefix로 사용할 수 있다.val a = arrayOf(1, 2, 3) val list = asList(-1, 0, *a, 4)Infix notationinfix 키워드를 가진 함수는 . 과 ( ) 를 생략하고 호출하는 infix notation 을 사용하여 호출될 수 있다.infix function 은 아래의 사항을 만족해야 한다. 멤버 함수 이거나 확장 함수 이어야 한다. 단 하나의 파라미터를 가진다. 파라미터는 고정되지 않은 개수의 arugment 를 가질 수 없고 기본 값을 가질 수 없다.infix fun Int.shl(x: Int): Int { ... } // calling the function using the infix notation 1 shl 2 // is the same as 1.shl(2)infix function 호출은 arithmetic operators, type casts, and the rangeTo operator 보다 우선순위가 낮다.아래의 예제들은 모두 동등하다. 1 shl 2 + 3 is equivalent to 1 shl (2 + 3) 0 until n * 2 is equivalent to 0 until (n * 2) xs union ys as Set&amp;lt;*&amp;gt; is equivalent to xs union (ys as Set&amp;lt;*&amp;gt;) boolean operators &amp;amp;&amp;amp; and **   , **is- and in-checks, and some other operators 보다는 우선 순위가 높다. 아래의 예제들은 모두 동등하다. a &amp;amp;&amp;amp; b xor c is equivalent to a &amp;amp;&amp;amp; (b xor c) a xor b in c is equivalent to (a xor b) in cLocal functions코틀린은 함수 안의 함수를 지원한다.fun dfs(graph: Graph) { fun dfs(current: Vertex, visited: MutableSet&amp;lt;Vertex&amp;gt;) { if (!visited.add(current)) return for (v in current.neighbors) dfs(v, visited) } dfs(graph.vertices[0], HashSet()) }로컬함수는 외부 함수의 변수에 접근할 수 있다.fun dfs(graph: Graph) { val visited = HashSet&amp;lt;Vertex&amp;gt;() fun dfs(current: Vertex) { if (!visited.add(current)) return for (v in current.neighbors) dfs(v) } dfs(graph.vertices[0]) }멤버 함수멤버 함수는 클래스나 오브젝트의 내부에 정의된다.class Sample(){ fun foo(){ print(&quot;Foo&quot;) } } Sample().foo()익명 함수자바에 익명 함수가 있듯이 kotlin에서도 익명 함수를 사용할 수 있다.val stringLengthFunc: (String) -&amp;gt; Int = { input -&amp;gt; input.length}제네릭 함수함수 이름 앞에 &amp;lt;&amp;gt;를 사용하여 지정된 generic parameters를 가질 수 있다.fun &amp;lt;T&amp;gt; singletonList(item: T): List&amp;lt;T&amp;gt; { /*...*/ } Tail recursive functions코틀린은 tail recursion 라고 알려진 함수형 프로그래밍 스타일을 지원한다.이는 특정 알고리즘의 경우 재귀형 함수 대신 루프를 사용할 수 있고,stack overflow 의 위험을 피할 수 있게 해준다.함수가 tailrec 로 표시되고 특정 조건들을 만족할 때 컴파일러는 재귀구문을 효과적인 루프 기반의 버전으로 최적화 한다.val eps = 1E-10 // &quot;good enough&quot;, could be 10^-15 tailrec fun findFixPoint(x: Double = 1.0): Double = if (Math.abs(x - Math.cos(x)) &amp;lt; eps) x else findFixPoint(Math.cos(x))이 코드는 Math.cos를 1.0에서 시작해서 결과가 더 이상 바뀌지 않을때 까지 반복적으로 호출하여 eps 0.7390851332151611 값을 넘긴다.이는 좀 더 전통적인 아래의 코드와 동등하다.val eps = 1E-10 // &quot;good enough&quot;, could be 10^-15 private fun findFixPoint(): Double { var x = 1.0 while (true) { val y = Math.cos(x) if (Math.abs(x - y) &amp;lt; eps) return x x = Math.cos(x) } }tailrec 에 좀더 맞게 하려면 함수는 자신이 마지막 호출 대상이 되어야 한다.재귀 호출 이후의 더이상의 코드가 없어야 tail recursion 을 쓸 수 있으며,try/catch/finally 구문과 함께 쓸 수 없다." }, { "title": "코틀린 기본 문법 정리 List", "url": "/posts/basic3/", "categories": "Kotlin, basic", "tags": "kotlin", "date": "2022-03-07 18:21:00 +0900", "snippet": "### 불변형 List 생성하기fun main(array: Array&amp;lt;String&amp;gt;){ var numbers: List&amp;lt;Int&amp;gt; = listOf(1,2,3,4,5) var names: List&amp;lt;String&amp;gt; = listOf(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;) var mixedType = listOf(&quot;Hello&quot;, 1, 2.45, &#39;s&#39;) // &amp;lt;Any&amp;gt; 타입 for(number in numbers) print(number) // 12345 println() for(index in names.indices) println(&quot;names[$index] = ${names[index]}&quot;) // names[0] = one for (index in names.indices) // 짝수 요소만 if(index % 2 == 0) println(&quot;names[$index] = ${names[index]}&quot;)}emptyList()val emptyList: List&amp;lt;String&amp;gt; = emptyList&amp;lt;String&amp;gt;()비어있는 List를 생성하려면 emptyList&amp;lt;&amp;gt;()를 사용할 수 있다.List의 주요 멤버 메서드 멤버 메서드 설명 get(index:Int) 특정 인덱스를 인자로 받아 해당 요소를 반환한다. indexOf(element:E) 인자로 받은 요소가 첫 번째로 나타나는 인덱스를 반환하며, 없으면 -1을 반환한다. lastIndexOf(element: E) 인자로 받은 요소가 마지막으로 나타나는 인덱스를 반환하고, 없으면 -1을 반환 listIterator() 목록에 있는 iterator를 반환한다. subList(fromIndex: Int, toIndex: Int) 특정 인덱스의 from과 to 범위에 있는 요소 목록을 반환한다. List의 기본 멤버 메소드 사용해보기fun main(array: Array&amp;lt;String&amp;gt;){ var names: List&amp;lt;String&amp;gt; = listOf(&quot;one&quot;, &quot;two&quot;,&quot;three&quot;) println(names.size) // List 크기 3 println(names.get(0)) // 해당 인덱스의 요소 가져오기 one println(names.indexOf(&quot;three&quot;)) // 해당 요소의 인덱스 가져오기 2 println(names.contains(&quot;two&quot;)) // 포함 여부 확인 후 포함되어 있으면 true 반환 true}가변형 List 생성하기arrayListOf()fun main(array: Array&amp;lt;String&amp;gt;){ // 가변형 List를 생성하고 자바의 ArrayList로 반환 val stringList: ArrayList&amp;lt;String&amp;gt; = arrayListOf&amp;lt;String&amp;gt;(&quot;Hello&quot;, &quot;Kotlin&quot;, &quot;Wow&quot;) stringList.add(&quot;Java&quot;) // 추가 stringList.remove(&quot;Hello&quot;) // 삭제 println(stringList) // [Kotlin, Wow, Java]}mutableListOf()``kotlinfun main(array: Array){ // 가변형 List의 생성 및 추가, 삭제, 변경 val mutableList: MutableList = mutableListOf(&quot;kildong&quot;,&quot;Dooly&quot;,&quot;Chelsu&quot;) mutableList.add(&quot;Ben&quot;) // 추가 mutableList.removeAt(1) // 인덱스 1번 삭제 mutableList[0]=&quot;Sean&quot; // 인덱스 0번을 변경, set(index: Int, element: E)와 같은 역할 println(mutableList) // [Sean, Chelsu, Ben]// 자료형의 혼합val mutableListMixed = mutableListOf(&quot;Android&quot;, &quot;Apple&quot;,5,6,&#39;X&#39;)println(mutableListMixed) // [Android, Apple, 5, 6, X] } ```불변형 List를 가변형으로 변환하기 val names: List&amp;lt;String&amp;gt; = listOf(&quot;one&quot;, &quot;two&quot;,&quot;three&quot;) // 불변형 List 초기화 val mutableNames = names.toMutableList() // 새로운 가변형 List가 만들어짐 mutableNames.add(&quot;four&quot;) // 가변형 List에 하나의 요소 추가 println(mutableNames) // [one, two, three, four]코틀린에서 List는 읽기 전용 컬렉션으로 데이터의 수정이나 삭제가 불가능하다.따라서, add, remove와 같은 메소드를 사용할 수 없기 때문에 MutableList를 사용해야 데이터 수정이 가능해짐" }, { "title": "코틀린 기본 문법 정리 (?:, ?., as?, !!, lateinit)", "url": "/posts/basic2/", "categories": "Kotlin, basic", "tags": "kotlin", "date": "2022-03-05 00:29:00 +0900", "snippet": "기본 문법2 (?:, ?., as?, !!, lateinit)엘비스 ?: 연산자fun main(args: Array&amp;lt;String&amp;gt;){ var fishFood : Int? = null fishFood = fishFood?.dec() ?: 0 println(fishFood)}fun main(args: Array&amp;lt;String&amp;gt;){ var yts: String? = null fun elvis() { val name: String = yts ?: &quot;YTS&quot; val nameTwo: String = yts ?: return //함수자체를 return 시키도록 만들 수 도 있음 val nameThree: String = yts ?: throw NullPointerException() }}엘비스 연산자는 널 값을 허용하지 않는 변수에 널 값이 들어갔을 때 null 값을 변환할 수 있는 결과를 만들어줌안전한 호출 ?. 연산자class Names { var name: String? = null } class Safe { fun safeGetName() { val names: Names? = Names() val name: String = names?.name ?: &quot;No Name&quot; print(name) } }fun main(args: Array&amp;lt;String&amp;gt;){ var fishFood = 6 if(fishFood != null) fishFood = fishFood.dec() println(fishFood) var fishFood2 : Int? = 5 fishFood2 = fishFood2?.dec() println(fishFood2)}위 처럼 if 문을 사용해 null 이 아니면 값을 줄이는 코드를 아래와 같이 ? 를 사용하여 한 줄로 줄일 수 있다.널 값 보증 !! 연산자fun nonNull() { val animal: String = &quot;호랑이&quot; val animalName: String = animal!! // animal은 절대 null값이 아니기 때문에 !!연산자로 보증 }상황에 따라 Null이 아닌 값만 포함되는 경우가 생길 수 있다.그럴 때 널 값이 안 들어온다는 보증을 해주는 !!연산자.널 값이 들어오면 오류 발생나중 초기화를 위한 lateinit 키워드lateinit var name: String클래스에서 변수를 만들 때에 상황에 따라 나중에 따로 초기화를 수행하는 경우가 생긴다.그럴 때 사용되는 키워드가 lateinit 키워드이며, lateinit 키워드를 사용하면 초기화 없이 변수 설정이 가능해짐안전한 자료형 변환 as? 연산자class As { fun As() { val animal: String = &quot;호랑이&quot; val value: Int = animal as? Int ?: 0 //Int 로 변환 할 수 없으므로 0으로 초기화된다. print(value) }}fun main(array: Array&amp;lt;String&amp;gt;){ As().As()}as? 연산자는 자료형 변환에 대해 안전하게 변환 할 수 있도록 도와준다." }, { "title": "MVC, MVP, MVVM", "url": "/posts/architecturePattern/", "categories": "Android, Architecture", "tags": "android", "date": "2022-03-04 01:15:00 +0900", "snippet": "아키텍처 패턴 - MVC, MVP, MVVMMVCModel, View, Controller로 구성 Model(모델): 어플리케이션의 데이터를 저장하는 역할을 담당. SQLite, File, cotent provider가 이 영역에 속함 View(뷰): 화면 구성을 담당하는 영역이다. 이 영역은 View 클래스를 상속하는 클래스를 사용해서 구성할 수 있다. Controller(컨트롤러) View와 Model을 서로 연결하고 제어하는 영역이다. activity, service, broadcast receiver, fragment 가 포함된다. 장점: 구현이 쉽다.단점: 하나의 클래스에 코드양이 증가, View와 Model간의 의존성이 높아져서 기능 추가 및 유지보수가 어려움간단한 프로젝트를 진행하는 경우에 적합, 프로젝트가 커지고 메소드 개수가 많아지면 코드 파악이 어려워지기때문에 메소드와 클래스를 적절히 분리하면서 복잡도를 관리 해야함MVPModel, View, Presenter로 구성되어 있음 Model(모델): 데이터와 관련된 처리를 담당 View(뷰): 이벤트가 발생하면 Presenter로 알린 후 반환 받은 것에 따라 UI를 갱신 Presenter(프레젠터): View에서 전달 받은 이벤트를 처리하여 다시 View로 반환한다. ㄴModel에 데이터 요청이 필요한 이벤트가 들어오는 경우 Model에 요청한 후 받은 데이터를 View에 전달 장점: View와 Model 사이의 의존성을 낮출 수 있다.단점: View와 Presenter 사이의 의존성이 높아진다. (View와 Presenter는 1:1로 매칭)MVVM Model(모델): 데이터와 관련된 처리를 담당한다. 데이터가 변경되면 ViewModel을 거쳐서 View로 전달 안드로이드에서는 LiveData나 RxJava 등을 통해 구현할 수 있다. View(뷰): 화면에 표현되는 레이아웃을 관리한다. View는 Model은 알지 못하기 때문에 ViewModel을 옵저빙하고 있다가 상태 변화가 전달되면 화면을 갱신해야 한다. ViewModel(뷰모델): View에 연결할 데이터와 명령으로 구성되어 있으며 변경 알림을 통해 View에게 상태 변화를 전달한다. ViewModel은 Model은 알지만 View는 알지 못한다. 장점: UI 컨트롤러의 책임을 분담하여 클래스가 거대해지는 것을 방지하고 유지 보수, 재사용성, 테스트 등을 용이하게 만들어준다.단점: ViewModel의 설계가 어렵다. DataBinding 등 추가적인 공부가 필요하다.MVVM 모델을 구현하는 경우 데이터 바인딩을 함께 써야 의존성을 낮출 수 있다. 구글이 제공하는 AAC(Android Architecture Component)를 사용해 MVVM 패턴을 쉽게 구성할 수 있다." }, { "title": "Swipe Layout", "url": "/posts/SwipeLayout/", "categories": "Android, User_Interface", "tags": "android, ui", "date": "2022-02-21 02:12:00 +0900", "snippet": "SwipeLayouthttps://github.com/chthai64/SwipeRevealLayout의존성 추가implementation &#39;com.chauthai.swipereveallayout:swipe-reveal-layout:1.4.1&#39;Adapter 등록 및 리스너 추가public class NoteAdapter extends RecyclerView.Adapter&amp;lt;NoteAdapter.ViewHolder&amp;gt; implements OnNoteItemClickListener { static ArrayList&amp;lt;Note&amp;gt; items = new ArrayList&amp;lt;Note&amp;gt;(); private final ViewBinderHelper binderHelper = new ViewBinderHelper(); @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int viewType) { LayoutInflater inflater = LayoutInflater.from(viewGroup.getContext()); View itemView = inflater.inflate(R.layout.note_item, viewGroup, false); return new ViewHolder(itemView, this, layoutType); } @Override public void onBindViewHolder(@NonNull ViewHolder viewHolder, int position) { Note item = items.get(position); binderHelper.setOpenOnlyOne(true); binderHelper.bind(viewHolder.swipelayout,Integer.toString(item.get_id())); viewHolder.bind(item); viewHolder.setItem(item); viewHolder.setLayoutType(layoutType); } public class ViewHolder extends RecyclerView.ViewHolder { SwipeRevealLayout swipelayout; private View deleteLayout; private View editLayout; LinearLayout layout1; LinearLayout layout2; ... (변수 선언 생략) NoteDatabase database; public ViewHolder(View itemView, final OnNoteItemClickListener listener, int layoutType) { super(itemView); swipelayout = (SwipeRevealLayout) itemView.findViewById(R.id.swipe_layout); deleteLayout = itemView.findViewById(R.id.txtDelete); ... 생략 // 데이터 베이스 객체 얻어오기 Fragment1 fragment1 = new Fragment1(); database = NoteDatabase.getInstance(fragment1.context); setLayoutType(layoutType); } // Swipe Layout (삭제, 수정) 리스너 설정 public void bind(final Note item){ deleteLayout.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // 클릭한 Swipe Layout의 일기id (DB) int position = item._id; // 리싸이클러 뷰 아이템 목록에서 안보이게 하기 items.remove(getAdapterPosition()); notifyItemRemoved(getAdapterPosition()); // 일기 삭제 (DB 테이블 삭제) deleteNote(position); } }); } /* swipe 삭제 버튼 누르면 DB에서 해당 일기를 찾아 삭제 */ public void deleteNote(int position){ String sql = &quot;delete from &quot; + NoteDatabase.TABLE_NOTE + &quot; where &quot; + &quot; _id = &quot; + position; database.execSQL(sql); } }Swipe 레이아웃과 관련된 코드가 아닌건 전부 생략하였음Swipe Layout.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;com.chauthai.swipereveallayout.SwipeRevealLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/swipelayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:dragEdge=&quot;right&quot; app:mode=&quot;same_level&quot;&amp;gt; &amp;lt;!--Swipe Layout--&amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;!--Main Layout--&amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot; android:padding=&quot;20dp&quot;&amp;gt; &amp;lt;/LinearLayout&amp;gt;&amp;lt;/com.chauthai.swipereveallayout.SwipeRevealLayout&amp;gt;현재 만들고 있는 다이어리 앱 xml 코드는 길어서 예제 파일의 xml을 첨부하였다.Swipe Layout 부분이 스와이프 했을 때 보이는 부분Main Layout 부분은 기본으로 보이는 부분 내가 작성한 다이어리 앱 코드 바로가기 " }, { "title": "JetPack이란?", "url": "/posts/Jetpack/", "categories": "Android, AppComponents", "tags": "android, library", "date": "2022-02-19 05:48:00 +0900", "snippet": "JetPackJetpack이란github 안드로이드 프로젝트를 구경하다 보면 Jetpack이라는 단어가 종종 보인다.책에서는 구경도 못한 단어여서 정리를 해보고자 한다.Jetpack은 2018년 5월 8일에 구글이 발표한 라이브러리 도구 모음 집이다.앱을 개발을 쉽고 빠르게 도와주는 라이브러리와 도구를 모아둔 것 이다.Jetpack이 출시되기 전에 Support Library가 존재했었다.Support Library에는 여러가지 문제점이 있어 이를 개선해서 출시한 것이 JetPack이다.위의 문제점은 당근 마켓 기술 블로그 에서 확인할 수 있다.시간이 날 때 확인 해봐야겠다.즉, JetPack은 Support Library의 이전 버전이라고 생각하면 될 것 같다.Support Library는 현재도 사용 가능 하지만 공식 문서에서는 AndroidX 를 권장한다.AndroidX는 Jetpack의 라이브러리들을 묶은 패키지 명이다.JetPack 구성요소 구글 공식 문서 JetPack을 구성하는 라이브러리는 굉장히 많다.인제부터 천천히 하나씩 공부해야겠다." }, { "title": "return문과 break 차이?", "url": "/posts/return/", "categories": "삽질_일기", "tags": "java", "date": "2022-02-18 17:58:00 +0900", "snippet": "return문과 break 차이?위의 소스코드에서 break문으로 빠져 나가면 weatherIndex값이 제대로 저장이 되는데,왜 return 문을 사용하면 값이 저장이 안되는 걸까?뭐지 ?뭘 까?이거 때문에 db 코드랑 class 파일 다 뜯어보느라 시간이 녹아 버렸다나는 똑같은 줄 알았는데 …나중에 return문에 대해 깊게 공부해봐야 겠다." }, { "title": "안드로이드 xml 배경 적용하다 삽질한 건에 대하여", "url": "/posts/BackgroundXML/", "categories": "삽질_일기", "tags": "xml", "date": "2022-02-18 02:53:00 +0900", "snippet": "안드로이드 xml 배경 적용 오류메인 액티비티의 전체 배경색을 바꿀려고 그라데이션 xml 파일을 정성스럽게 만든 후메인 액티비티의 Constraint Layout 배경색에 적용 시켰는데 아래와 같이 오류가 났다.코드를 잘못 짯나 해서 xml 태그를 계속 바꾸어 가며 2시간 삽질을 하다 진전이 없어 포기를 하였다.이때 당시에 Layout에는 xml 파일을 적용 시키면 안되는줄 알았다.그래서 배경색을 이미지 파일로 적용 시키고 다른 작업을 하던 중 우연히 어떤 글을 보았는데LinearLayout에 xml 파일로 배경색을 적용하는데 오류가 난다는 글이였다.그래서 답변에 있는 코드 xml 파일을 복붙해서 LinearLayout에 적용 해보니 잘된다 -_-뭐지 하면서 내가 작성한 코드랑 다른 점을 살펴보는데 \\&amp;lt;gradient&amp;gt; 태그 속성에 android:angle 값이달랐다. ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt; &amp;lt;item&amp;gt; &amp;lt;shape&amp;gt; &amp;lt;gradient android:angle=&quot;120&quot; android:startColor=&quot;#B2EBEA&quot; android:endColor=&quot;#FCEFE4&quot; android:type=&quot;linear&quot; /&amp;gt; &amp;lt;/shape&amp;gt; &amp;lt;/item&amp;gt;&amp;lt;/selector&amp;gt;위는 내가 작성한 코드인데 android:angle 값이 당연히 120도가 되는 줄 알았는데 ..검색을 해보니 줄 수 있는 값은 0, 90, 180, 270도로 정해져 있었다.하.. ㅋㅋ 진짜 화가 치밀어 오르네그래서 아래와 같이 수정한 후&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt; &amp;lt;item&amp;gt; &amp;lt;shape&amp;gt; &amp;lt;gradient android:angle=&quot;270&quot; android:startColor=&quot;#B2EBEA&quot; android:endColor=&quot;#FCEFE4&quot; android:type=&quot;linear&quot; /&amp;gt; &amp;lt;/shape&amp;gt; &amp;lt;/item&amp;gt;&amp;lt;/selector&amp;gt;실행을 해보니 아래와 같이 문제 없이 잘 적용되었다 !!" }, { "title": "코틀린 기본 문법 정리", "url": "/posts/basic/", "categories": "Kotlin, basic", "tags": "kotlin", "date": "2022-02-17 17:36:00 +0900", "snippet": "코틀린 기본 문법reference by Kotlin 공식 문서 Kotlin 구조package kotlinprojectfun main(){println(&quot;Hello World&quot;)} .kt 확장자를 가진다. package, import 선언부는 자바와 동일 함수의 fun 키워드로 시작한다. 리턴 타입은 함수명() 뒤쪽에 명시 코틀린은 문장의 끝을 세미콜론으로 명시하지 않음 변수 타입, 정의 및 초기화 데이터 타입에 관계 없는 상수는 val, 변수는 var 로 선언 데이터 타입을 명시하지 않아도 할당 해주는 값에 따라 자동으로 결정됨 val는 자바와 final과 같으므로 다른 값으로 재 할당할 경우 위와 같이 오류가 난다.위의 경우는 var 키워드로 num 변수를 int 형으로 타입을 정하였는데,아래에서 String으로 타입을 재할당 시도를 하여서 컴파일 오류가 나는 경우변수 정의코틀린에서 변수를 선언할 때 초기화를 하지 않고 정의만 할 경우 아래와 같이 타입을 명시해줘야 함변수 초기화초기화는 아래와 같이 타입에 맞는 값을 할당해주면 된다함수 정의두 개의 Int 타입 파라미터를 전달 받아 Int 타입을 반환하는 함수fun sum (a: Int, b: Int) : Int{ return a+b }직접 값을 할당해주는 함수fun sum(a: Int, b: Int) = a + b fun main(){ var a = 10 var b = 20 println(sum(a,b)) }리턴 값이 없는 함수는 Unit (자바의 void)으로 정의fun print(a: Int, b: Int): Unit{ println(&quot;$a + $b = ${a+b}&quot;) } fun main(){ var a = 10 var b = 20 print(a,b) }Unit 리턴 타입은 생략 가능fun print(a: Int, b: Int){ println(&quot;$a + $b = ${a+b}&quot;) } 스트링 템플릿자바에서 String 클래스가 가지고 있는 format 메서드와 유사한 기능을 한다.fun main() { var a = 1 val str1 = &quot;a is $a&quot; a = 2 var str2 = &quot;${str1.replace(&quot;is&quot;, &quot;was&quot;)}, but now is $a&quot; println(str1) println(str2) } 조건문조건문 사용법은 자바와 동일fun max(a: Int, b: Int): Int{ if(a &amp;gt; b) return a else return b }하지만 코틀린에서는 아래와 같이 표현식으로 나타낼 수 있음fun max(a: Int, b: Int) = if (a &amp;gt; b) a else bNULLNull값을 허용하는 경우 타입 뒤에 ? 를 명시해주면 된다.fun parseInt(str :String) : Int? { return str.toInt() // 리턴 타입이 기본적으로 Int형이고, null일 수 도 있음 }자동 형 변환반대의 경우반복문for-each문인덱스를 사용하는 경우While문When 표현식when 표현식은 자바의 switch 문과 유사하다Range// Java for(int i=0; i&amp;lt;10; i++){ ... } // Kotlin for(i in 0..x){ //0부터 1씩 증가하면서 x보다 작거나 같을 때까지 ... }// Java for(int i=0; i&amp;lt;10; i+=2){ ... } // Kotlin for(i in 0.. 9 step 2){ // 0 ~ 9까지 2씩 증가 ... } for(i in 9 downTo 0 step 2){ // 9 ~ 0까지 2씩 다운 }인덱스가 특정 범위를 벗어 났는지 확인하려면 아래와 같이 ! 연산자를 in과 함께 사용" }, { "title": "볼링 점수 계산 (17215)", "url": "/posts/back-17215/", "categories": "PS, implement", "tags": "backjoon, implement, gold1", "date": "2022-02-08 20:26:00 +0900", "snippet": "볼링 점수 계산 (17215)문제소현이는 친구들과 함께 볼링을 치러 볼링장에 갔다. 그런데 볼링장의 시스템 오류로 인해 점수판에 점수가 집계 되지 않는 문제가 있었다. 밖이 너무 추운 나머지 소현이와 친구들은 그냥 치기로 하였고 1게임이 끝났지만 각자 점수가 얼마나 되는지를 계산하지 못하고 있다. 소현이와 친구들을 위해 볼링 점수를 계산해주는 프로그램을 작성해 보자.볼링 규칙 1게임은 총 10프레임으로 구성되어 있다. 각 프레임마다 볼링핀 10개를 세워두고 공으로 쓰러뜨리는 것이며 기본적으로 볼링핀 1개당 1점이다. 각 프레임마다 2번의 기회가 주어지며 첫 번째 기회에 10개의 핀을 모두 쓰러뜨리는 것을 스트라이크(S)라고 한다. 두 번째 기회까지 사용하여 10개의 핀을 쓰러뜨리는 것을 스페어(P)라고 한다. 스트라이크를 치면 다음 두 번의 기회동안 쓰러뜨린 볼링핀의 개수만큼 추가점수를 얻게 된다. 10프레임을 제외한 프레임에서 스트라이크를 치면 해당 프레임의 두 번째 기회는 사라진다. 스페어를 치면 다음 한번의 기회동안 쓰러뜨린 볼링핀의 개수만큼 추가점수를 얻게 된다. 마지막 10번째 프레임에서 스트라이크를 칠 경우 두번의 보너스 기회가 제공된다. 이때 두번의 보너스 기회동안 추가점수는 존재하지 않는다. 마지막 10번째 프레임에서 스페어를 칠 경우 한번의 보너스 기회가 제공된다. 이때 한번의 보너스 기회동안 추가점수는 존재하지 않는다. 입력첫째 줄에 각 기회마다 소현이가 쓰러뜨린 볼링핀의 개수가 공백없이 주어진다. 이때 스트라이크는 S, 스페어는 P, 핀을 하나도 못 쓰러뜨린 것은 -으로 주어진다.출력첫째 줄에 소현이의 점수를 출력한다.볼링을 좋아해서 자주 쳤었는데 점수 계산하는 방법을 몰라 볼링 점수 계산 방법을 따로 공부해서 푼 문제 ㅎㅎ.. 머쓱열심히 디버깅한 결과 3트 성공디버깅할때 열심히한 메모 풀이 기본 점수를 다 더한다. 10프레임이 (S, P)일 경우 보너스 프레임 추가 각 프레임이 더블인지, 터키인지 구분 1프레임 ~ 9프레임까지 보너스 점수 계산 터키일 경우 +20점 더블일 경우 +10 +(현재 프레임 인덱스 +2) 스트라이크일 경우 다음 2구에서 맞춘 핀의 개수를 더함 스페어일 경우 다음 1구에서 맞춘 핀의 개수를 더함 일단 볼링은 무조건 10 프레임으로 구성되어 있고 한 프레임 최대 2구를 던지므로 기본 점수, 보너스 점수 반복문을 따로 분리해서 구해줘도 될 것 같았다. (제한시간 1초)import java.io.*;import java.util.*;class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); }}class Bowling{ boolean Db; boolean tk; public Bowling(){ this.Db = false; this.tk = false; }}public class Main { static int frame = 10; static StringBuilder in ; static int i =0; static int idx = 0; static int frameUpCount=0; static boolean bonusFrame = false; static int score = 0; static Bowling bwc[]; public static void main(String args[]) throws IOException{ FastScanner sc = new FastScanner(); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); in = new StringBuilder(sc.next()); bwc = new Bowling[10]; for(int i=0; i&amp;lt;10; i++) bwc[i] = new Bowling(); for(i=0; i&amp;lt;frame; idx++ ){ if(frameUpCount &amp;gt;= 2){ i++; frameUpCount = 0; } if(i&amp;lt;=9) { if(in.charAt(idx) == &#39;S&#39;) { if (in.charAt(idx + 1) == &#39;S&#39; &amp;amp;&amp;amp; in.charAt(idx + 2) == &#39;S&#39;) bwc[i].tk = true; else if (in.charAt(idx + 1) == &#39;S&#39;) bwc[i].Db = true; } if(in.charAt(idx) == &#39;P&#39;){ bwc[i].tk = false; bwc[i].Db = false; } } if(i &amp;gt;= frame) break; /* 10 프레임에서 보너스 게임 추가 */ if(i== 9 &amp;amp;&amp;amp; in.charAt(idx) == &#39;S&#39;) { frame += 2; bonusFrame = true; } else if (i == 9 &amp;amp;&amp;amp; in.charAt(idx) == &#39;P&#39;) { frame++; bonusFrame = true; } score += changeScore(in.charAt(idx),idx); } bonusScore(); bw.write(Integer.toString(score)); bw.close(); } public static int changeScore(char input,int idx){ switch (input){ case &#39;S&#39;: frameUpCount=2; return 10; case &#39;P&#39;: frameUpCount += (bonusFrame == false) ? 1 : 2; return 10 - (in.charAt(idx-1) - &#39;0&#39;); case &#39;-&#39;: frameUpCount += (bonusFrame == false) ? 1 : 2; in.replace(idx,idx+1, &quot;0&quot;); return 0; default: frameUpCount += (bonusFrame == false) ? 1 : 2; return input - &#39;0&#39;; } } public static void bonusScore(){ frame = 9; idx = 0; frameUpCount = 0; bonusFrame = false; boolean cover = false; // 터키이상 일 경우 for(i=0; i&amp;lt;frame; idx++ ){ if(frameUpCount &amp;gt;= 2){ i++; frameUpCount = 0; } if(bwc[i].tk == true){ score += 20; i++; frameUpCount =0; }else if(bwc[i].Db == true){ score += (i != 9) ? 10 + changeScore(in.charAt(idx+2),idx) : 0; i++; frameUpCount =0 ; }else if(in.charAt(idx) == &#39;S&#39; &amp;amp;&amp;amp; i&amp;lt;9){ for(int j=idx+1; j &amp;lt;= idx+2; j++){ score += changeScore(in.charAt(j),j); } }else if(in.charAt(idx) == &#39;P&#39;){ score += changeScore(in.charAt(idx+1),idx); }else{ frameUpCount++; } } }}" }, { "title": "MultiWindow (다중 창)", "url": "/posts/MultiWindow/", "categories": "Android, User_Interface", "tags": "android, multiwindow", "date": "2022-02-07 16:17:00 +0900", "snippet": "다중 창 지원하기다중 창(Multi Window)은 단말 화면에 여러 개의 액티비티가 보이도록 지원하는 기능이다.이 기능은 API 24부터 지원되므로 예전 단말에서는 볼 수 없는 기능이지만 최근 단말에서는 필요에 따라 사용할 수 있다.사용자는 다중 창을 만들어 각각의 영역에 액티비티를 보여줄 수 있다.시스템 메뉴 버튼을 누르면 단말에서 실행된 액티비티들을 볼 수 있는 오버뷰(Overview) 화면이 뜨게 되는데이 화면에서 액티비티 상단의 아이콘 부분을 클릭하면 다중 창으로 만들 수 있는 메뉴가 표시된다.이 메뉴를 눌러 화면을 분할한 후 다른 액티비티를 다른 창에 보이도록 선택하면 된다.이 기능은 사용자가 필요에 따라 만드는 기능이지만 앱에서 별도의 처리를 해주어야 하는 경우도 있다.예를 들어, 다중 창 모드로 들어갔을 때는 액티비티가 보이는 영역이 줄어들기 때문에 화면 레이아웃을 변경해야 할 수도 있다.위와 같은 문제를 해결하기 위해 다음과 같은 메서드를 제공한다.public boolean isInMultiWindowMode()public boolean isInPictureInPictureMode()public void onMultiWindowModeChanged(boolean isInMultiWindowMode, Configuration newConfig)isInMultiWindowMode 메서드를 호출하면 현재 다중 창 모드에 들어가 있는지 확인할 수 있다.isInPictureInPictureMode 메서드를 호출하면 PIP (큰 화면에 작은 화면이 보이는 모드)에 들어가 있는지 확인할 수 있다.하지만 위 메서드들은 호출할 때만 알려주기 때문에 다중 창 모드로 변경될 때 마다 즉시 알아야 할 수도 있다.이때 사용하는 것이 nMultiWindowModeChanged 메서드이고 다중 창 모드로 변경될 때마다 자동으로 호출된다.예제package org.techtown.multiwindow;import androidx.appcompat.app.AppCompatActivity;import android.os.Build;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class MainActivity extends AppCompatActivity { TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if (Build.VERSION.SDK_INT &amp;gt;= 24){ boolean isIn = isInMultiWindowMode(); // 다중 창 모드 여부 확인하기 println(&quot;다중 창 모드 여부: &quot; + isIn); } } }); Button button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if(Build.VERSION.SDK_INT &amp;gt;= 24){ boolean isIn = isInPictureInPictureMode(); println(&quot;PIP 모드 여부: &quot; + isIn); } } }); } @Override public void onMultiWindowModeChanged(boolean isInMultiWindowMode){ super.onMultiWindowModeChanged(isInMultiWindowMode); println(&quot;다중 창 모드 변경됨: &quot; + isInMultiWindowMode); } public void println(String data){ textView.append(data + &quot;\\n&quot;); }}결과" }, { "title": "네트워크 상태 확인", "url": "/posts/NetworkState/", "categories": "Android, Network", "tags": "android, network", "date": "2022-02-07 03:40:00 +0900", "snippet": "네트워크 상태 확인단말의 인터넷 연결 상태는 어떻게 알 수 있을까?인터넷에 연결되어 있다면 일반망에 연결되어 있는지, 무선랜(WiFi)에 연결 되었는지 어떻게 확인할까?인터넷의 연결 상태에 따라 사용자에게 보여줄 결과물을 다르게 만들고 싶은 경우가 있다.예제를 통해 알아보자.예제MainActivity.javapackage org.techtown.network;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.net.ConnectivityManager;import android.net.NetworkInfo;import android.net.wifi.WifiManager;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity { TextView textView; WiFiReceiver wifiReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { checkConnectivity(); } }); wifiReceiver = new WiFiReceiver(); } public void checkConnectivity() { ConnectivityManager manager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo info = manager.getActiveNetworkInfo(); if (info != null) { if (info.getType() == ConnectivityManager.TYPE_WIFI) { println(&quot;WiFi로 설정됨&quot;); } else if (info.getType() == ConnectivityManager.TYPE_MOBILE) { println(&quot;일반망으로 설정됨&quot;); } println(&quot;연결 여부 : &quot; + info.isConnected()); } else { println(&quot;데이터통신 불가&quot;); } } public void println(String data) { textView.append(data + &quot;\\n&quot;); } @Override protected void onPause() { super.onPause(); unregisterReceiver(wifiReceiver); } @Override protected void onResume() { super.onResume(); IntentFilter filter = new IntentFilter(); // 코드에서 수신자 등록하기 filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION); filter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION); registerReceiver(wifiReceiver, filter); } class WiFiReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) { // WiFi 상태 체크하기 int state = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, -1); if (state == WifiManager.WIFI_STATE_ENABLED) { println(&quot;WiFi enabled&quot;); } else if (state == WifiManager.WIFI_STATE_DISABLED) { println(&quot;WiFi disabled&quot;); } } else if (action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) { NetworkInfo info = intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO); WifiManager manager = (WifiManager) getApplicationContext().getSystemService(Context.WIFI_SERVICE); String ssid = manager.getConnectionInfo().getSSID(); if (info.getState() == NetworkInfo.State.CONNECTED) { println(&quot;Connected : &quot; + ssid); } else if (info.getState() == NetworkInfo.State.DISCONNECTED) { println(&quot;Disconnected : &quot; + ssid); } } } }}https://www.acmicpc.net/problem/17215권한 추가AndroidManifest.xml&amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot;/&amp;gt;결과" }, { "title": "시스템 서비스 활용하기", "url": "/posts/SeystemService/", "categories": "Android, AppComponents", "tags": "android, service", "date": "2022-02-07 03:18:00 +0900", "snippet": "시스템 서비스 활용하기시스템 서비스 (System Service)는 단말이 켜졌을 때 자동으로 실행되어 백그라운드에서 동작한다.이런 시스템 서비스 중에 인플레이션을 위한 시스템 서비스나 센서를 위한 시스템 서비스 등을 포스팅 했다.안드로이드에서는 다양한 시스템 서비스가 제공되는데 그 중에서 ActivityManager, PackageManager, AlarmManager 에 대해 알아보자.ActivityManager는 액티비티나 서비스를 관리하는 시스템 서비스로 앱의 실행 상태를 알 수 있도록 한다.PackagerManager는 앱의 설치에 대한 정보를 알 수 있도록 하며 AlarmManager는 일정 시간에 알림을 받을 수 있도록 시스템에 등록해주는 역할을 한다.예제를 통해 알아보자.예제MainActivity.javapackage org.techtown.manager;import androidx.appcompat.app.AppCompatActivity;import android.app.ActivityManager;import android.app.AlarmManager;import android.app.PendingIntent;import android.content.Context;import android.content.Intent;import android.content.pm.ApplicationInfo;import android.content.pm.PackageManager;import android.content.pm.ResolveInfo;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import java.util.List;public class MainActivity extends AppCompatActivity { TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { getServiceList(); } }); Button button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { getCurrentActivity(); } }); Button button3 = findViewById(R.id.button3); button3.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { getAppList(); } }); Button button4 = findViewById(R.id.button4); button4.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { findActivity(); } }); Button button5 = findViewById(R.id.button5); button5.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { setAlarm(); } }); } public void getServiceList(){ ActivityManager manager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); // 실행 중인 프로세스 확인을 위한 메서드 호출하기 List&amp;lt;ActivityManager.RunningAppProcessInfo&amp;gt; processInfoList = manager.getRunningAppProcesses(); for(int i=0; i &amp;lt; processInfoList.size(); i++){ ActivityManager.RunningAppProcessInfo info = processInfoList.get(i); println(&quot;#&quot; + i + &quot; -&amp;gt; &quot; + info.pid + &quot;, &quot; + info.processName); } } public void getCurrentActivity(){ ActivityManager manager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); // 액티비티 스택에 들어있는 액티비티 정보 중에서 가장 최상위의 정보를 확인 List&amp;lt;ActivityManager.RunningTaskInfo&amp;gt; taskList = manager.getRunningTasks(1); ActivityManager.RunningTaskInfo info = taskList.get(0); println(&quot;Running Task -&amp;gt; &quot; + info.topActivity.toString()); } public void getAppList(){ PackageManager manager = getPackageManager(); // 어떤 앱이 설치되어 있는지 확인하기 위한 메서드 List&amp;lt;ApplicationInfo&amp;gt; appInfoList = manager.getInstalledApplications(PackageManager.GET_META_DATA); for(int i=0; i &amp;lt; appInfoList.size(); i++){ ApplicationInfo info = appInfoList.get(i); println(&quot;#&quot; + i + &quot; -&amp;gt; &quot; + info.loadLabel(manager).toString() + &quot;, &quot; + info.packageName); } } public void findActivity(){ PackageManager manager = getPackageManager(); Intent intent = new Intent(this, MainActivity.class); // 실행할 액티비티가 있는지 확인하기 위한 메서드 List&amp;lt;ResolveInfo&amp;gt; activityInfoList = manager.queryIntentActivities(intent, 0); for(int i=0; i&amp;lt;activityInfoList.size(); i++){ ResolveInfo info = activityInfoList.get(i); println(&quot;#&quot; + i + &quot; -&amp;gt; &quot; + info.activityInfo.applicationInfo.packageName); } } public void setAlarm(){ AlarmManager manager = (AlarmManager) getSystemService(Context.ALARM_SERVICE); Intent intent = new Intent(this,MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this, 101, intent, PendingIntent.FLAG_CANCEL_CURRENT); // Alarm Manager에 알람 등록하기 manager.set(AlarmManager.RTC, System.currentTimeMillis() + 60000, pendingIntent); } public void println(String data) { textView.append(data + &quot;\\n&quot;);}}결과" }, { "title": "센서", "url": "/posts/Sensor/", "categories": "Android, PushService", "tags": "android, sensor", "date": "2022-02-07 02:51:00 +0900", "snippet": "센서안드로이드는 다양한 표준 센서를 지원한다.대표적인 센서 중 하나인 가속 센서 (Accelerometer) 는 다양한 기준 (Axe)을 따라 기기가 얼마 만큼의 속도로 움직이는지 측정할 수 있게 한다.또한 자이로스코프 센서 (Gyroscope) 는 가속 센서보다 더 많은 축을 기준으로 시간에 따라 회전하는 정보까지 확인 할 수 있도록 해준다.이 외에도 다양한 센서들이 지원되는데 이 정보들은 센서 매니저 (SensorManager) 라는 시스템 서비스를 통해 모두 같은 방식으로 사용할 수 있다.안드로이드에서 지원하는 대표적인 센서들 센서 이름 상수 설 명 가속센서(Accelerometer) TYPE_ACCELEROMETER 가속도 감지, 외부의 충격량과 방향 감지 (단위: m/s^2)(중력 + 선형가속) 자이로스코프 센서 (Gyroscope) TYPE_GYROSCOPE 회전 정보 감지, 다양한 축을 따른 회전각 감지 중력 센서 (Gravity) TYPE_GRAVITY 축의 방향과 중력 감지 (단위: m/s^2) 조도 센서(Light) TYPE_LIGHT 빛의 세기 감지 (단위: lux) 선형 가속 센서(Linear Acceleration) TYPE_LINEAR_ACCELERATION 각 축에 따른 가속도를 감지하는 3차원 벡터 (단위:m/s^2) 근접 센서(Proximity) TYPE_PROXIMITY 근접한 물체와의 거리 감지 (단위: cm) 단말에 따라 가깝거나 먼 정도만 표시할 수도 있음 온도 센서(Temperature) TYPE_TEMPERATURE 온도 감지 방향 센서(Orientation) TYPE_ORIENTATION 방향 각 감지(단위: degree) 가속 센서와 방향 센서 이해하기가속 센서는 중력 정보와 선형 가속 정보가 같이 계산되므로 가장 자주 사용되는 센서 중의 하나이다.가속 센서를 이해하기 위해서는 가속 센서의 값을 계산할 줄 알아야 한다.단말을 테이블 위에 올려 두면 가속 센서의 값은 +9.81이 된다.이 값은 아래와 같이 단말의 선형 가속 값과 중력 값을 뺀 값이다. \\(0m/s^2 - (-9.81m/s^2)\\)이 값을 기준으로 가속 값을 계산하면 된다.예를 들어 단말을 테이블 위에 놓아둔 상태에서 한 방향으로 A 만큼 밀면 가속 값은 아래와 같이 된다. \\(A+9.81m/s^2\\)그러면 방향은 어떻게 정하면 될까?가속 센서와 같이 기준 축이 있는 경우에는 다음과 같은 좌표계를 사용한다. 출처 : Do it! Android 프로그래밍X축으로는 오른쪽이 +값, Y축으로는 위쪽이 +값, 그리고 Z축으로는 화면 앞쪽이 +값이된다.방향 센서는 세 개의 값을 전달 받을 수 있고 첫 번째 값은 Azimuth라고 하고 Z축을 기준으로 북쪽 방향과 현재 감지되는 Y축과의 차이를 나타낸다.따라서 값의 범위는 0 ~ 359도 사이가 되고 각각의 방위 값은 0 = 북쪽, 90 = 동쪽, 180 = 남쪽, 270 = 서쪽이 된다.두 번째 값은 Pitch라 하고 X 축을 기준으로 한 회전각을 나타낸다.값의 범위는 -180 ~ 180도 사이가 되고 Z 축이 Y축 방향으로 이동할 때 +값이 된다.세 번째 값은 Roll이라 하고 Y축을 기준으로 한 회전각을 나타낸다.따라서 값의 범위는 -90 ~ 90도까지가 되고 X 축이 Z축 방향으로 이동할 때 + 값이 된다.센서를 사용하면서 볼 수 있는 대표적인 클래스들은 다음과 같다.SensorManagerSensorSensorEventSensorManger 객체는 센서를 다루기 위해 제공되는 시스템 서비스 객체이다.Sensor 객체는 각 센서 정보를 포함하고 있다.SensorEvent 객체를 통해 각 센서의 값을 바로바로 확인할 수 있다.예제MainActivity.javapackage org.techtown.sensor;import androidx.appcompat.app.AppCompatActivity;import android.hardware.Sensor;import android.hardware.SensorEvent;import android.hardware.SensorEventListener;import android.hardware.SensorManager;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import java.util.List;public class MainActivity extends AppCompatActivity { TextView textView; SensorManager manager; List&amp;lt;Sensor&amp;gt; sensors; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { getSensorList(); } }); Button button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { registerFirstSensor(); } }); } public void getSensorList(){ manager = (SensorManager) getSystemService(SENSOR_SERVICE); sensors = manager.getSensorList(Sensor.TYPE_ALL); int index = 0; for(Sensor sensor : sensors){ println(&quot;#&quot; + index + &quot; : &quot; + sensor.getName()); } } public void registerFirstSensor(){ manager.registerListener( new SensorEventListener() { @Override public void onSensorChanged(SensorEvent event) { String output = &quot;Sensor Timestamp : &quot; + event.timestamp + &quot;\\n\\n&quot;; for(int index = 0; index &amp;lt; event.values.length; ++index){ output += (&quot;Sensor Value #&quot; + (index +1) + &quot; : &quot; + event.values[index] + &quot;\\n&quot;); } println(output); } @Override public void onAccuracyChanged(Sensor sensor, int i) { } }, sensors.get(0), SensorManager.SENSOR_DELAY_UI); } public void println(String data){ textView.append(data + &quot;\\n&quot;); }}센서를 사용할 때는 센서 매니저 객체를 시스템 서비스로 참조하는 것부터 시작한다.getSystemService 메서드를 호출하여 시스템 서비스 객체를 참조할 때 사용하는 상수는 SENSOR_SERVICE이다.센서 매니저 객체를 참조한 후 단말에서 지원하는 모든 센서 리스트를 가져오려면 getSensorList 메서드를 호출하면 된다.단말에서 지원하는 모든 센서 리스트를 가져오려면 getSensorList 메서드를 호출한다.두 번째 버튼을 누르면 센서의 값이 변할 때마다 그 값을 화면에 보여주게 된다.센서들의 값들이 변하는 경우에는 SensorEvent 객체를 통해 전달받게 되는데,이 액티비티가 SensorEventListener를 구현하여 사용하므로 다음과 같은 두 메서드를 통해 이벤트를 전달 받을 수 있다.abstract void onAccuracyChanged(Sensor sensor, int accuracy)abstract void onSensorChanged(SensorEvent event)onAccuracyChanged 메서드는 센서의 정확도 값이 변할 때 마다 호출된다.onSensorChanged 메서드는 센서의 데이터 값이 변할 때 마다 호출된다.결과" }, { "title": "FCM(Firebase Cloud Messaging)", "url": "/posts/Firebase/", "categories": "Android, PushService", "tags": "android, pushservice, firebase, alerm", "date": "2022-02-07 00:24:00 +0900", "snippet": "푸시 서비스 사용하기안드로이드 스마트폰을 사용하다 보면 Play 스토어나 앱 마켓에서 설치한 앱의 업데이트가 있다는 알람이 종종 울린다. 단말의 위쪽 부분에 보이는 상태 바 부분에 메시지가 표시되면 사용자는 업데이트 여부를 결정하게 된다.업데이트 메시지는 어떻게 표시되는 걸까?단말로 메시지를 보내는 방법에는 세 가지 방법이 있다. 단순 SMS를 이용한 알림 -&amp;gt; 간단하지만 비용이 발생할 수 있다. 앱과 서버를 연결한 알림-&amp;gt; 앱에서 서버와의 연결을 만들어놓고 폴링하는 과정이 필요하며 백그라운드 서비스를 이용해 연결을 유지      해야 하므로 간단하지 않다. 구글의 푸시 서비스(FCM)를 사용하여 알림 -&amp;gt; 구글의 클라우드 서비스를 사용해 메시지 전송 방식을 최적화한 서비스 방식 -&amp;gt; 앱에서 서버로 직접 연결할 필요가 없으며 단말의 내부 연결을 공유하여 메시지를 수신하는 방식세 번째 푸시 서비스는 FCM(Firebase Cloud Messaging) 이라고 불린다.FCM은 앱 사용자에게 포그라운드 상태 (앱 실행 중)나 백그라운드(앱 실행 x) 상태나 알림을 보낼 수 있다.푸시 서비스란 ‘업데이트가 있습니다.’ 와 같은 메시지를 구글 클라우드 서버에서 구글 Play 스토어가 설치된 단말기로 보내는 방식이다.이 푸시 서비스를 사용하는 각각의 앱은 구글 클라우드 서버에 직접 연결하지 않는다.그 이유는 단말에서 연결을 유지하고 있기 때문이다.만약 위 구글 서비스를 사용하지 않고 직접 구현하려면 단말에서 서버로 연결을 유지하면서 동시에 연결을 지속적으로 유지해야 한다. 따라서 일정 시간 간격으로 연결이 끊어졌는지 검사하는 Polling 메커니즘을 구현해야한다하지만 폴링 기능을 구현하게 되면 그 과정에서 단말의 하드웨어 리소스나 전원을 많이 소모하는 문제가 발생하게 된다. 결국 구글에서 제공하는 FCM을 사용하는 것이 효과적으로 푸시 메시지를 보낼 수 있는 방법이 된다.FCM 푸시 메시지 처리 과정1. 단말은 자신을 클라우드 서버에 등록하고 서버로부터 등록 id를 받는다.2. 등록 ID는 메시지 전송을 담당할 애플리케이션 서버로 보낸 후 메시지를 기다린다.3. 보내려는 메시지는 애플리케이션 서버에서 클라우드에 접속한 후 전송한다.4. 클라우드 서버로 전송된 메시지는 대상 단말에 보내진다.기본적으로 푸시 메시지를 받으려면 클라우드 서버에 자신의 단말이 등록되어 있어야 한다.단말 등록 과정에서 등록 id를 받게 되고 푸시 메시지를 보내는 쪽에서 상대방의 등록 id를 사용해야 메시지를 보낼 수 있다. 등록 id는 전송 허가서와 같은 역할을 하는셈이다.보통 웹 서버에 푸시 메시지를 전송하는 기능을 추가하여 구성하는 경우가 많다.이 어플리케이션 서버는 직접 단말로 메시지를 보낼 수 없으므로 클라우드 서버를 통해 보내게 된다.즉, 어플리케이션 서버 -&amp;gt; 클라우드서버 -&amp;gt; 단말 형태를 띠게 된다.위 과정은 다음과 같은 두 가지 내용을 알아야한다.1. 어플리케이션 서버에 저장된 단말의 등록 id2. 어플리케이션 서버에서 클라우드 서버로 접속하기 위한 인증 정보첫 번째는 단말의 등록 id이다.푸시 메시지를 보내기 위해서는 어플리케이션 서버가 어떤 단말로 메시지를 보내 줄 것인지에 대한 정보가 필요하게 된다.이 등록 id는 등록한 단말별로 고유한 값이 되므로 어플리케이션 서버에 저장되며, 클라우드 서버가 메시지를 보내주어야 할 단말을 구분하는데 사용된다.두 번째로 클라우드 서버로 접속하기 위한 인증 정보이다.메시지를 전송할 때도 아무나 접속하여 단말 메시지를 보내면 안되므로 애플리케이션 서버가 API 키라는 고유한 값을 포함하여 메시지를 보내도록 한다.이 인증 정보는 어떤 사람이 어떤 서비스에 사용하는지 구별하기 위한 것이므로 개발자가 만드는 애플리케이션을 FCM 사이트에 등록해야 사용할 수 있다.예제FCM 설정 페이지에서 프로젝트 만들기FCM을 사용하려면 FCM 설정 페이지에서 프로젝트를 새로 만들어야 한다.FCM은 여러 구글 서비스 중 하나인 Firebase에 통합되어 있어 Firebase 개발자 콘솔 페이지에서 새로운 프로젝트를 만들거나 설정할 수 있다.아래 홈페이지에 들어가 프로젝트를 만들어주자. Firebase 개발자 콘솔 페이지 안드로이드 아이콘을 클릭다운로드를 해서 프로젝트의 app 폴더에 넣어준다.이렇게 하면 성공적으로 프로젝트가 만들어진다.인제 FCM 사용을 위해 추가 설정을 해주자.build.gradle(Project:SamplePath)dependencies { classpath &#39;com.google.gms:google-services:4.3.10&#39; }위의 클래스 패치를 추가해 준다.build.gradle(Module:SamplePath)plugins { id &#39;com.android.application&#39; id &#39;com.google.gms.google-services&#39; }dependencies { implementation platform(&#39;com.google.firebase:firebase-bom:29.0.4&#39;) implementation &#39;com.google.firebase:firebase-analytics&#39; implementation &#39;com.google.firebase:firebase-messaging:21.1.0&#39;플러그인과 의존성을 추가해준다.위의 29.0.4 같은 숫자들은 프로젝트를 언제 만들었는지에 따라 달라지므로 개발자 콘솔 페이지에 있는 설명글을 확인해서 넣어주자.이렇게 하면 FCM를 사용할 때 필요한 기본적인 설정이 끝난다.FCM을 사용하려면 앱 프로젝트 안에 두 개의 서비스를 만들어야 한다.첫 번째 서비스 파일을 만들어 보자.프로젝트 창의 왼쪽 프로젝트 영역에서 app를 선택한 후 오른쪽 마우스를 클릭[New -&amp;gt; Service -&amp;gt; Service] 메뉴를 누른다.대화 상자가 표시되면 Class Name 입력 상자에 MyFirebaseMessagingService를 입력한다.MyFirebaseMessagingService.classpackage org.techtown.push;import android.app.Service;import android.content.Context;import android.content.Intent;import android.os.IBinder;import android.util.Log;import com.google.firebase.messaging.FirebaseMessagingService;import com.google.firebase.messaging.RemoteMessage;import java.util.Map;public class MyFirebaseMessagingService extends FirebaseMessagingService { public MyFirebaseMessagingService() { } @Override public void onNewToken(String token){ // 새로운 토큰을 확인했을 때 호출되는 메서드 super.onNewToken(token); // token은 앱의 등록 id를 의미 Log.e(&quot;FMS&quot;, &quot;onNewToken 호출됨: &quot; + token); } @Override // 푸시 메시지를 받았을 떄 그 내용 확인한 후 액티비티 쪽으로 보내는 메서드 호출 public void onMessageReceived(RemoteMessage remoteMessage){ // 새로운 메시지를 받았을 때 호출되는 메서드 Log.d(&quot;FMS&quot;, &quot;onMessageReceived 호출됨.&quot;); String from = remoteMessage.getFrom(); Map&amp;lt;String, String&amp;gt; data = remoteMessage.getData(); String contents = data.get(&quot;contents&quot;); Log.d(&quot;FMS&quot;, from + &quot;, contents : &quot; + contents); sendToActivity(getApplicationContext(), from, contents); } // 액티비티 쪽으로 데이터를 보내기 위해 인텐트 객체를 만들고 startActivity 메서드 호출 private void sendToActivity(Context context, String from, String contents){ Intent intent = new Intent(context, MainActivity.class); intent.putExtra(&quot;from&quot;, from); intent.putExtra(&quot;contents&quot;, contents); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP| Intent.FLAG_ACTIVITY_CLEAR_TOP); context.startActivity(intent); }}위와 같이 수정한다.구글 클라우드 서버에서 보내오는 메시지는 위 클래스에서 받을 수 있으며, 메시지가 도착하면 onMessageReceived 메서드가 자동으로 호출된다.따라서 onMessageReceived 메서드를 재정의하면 구글 클라우드 서버에서 보내오는 메시지를 받아서 처리할 수 있다.onNewToken 메서드는 이 앱이 Firebase 서버에 등록되었을 때 호출된다.AndroidManifest.xml 파일을 열어 인텐트 필터를 갖도록 설정해주고 인터넷 권한을 추가해주자.AndroidManifest.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.push&quot;&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&amp;gt; &amp;lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.SamplePush&quot;&amp;gt; &amp;lt;service android:name=&quot;.MyFirebaseMessagingService&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; android:stopWithTask=&quot;false&quot;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name =&quot;com.google.firebase.MESSAGING_EVENT&quot; /&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;/service&amp;gt; &amp;lt;activity android:name=&quot;.MainActivity&quot; android:exported=&quot;true&quot;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt; &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;/activity&amp;gt; &amp;lt;/application&amp;gt;&amp;lt;/manifest&amp;gt;인제 소스 코드에 단말 등록 기능을 추가하자.MainActivity.javapackage org.techtown.push;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.TextView;import com.google.android.gms.tasks.OnCompleteListener;import com.google.android.gms.tasks.Task;import com.google.firebase.iid.FirebaseInstanceIdReceiver;import com.google.firebase.installations.FirebaseInstallations;import com.google.firebase.messaging.FirebaseMessaging;public class MainActivity extends AppCompatActivity { TextView textView; TextView textView2; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); textView2 = findViewById(R.id.textView2); FirebaseMessaging.getInstance().getToken() // 등록 id 확인을 위한 리스너 설정 .addOnCompleteListener(new OnCompleteListener&amp;lt;String&amp;gt;() { @Override public void onComplete(@NonNull Task&amp;lt;String&amp;gt; task) { if(!task.isSuccessful()){ Log.d(&quot;Main&quot;, &quot;토큰 가져오는데 실패&quot;, task.getException()); return; } String newToken = task.getResult(); println(&quot;등록id : &quot; + newToken); } }); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Task&amp;lt;String&amp;gt; instanceId = FirebaseInstallations.getInstance().getId() .addOnCompleteListener(new OnCompleteListener&amp;lt;String&amp;gt;() { @Override public void onComplete(@NonNull Task&amp;lt;String&amp;gt; task) { if (task.isSuccessful()) { Log.d(&quot;Installations&quot;, &quot;Installation ID: &quot; + task.getResult()); println(&quot;확인된 인스턴스 id: &quot; + task.getResult()); } else { Log.e(&quot;Installations&quot;, &quot;Unable to get Installation ID&quot;); } } }); } }); } public void send(String input){ } @Override // 서비스로부터 인텐트를 받았을 때 처리 protected void onNewIntent(Intent intent){ println(&quot;onNewIntent 호출됨&quot;); if(intent != null) processIntent(intent); super.onNewIntent(intent); } private void processIntent(Intent intent){ String from = intent.getStringExtra(&quot;from&quot;); if(from == null){ println(&quot;form is null&quot;); return; } // 보낸 데이터는 contents 키를 사용해서 확인 String contents = intent.getStringExtra(&quot;contents&quot;); textView.setText(&quot;[&quot; + from + &quot;]로부터 수신한 데이터: &quot; + contents); } public void println(String data){ textView2.append(data + &quot;\\n&quot;); }}}책에서는 인스턴스 등록 id 값을 확인할 때 FirebaseInstnaceId.getInstance().getId() 메서드를 사용 하라고 했는데 위의 메서드가 자꾸 인식 오류가 났다.원인을 알아 본 결과 위의 방식은 예전 방식이여서 지원하지 않는다고 한다.. -_-따라서 FirebaseInstallations.getInstance().getId()로 확인해야 한다. 참고 사이트 이렇게 하면 푸시 메시지를 받는 앱의 기능이 완성 되었다.메시지 전송 앱 만들기SamplePushSend라는 새 프로젝트를 만들어 준다.메시지 전송할때 Volley 라이브러리를 사용할 것이므로 아래와 같이 라이브러리를 추가한다.build.gradle(Module: SamplePushSend.app)dependencies { implementation &#39;com.android.volley:volley:1.2.0&#39;MainActivity.java를 수정해주자.package org.techtown.push.send;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import androidx.appcompat.app.AppCompatActivity;import com.android.volley.AuthFailureError;import com.android.volley.Request;import com.android.volley.RequestQueue;import com.android.volley.Response;import com.android.volley.VolleyError;import com.android.volley.toolbox.JsonObjectRequest;import com.android.volley.toolbox.Volley;import org.json.JSONArray;import org.json.JSONObject;import java.util.HashMap;import java.util.Map;public class MainActivity extends AppCompatActivity { EditText editText; TextView textView; static RequestQueue requestQueue; static String regId = &quot;Input Your Installation ID&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText = findViewById(R.id.editText); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { String input = editText.getText().toString(); send(input); } }); if (requestQueue == null) { requestQueue = Volley.newRequestQueue(getApplicationContext()); } } public void send(String input) { // 전송 정보를 담아둘 JSONObject 객체 생성 JSONObject requestData = new JSONObject(); try { requestData.put(&quot;priority&quot;, &quot;high&quot;); // 옵션 추가 // 전송 할 데이터 추가 JSONObject dataObj = new JSONObject(); dataObj.put(&quot;contents&quot;, input); requestData.put(&quot;data&quot;, dataObj); // 푸시 메시지를 수신할 단말 등록 ID를 JSONArray에 추가한 후 requestData 객체에 추가 JSONArray idArray = new JSONArray(); idArray.put(0, regId); requestData.put(&quot;registration_ids&quot;, idArray); } catch (Exception e) { e.printStackTrace(); } sendData(requestData, new SendResponseListener() { // 푸쉬 전송을 위해 정의한 메서드 호출 @Override public void onRequestCompleted() { println(&quot;onRequestCompleted() 호출됨.&quot;); } @Override public void onRequestStarted() { println(&quot;onRequestStarted() 호출됨.&quot;); } @Override public void onRequestWithError(VolleyError error) { println(&quot;onRequestWithError() 호출됨.&quot;); } }); } public interface SendResponseListener { public void onRequestStarted(); public void onRequestCompleted(); public void onRequestWithError(VolleyError error); } public void sendData(JSONObject requestData, final SendResponseListener listener) { // Volley 요청 객체를 만들고 요청을 위한 데이터 설정, 두 번째 매개 변수는 클라우드 서버의 요청 주소 JsonObjectRequest request = new JsonObjectRequest( Request.Method.POST, &quot;https://fcm.googleapis.com/fcm/send&quot;, requestData, new Response.Listener&amp;lt;JSONObject&amp;gt;() { @Override public void onResponse(JSONObject response) { listener.onRequestCompleted(); } }, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { listener.onRequestWithError(error); } }) { @Override protected Map&amp;lt;String, String&amp;gt; getParams() throws AuthFailureError { Map&amp;lt;String, String&amp;gt; params = new HashMap&amp;lt;String, String&amp;gt;(); return params; } @Override public Map&amp;lt;String, String&amp;gt; getHeaders() throws AuthFailureError { Map&amp;lt;String, String&amp;gt; headers = new HashMap&amp;lt;String, String&amp;gt;(); headers.put(&quot;Authorization&quot;, &quot;key= Input Your API KEY&quot;); return headers; } @Override public String getBodyContentType() { return &quot;application/json&quot;; } }; request.setShouldCache(false); listener.onRequestStarted(); requestQueue.add(request); } public void println(String data) { textView.append(data + &quot;\\n&quot;); }}getHeader 메서드 안의 key값은 FCM 개발자 콘솔 페이지에서 확인할 수 있다.프로젝트 설정 -&amp;gt; 서버 키 복사해서 넣으면 된다.regId 변수의 값은 Firebase 클라이언트 식별자 id 값이다.마지막으로 인터넷 권한을 추가해주면 끝난다.AndroidManifest.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.push.send&quot;&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&amp;gt;" }, { "title": "상단 알림으로 알려주기", "url": "/posts/Notificatoin/", "categories": "Android, PushService", "tags": "android, pushservice, alerm", "date": "2022-02-06 20:22:00 +0900", "snippet": "상단 알림으로 알려주기알림은 화면 상단에 정보를 표시하여 사용자가 알 수 있도록 한다.이 알림 기능은 주로 다른 사람에게서 메시지를 받았을 때나 단말의 상태를 표시할 때 사용한다.예를 들어 카카오톡 앱을 직접 만든다면 앱이 실행되지 않은 상태에서도 사용자에게 메시지가 왔다는 것을 알려줄 필요가 있다.이때 백그라운드에서 동작하는 서비스에서 알림을 표시하면 사용자에게 알려줄 수 있다.알림은 NotificationManager 시스템 서비스를 이용해 화면 상단에 띄울 수 있다.알림을 띄우려면 Notification 객체를 만들어야 하는데 이 객체는 NotificationCompat.Builder 객체를 이용해서 만들 수 있다.예제MainActivity.javapackage org.techtown.noti;import androidx.appcompat.app.AppCompatActivity;import androidx.core.app.NotificationCompat;import android.app.Notification;import android.app.NotificationChannel;import android.app.NotificationManager;import android.app.PendingIntent;import android.content.Intent;import android.os.Build;import android.os.Bundle;import android.view.View;import android.widget.Button;public class MainActivity extends AppCompatActivity { NotificationManager manager; private static String CHANNEL_ID = &quot;channel1&quot;; private static String CHANNEL_NAME = &quot;Channel1&quot;; private static String CHANNEL_ID2 = &quot;channel2&quot;; private static String CHANNEL_NAME2 = &quot;Channel2&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { showNoti1(); } }); Button button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { showNoti2(); } }); } public void showNoti1() { manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); NotificationCompat.Builder builder = null; if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.O) { manager.createNotificationChannel(new NotificationChannel( CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_DEFAULT) ); builder = new NotificationCompat.Builder(this, CHANNEL_ID); } else { builder = new NotificationCompat.Builder(this); } builder.setContentTitle(&quot;간단 알림&quot;); builder.setContentText(&quot;알림 메시지입니다.&quot;); builder.setSmallIcon(android.R.drawable.ic_menu_view); Notification noti = builder.build(); manager.notify(1, noti); } public void showNoti2() { manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); NotificationCompat.Builder builder = null; if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.O) { manager.createNotificationChannel(new NotificationChannel( CHANNEL_ID2, CHANNEL_NAME2, NotificationManager.IMPORTANCE_DEFAULT )); builder = new NotificationCompat.Builder(this, CHANNEL_ID2); } else { builder = new NotificationCompat.Builder(this); } Intent intent = new Intent(this, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this, 101, intent, PendingIntent.FLAG_UPDATE_CURRENT); builder.setContentTitle(&quot;간단 알림&quot;); builder.setContentText(&quot;알림 메세지 입니다.&quot;); builder.setSmallIcon(android.R.drawable.ic_menu_view); builder.setAutoCancel(true); builder.setContentIntent(pendingIntent); Notification noti = builder.build(); manager.notify(2, noti); }}showNoti1 메서드 안에 NotificationManager 객체를 참조한 후 NotificationCompat.Builder 객체를 생성한다.안드로이드 오레오 버전 이전과 이후에 Builder 객체를 만드는 방법이 다르기 때문에 Build.VERSION.SDK_INT 상수의 값을 비교하여 단말의 OS 버전에 따라 다른 코드가 실행되도록 한다.오레오 버전 이후 버전에서는 알림 채널이 지정되어야 하며, 채널은 createNotificationChannel메서드를 이용해 생성할 수 있다.Builder 객체가 만들어지면 알림 정보를 설정할 수 있고 Builder 객체의 build 메서드를 호출하면 Notification 객체가 생성된다.NotificationManager의 notify 메서드를 호출하면서 이 Notification 객체를 매개변수로 전달하면 알림을 띄우게 된다.또한 showNoti2 메서드는 버튼을 눌렀을 때PendingIntent를 만들어 Notification을 만들 때 설정한다.PedingIntent는 Intent와 비슷하지만 시스템에서 대기하는 역할을한다.예를 들어 액티비티를 띄우는 역할을 하는 메서드가 startActivity 또는 startActivityForResult인데 이 메서드를 호출하면 시스템에서는 즉시 해석하고 처리한다.하지만 PendingIntent는 지정된 상황이 될 때까지 보관하고 있게 된다.setAutoCancel 메서드는 알림을 클릭했을 때 자동으로 알림 표시를 삭제하라는 설정이다.setContentIntent 메서드에는 PendingIntent 객체가 매개 변수로 전달된다.그리고 PendingIntent 객체에는 Intent 객체가 매개 변수로 전달되는데 이렇게 되면 알림을 클릭했을 때 이 Intent 객체를 이용해 액티비티를 띄워준다. 액티비티는 MainActivity가 뜨도록 MainActivity.class로 지정했다.결과첫 번째 버튼을 클릭하면 상단 바에 알람이 띄워지게 되고두 번째 버튼을 클릭하면 상단 바에 알람이 띄워지고 알림을 클릭하면 MainActivity 화면으로 돌아온다.알름을 표시하는 방법은 이것 외에도 글자를 많이 표시하거나 이미지를 표시하거나 또는 목록을 표시하는 방법 등이 있다.이것을 스타일 알림 (Styled Notification) 이라고 부른다." }, { "title": "진동과 소리로 알려주기", "url": "/posts/vibrator/", "categories": "Android, PushService", "tags": "android, pushservice, vibrator, alerm", "date": "2022-02-06 19:34:00 +0900", "snippet": "진동과 소리로 알려주기사용자에게 무언가를 알려주는 가장 간단한 방법은 진동과 소리이디.진동은 얼마 동안 울리도록 지정할 수 있으며 Vibrator라는 시스템 서비스 객체를 사용한다.vibrate라는 이름의 메서드가 있어 진동이 울리는 패턴이나 시간을 지정할 수 있다.APIpublic void vibrate (long millseconds) // 예전 방식public void vibrate (Vibration vibe) // 안드로이드 26버전 이후vibrate 메서드의 파라미터로 진동을 얼마나 지속시킬 것인지 전달해준다.안드로이드 버전 26부터 VibrationEffect를 매개 변수로 전달하는 방식으로 바뀌었다.변경된 내용을 반영하기 위해서는 Build.VERSION.SDK_INT 상수를 이용해 현재 단말의 버전을 체크하는 과정이 필요하다.소리를 이용해 사용자에게 알리고 싶다면 Ringtone 객체를 사용할 수 있다.APIpublic void play()Rington 객체의 play 메서드를 호출하면 소리가 울리게 된다.만약 API에서 제공하는 소리가 마음에 들지 않는다면 직접 음원 파일을 만들어 재생할 수 있다.음원 파일을 만들어 재생할 때는 미디어 플레이어 (MediaPlayer) 객체를 사용할 수 있다.예제package org.techtown.vibrate;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.media.MediaPlayer;import android.media.Ringtone;import android.media.RingtoneManager;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.os.VibrationEffect;import android.os.Vibrator;import android.view.View;import android.widget.Button;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ Vibrator vibrator = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE); if(Build.VERSION.SDK_INT &amp;gt;= 26){ vibrator.vibrate(VibrationEffect.createOneShot(1000,10)); }else vibrator.vibrate(1000); } }); Button button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v) { Uri uri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION); // 소리를 울리기 위해 Ringtone 객체 참조하기 Ringtone ringtone = RingtoneManager.getRingtone(getApplicationContext(), uri); ringtone.play(); } }); Button button3 = findViewById(R.id.button3); button3.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ MediaPlayer player = MediaPlayer.create(getApplicationContext(), R.raw.beep); player.start(); } }); }}첫 번째 버튼을 클릭했을 때 먼저 Vibrator 객체를 참조한다.이 객체에는 vibrate 메서드가 정의되어 있는데 안드로이드 버전 26부터 파라미터가 변경되었으므로 Build.VERSION.SDK_INT 상수의 값과 현재 단말의 OS 버전 값을 비교하도록 한다.만약 26 이상이라면 VibratorEffect.createOneShot 메서드를 호출하여 반환된 객체를 매개 변수로 전달한다.이 메서드에 전달되는 1000, 10 값은 각각 지속시간과 음량을 나타내며 26 미만이라면 진동 지속 시간만 전달한다.두 번째 버튼을 클릭했을 때는 API에서 제공하는 기본 음원을 재생하도록 한다.Ringtone 객체는 RingtoneManager.getRingtone 메서드를 이용해 참조할 수 있으며 Uri 객체를 전달하면 지정한 음원을 Ringtone 객체를 참조한다.세 번째 버튼을 클릭했을 때는 직접 지정한 음원을 재생하도록 한다.여기에서는 raw 폴더안에 들어 있는 beep.wav 파일을 지정했다.진동을 우리기 위해서는 VIBRATE 권한이 필요하므로 권한을 추가해주자.AndroidManifet.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.vibrate&quot;&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&amp;gt;결과" }, { "title": "백준 강의실 배정 (11000)", "url": "/posts/back-1003/", "categories": "PS, Greedy", "tags": "backjoon, greedy, gold5", "date": "2022-02-05 03:26:00 +0900", "snippet": "백준 강의실 배정 (11000)문제수강신청의 마스터 김종혜 선생님에게 새로운 과제가 주어졌다.김종혜 선생님한테는 Si에 시작해서 Ti에 끝나는 N개의 수업이 주어지는데, 최소의 강의실을 사용해서 모든 수업을 가능하게 해야 한다.참고로, 수업이 끝난 직후에 다음 수업을 시작할 수 있다. (즉, Ti ≤ Sj 일 경우 i 수업과 j 수업은 같이 들을 수 있다.)수강신청 대충한 게 찔리면, 선생님을 도와드리자!입력첫 번째 줄에 N이 주어진다. (1 ≤ N ≤ 200,000)이후 N개의 줄에 Si, Ti가 주어진다. (0 ≤ Si &amp;lt; Ti ≤ 109)출력강의실의 개수를 출력하라.문제 접근 이른 시작 시간 순으로 클래스 배열을 오름 차순 정렬한다. 정렬한 배열을 하나 씩 꺼내서 우선순위 큐에 넣는다. (종료 시간 빠른 우선순위 큐) 우선 순위 큐 맨 앞 원소의 종료 시간과 배열안의 요소 시작 시간과 비교해 나간다. 종료시간이 시작시간 보다 작으면 우선순위 큐에서 하나 제거하고 배열 안의 요소를 다시 넣어준다. 위의 조건이 아니라면 우선순위 큐는 그대로 놔두고 배열 안의 요소를 큐에 넣는다.import java.io.*;import java.util.Arrays;import java.util.PriorityQueue;import java.util.StringTokenizer;class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); }}class Room implements Comparable&amp;lt;Room&amp;gt;{ int start; int end; public Room(int st, int end){ this.start = st; this.end = end; } @Override public int compareTo(Room other){ if(this.start == other.start) return (this.end &amp;gt;= other.end) ? 1 : -1; else return (this.start &amp;gt;= other.start) ? 1 : -1; }}public class Main { public static void main(String args[]) throws IOException{ FastScanner sc = new FastScanner(); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = sc.nextInt(); Room [] arr = new Room[n]; for(int i=0; i&amp;lt;n; i++) arr[i] = new Room(sc.nextInt(), sc.nextInt()); Arrays.sort(arr); PriorityQueue&amp;lt;Integer&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;(); pq.add(arr[0].end); for(int i=1; i&amp;lt;n; i++){ if(pq.peek() &amp;lt;= arr[i].start) { pq.add(arr[i].end); pq.poll(); }else{ pq.add(arr[i].end); } } bw.write(Integer.toString(pq.size())); bw.close(); }}런타임 에러시작 시간과 종료시간이 같을 경우를 고려 하지 않아서 위의 런타임 에러가 나왔다.문제의 코드class Room implements Comparable&amp;lt;Room&amp;gt;{ int st; int end; public Room(int st, int end){ this.st = st; this.end = end; } @Override public int compareTo(Room other){ return (this.st &amp;gt;= other.st) ? 1 : -1; }}수정 후 코드class Room implements Comparable&amp;lt;Room&amp;gt;{ int start; int end; public Room(int st, int end){ this.start = st; this.end = end; } @Override public int compareTo(Room other){ if(this.start == other.start) return (this.end &amp;gt;= other.end) ? 1 : -1; else return (this.start &amp;gt;= other.start) ? 1 : -1; }}" }, { "title": "백준 온라인 판매 (1246)", "url": "/posts/back-1246/", "categories": "PS, Greedy", "tags": "backjoon, greedy, silver5", "date": "2022-02-04 17:30:00 +0900", "snippet": "백준 온라인 판매 (1246)현재 가지고 있는 달걀 수를 넘지 않게 최대 이익을 계산 해주면 되는 문제import java.io.*;import java.util.Collections;import java.util.PriorityQueue;import java.util.StringTokenizer;class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); }}public class Main { public static void main(String args[]) throws IOException{ BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); FastScanner sc = new FastScanner(); int eggNum = sc.nextInt(); int customerNum = sc.nextInt(); PriorityQueue&amp;lt;Integer&amp;gt; customer = new PriorityQueue&amp;lt;Integer&amp;gt;(Collections.reverseOrder()); int max = Integer.MIN_VALUE; int price = 0; for(int i=0; i&amp;lt;customerNum; i++) customer.add(sc.nextInt()); int maxSellNum = (customer.size() &amp;gt;= eggNum) ? eggNum : customer.size(); for(int i=0; i&amp;lt;customerNum; i++){ int tmp = (i+1 &amp;gt;= maxSellNum) ? maxSellNum : i+1; // 팔 수 있는 최대 달걀 수를 넘지 않게 해주는 수식 int curPrice = customer.peek() * tmp; // 현재 가격으로 얻을 수 있는 최대 이익 계산 if(max &amp;lt;= curPrice) { max = curPrice; price = customer.poll(); }else customer.poll(); } bw.write(Integer.toString(price ) + &quot; &quot; + Integer.toString(max) + &quot;\\n&quot;); bw.close(); }}" }, { "title": "백준 기타줄 (1049)", "url": "/posts/back-1049/", "categories": "PS, Greedy", "tags": "backjoon, greedy, silver4", "date": "2022-02-04 17:00:00 +0900", "snippet": "백준 기타줄 (1049) 우선순위 큐 두개를 만들어 패키지 최소 가격과, 낱개 최소 가격을 구한다. Min(패키지 가격 * (기타줄 개수 / 6) , 단품가격 * 필요한 기타줄 개수) 7개 이상일 경우 패키지 + 단품 섞어서 살 수 있으므로 주의import java.io.*; import java.util.PriorityQueue; import java.util.StringTokenizer; class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); } } public class Main { public static void main(String args[]) throws IOException{ BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); FastScanner sc = new FastScanner(); PriorityQueue&amp;lt;Integer&amp;gt; pack = new PriorityQueue&amp;lt;Integer&amp;gt;(); PriorityQueue&amp;lt;Integer&amp;gt; unit = new PriorityQueue&amp;lt;Integer&amp;gt;(); int N = sc.nextInt(); // 사야하는 기타 줄 수 int M = sc.nextInt(); // 브랜드 수 for(int i=0; i&amp;lt;M; i++){ pack.add(sc.nextInt()); unit.add(sc.nextInt()); } int ans = 0; int packMin = pack.peek(); int unitMin = unit.peek(); int needPack = N / 6; int needUni = N % 6; ans += (packMin &amp;lt; unitMin * 6) ? (packMin * needPack) : (unitMin * 6 * needPack); ans += (packMin &amp;gt; unitMin * needUni) ? (needUni * unitMin) : (packMin); bw.write(Integer.toString(ans) + &quot;\\n&quot;); bw.close(); } }" }, { "title": "앱 위젯 만들기", "url": "/posts/AppWidget/", "categories": "Android, GPS", "tags": "android, location, gps, appwidget", "date": "2022-02-04 15:07:00 +0900", "snippet": "앱 위젯 만들기앱 위젯(App Widget) 은 안드로이드 단말이 홈 화면에서 위젯을 바로 보여주고 싶을 때 사용할 수 있다. 일반적으로 위젯은 홈 화면을 길게 누르면 추가할 수 있는 화면이 표시된다.또는 홈 화면 하단 중앙에 있는 앱 리스트 아이콘을 눌렀을 때 추가하는 화면이 표시되는 단말도 있다.앱 위젯은 다음과 같이 두가지로 구성 된다.     앱 위젯 호스트 위젯이 담고 있는 그릇 앱 위젯 제공자 위젯을 보여주는 제공자 앱 위젯 제공자가 앱 위젯 호스트 안에서 위젯을 보여준다.이런 앱 위젯을 구성할 때 필요한 요소는 아래와 같이 세 가지 있다.     위젯의 초기 뷰 레이아웃 앱 위젯이 처음에 화면에 나타날 때 필요한 레이아웃을 정의함XML로 정의한다. 앱 위젯 제공자 정보 앱 위젯을 위한 메타데이터(레이아웃, 업데이트 주기 등)를 가지고 있다. 앱 위젯 제공자 클래스에 대한 정보를 가지고 있다.XML로 정의한다. 앱 위젯 제공자 앱 위젯과 정보를 주고 받기 위한 기본 클래스이다. 브로드캐스트 수신자로 만들며 앱 위젯의 상태 변화에 따른 기능을 구현한다. 앱 위젯을 만든다는 것은 앱 위젯 제공자를 만드는 것이라고 할 수 있으며, 구성에 필요한 세가지 요소를 순서대로 만들면 앱 위젯을 구성할 수 있다.앱 위젯으로 만든 뷰는 주기적으로 업데이트될 수 있는데, 그럴 때마다 앱 위젯 제공자의 onUpdate 메서드가 호출된다.만약 앱 위젯 제공자가 위젯을 바꾸고 싶을 경우에는 앱 위젯 매니저를 통해 업데이트 할 수 있다.예제앱 위젯 화면으로 보여줄 텍스트 뷰 정의&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/background&quot; android:padding=&quot;10dp&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/txtInfo&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center_horizontal|center_vertical&quot; android:text=&quot;내 위치 정보 수신중 ...&quot; android:textColor=&quot;#FFFFFFFF&quot; android:lineSpacingExtra=&quot;4dp&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/LinearLayout&amp;gt;앱 위젯에 들어갈 수 있는 뷰는 아래와 같다. 유형 뷰 이름 뷰 그룹 FrameLayout, LinearLayout, RelativeLayout 뷰 AnalogClock, Button, Chronometer ImageButton, ImageView, ProgressBar, TextView 앱 위젯으로 표현되는 뷰들이 다른 프로세스에 들어가고 있기 때문에 다른 프로세스의 뷰를 접근하기 위해 RemoteViews 객체가 사용된다.인제 앱 위젯 제공자 정보를 넣어주자./app/res/xml/mylocationinfo.xml&amp;lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:minWidth=&quot;294dp&quot; android:minHeight=&quot;72dp&quot; android:updatePeriodMillis=&quot;1800000&quot; android:initialLayout=&quot;@layout/mylocation&quot;&amp;gt; &amp;lt;/appwidget-provider&amp;gt;앱 위젯이 주기적으로 업데이트될 때 처리할 코드를 구현하자.package org.techtown.location.widget; import android.app.PendingIntent; import android.app.Service; import android.appwidget.AppWidgetManager; import android.appwidget.AppWidgetProvider; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.location.Address; import android.location.Criteria; import android.location.Geocoder; import android.location.Location; import android.location.LocationListener; import android.location.LocationManager; import android.net.Uri; import android.os.Bundle; import android.os.IBinder; import android.util.Log; import android.widget.RemoteViews; import java.util.List; public class MyLocationProvider extends AppWidgetProvider { public static double ycoord = 0.0D; public static double xcoord = 0.0D; @Override public void onDeleted(Context context, int[] appWidgetIds) { super.onDeleted(context, appWidgetIds); } @Override public void onDisabled(Context context) { super.onDisabled(context); } @Override public void onEnabled(Context context) { super.onEnabled(context); } @Override public void onReceive(Context context, Intent intent) { super.onReceive(context, intent); } @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) { super.onUpdate(context, appWidgetManager, appWidgetIds); Log.d(&quot;MyLocationProvider&quot;, &quot;onUpdate() called : &quot; + ycoord + &quot;, &quot; + xcoord); final int size = appWidgetIds.length; for (int i = 0; i &amp;lt; size; i++) { int appWidgetId = appWidgetIds[i]; //String uri = &quot;geo:&quot;+ ycoord + &quot;,&quot; + xcoord + &quot;?z=10&quot;; //Intent intent = new Intent(android.content.Intent.ACTION_VIEW, Uri.parse(uri)); String uriBegin = &quot;geo:&quot; + ycoord + &quot;,&quot; + xcoord; String query = ycoord + &quot;,&quot; + xcoord + &quot;(&quot; + &quot;내위치&quot; + &quot;)&quot;; String encodedQuery = Uri.encode(query); String uriString = uriBegin + &quot;?q=&quot; + encodedQuery + &quot;&amp;amp;z=15&quot;; Uri uri = Uri.parse(uriString); Intent intent = new Intent(Intent.ACTION_VIEW, uri); PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0); RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.mylocation); views.setOnClickPendingIntent(R.id.txtInfo, pendingIntent); appWidgetManager.updateAppWidget(appWidgetId, views); } // gps 위치 확인을 위한 서비스 시작 context.startService(new Intent(context,GPSLocationService.class)); } public static class GPSLocationService extends Service { public static final String TAG = &quot;GPSLocationService&quot;; private LocationManager manager = null; private LocationListener listener = new LocationListener() { public void onStatusChanged(String provider, int status, Bundle extras) { } public void onProviderEnabled(String provider) { } public void onProviderDisabled(String provider) { } public void onLocationChanged(Location location) { Log.d(TAG, &quot;onLocationChanged() called.&quot;); // 위치 정보가 확인되면 updateCoordinates 메서드 호출 updateCoordinates(location.getLatitude(), location.getLongitude()); stopSelf(); } }; public IBinder onBind(Intent intent) { return null; } public void onCreate() { super.onCreate(); Log.d(TAG, &quot;onCreate() called.&quot;); manager = (LocationManager) getSystemService(LOCATION_SERVICE); } public int onStartCommand(Intent intent, int flags, int startId) { startListening(); return super.onStartCommand(intent, flags, startId); } public void onDestroy() { stopListening(); Log.d(TAG, &quot;onDestroy() called.&quot;); super.onDestroy(); } private void startListening() { Log.d(TAG, &quot;startListening() called.&quot;); final Criteria criteria = new Criteria(); criteria.setAccuracy(Criteria.ACCURACY_COARSE); criteria.setAltitudeRequired(false); criteria.setBearingRequired(false); criteria.setCostAllowed(true); criteria.setPowerRequirement(Criteria.POWER_LOW); final String bestProvider = manager.getBestProvider(criteria, true); try { if (bestProvider != null &amp;amp;&amp;amp; bestProvider.length() &amp;gt; 0) { manager.requestLocationUpdates(bestProvider, 500, 10, listener); } else { final List&amp;lt;String&amp;gt; providers = manager.getProviders(true); for (final String provider : providers) { manager.requestLocationUpdates(provider, 500, 10, listener); } } } catch(SecurityException e) { e.printStackTrace(); } } private void stopListening() { try { if (manager != null &amp;amp;&amp;amp; listener != null) { manager.removeUpdates(listener); } manager = null; } catch (final Exception ex) { } } private void updateCoordinates(double latitude, double longitude) { Geocoder coder = new Geocoder(this); List&amp;lt;Address&amp;gt; addresses = null; String info = &quot;&quot;; Log.d(TAG, &quot;updateCoordinates() called.&quot;); try { addresses = coder.getFromLocation(latitude, longitude, 2); if (null != addresses &amp;amp;&amp;amp; addresses.size() &amp;gt; 0) { int addressCount = addresses.get(0).getMaxAddressLineIndex(); if (-1 != addressCount) { for (int index = 0; index &amp;lt;= addressCount; ++index) { info += addresses.get(0).getAddressLine(index); if (index &amp;lt; addressCount) info += &quot;, &quot;; } } else { info += addresses.get(0).getFeatureName() + &quot;, &quot; + addresses.get(0).getSubAdminArea() + &quot;, &quot; + addresses.get(0).getAdminArea(); } } Log.d(TAG, &quot;Address : &quot; + addresses.get(0).toString()); } catch (Exception e) { e.printStackTrace(); } coder = null; addresses = null; if (info.length() &amp;lt;= 0) { info = &quot;[내 위치] &quot; + latitude + &quot;, &quot; + longitude + &quot;\\n터치하면 지도로 볼 수 있습니다.&quot;; } else { info += (&quot;\\n&quot; + &quot;[내 위치] &quot; + latitude + &quot;, &quot; + longitude + &quot;)&quot;); info += &quot;\\n터치하면 지도로 볼 수 있습니다.&quot;; } RemoteViews views = new RemoteViews(getPackageName(), R.layout.mylocation); views.setTextViewText(R.id.txtInfo, info); ComponentName thisWidget = new ComponentName(this, MyLocationProvider.class); AppWidgetManager manager = AppWidgetManager.getInstance(this); manager.updateAppWidget(thisWidget, views); xcoord = longitude; ycoord = latitude; Log.d(TAG, &quot;coordinates : &quot; + latitude + &quot;, &quot; + longitude); } } }텍스트 뷰를 눌렀을 때 내 위치를 이용해 지도를 보여줄 수 있는 가장 간단한 방법은 “geo:”로 시작하는 URI 객체를 만들어 인텐트로 지도를 띄워주는 것이다.내 위치를 띄우는데 사용되는 URI 문자열 포맷은 다음과 같다.geo:&amp;lt;latitude&amp;gt;, &amp;lt;longitude&amp;gt;?z=&amp;lt;zoomLevel&amp;gt;위도와 경도 뒤에 오는 “z” 파라미터 값은 지도가 나타날 때 사용되는 확대/축소 수준을 지정하는 것이다.IntroActivity.javapackage org.techtown.location.widget; import android.os.Bundle; import android.util.Log; import androidx.appcompat.app.AppCompatActivity; import com.yanzhenjie.permission.Action; import com.yanzhenjie.permission.AndPermission; import com.yanzhenjie.permission.runtime.Permission; import java.util.List; public class IntroActivity extends AppCompatActivity { public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.intro); AndPermission.with(this) .runtime() .permission( Permission.ACCESS_FINE_LOCATION, Permission.ACCESS_COARSE_LOCATION) .onGranted(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { Log.d(&quot;Intro&quot;, &quot;허용된 권한 갯수 : &quot; + permissions.size()); } }) .onDenied(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { Log.d(&quot;Intro&quot;, &quot;거부된 권한 갯수 : &quot; + permissions.size()); } }) .start(); } }마지막으로 매니페스트 파일에 앱 위젯과 관련된 태그들을 정의해주자.AndroidManifest.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.location.widget&quot;&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&amp;gt; &amp;lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.SampleMyLocationWidget&quot;&amp;gt; &amp;lt;receiver android:name=&quot;.MyLocationProvider&quot;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;meta-data android:name=&quot;android.appwidget.provider&quot; android:resource=&quot;@xml/mylocationinfo&quot; /&amp;gt; &amp;lt;/receiver&amp;gt; &amp;lt;service android:name=&quot;.MyLocationProvider$GPSLocationService&quot;&amp;gt;&amp;lt;/service&amp;gt; &amp;lt;/application&amp;gt; &amp;lt;/manifest&amp;gt;" }, { "title": "지도에 아이콘 추가하기", "url": "/posts/ShowMarker/", "categories": "Android, GPS", "tags": "android, location, gps", "date": "2022-02-04 13:55:00 +0900", "snippet": "오버레이란?일반적으로 지구상의 현실 공간을 지도로 표현할 때는 레이어(Layer)로 분리하고 각각의 레이어에는 유사한 속성을 가진 객체들을 넣어두게 된다.구글맵에서는 이런 레이어들을 오버레이(Overlay)라고 부른다.(출처 : Google Map Layer - https://seefurther.withgoogle.com/)내 현재 위치 표시를 위한 오버레이 추가하기@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mapFragment = (SupportMapFragment) getSupportFragmentManager().findFragmentById(R.id.map); mapFragment.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(GoogleMap googleMap) { Log.d(&quot;Map&quot;, &quot;지도 준비됨.&quot;); map = googleMap; } }); mapFragment.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(GoogleMap googleMap) { Log.d(&quot;Map&quot;, &quot;GoogleMap is ready&quot;); map = googleMap; map.setMyLocationEnabled(true); } }); ... 중략 }... 중략 public void onResume(){ super.onResume(); if(map != null) map.setMyLocationEnabled(true); // 액티비티가 화면에 보일 때 내 위치 표시 활성화 } public void onPause(){ super.onPause(); if(map != null) map.setMyLocationEnabled(false); // 액티비티가 중지될 때 내 위치 표시 비활성화 }액티비티가 중지되거나 다시 시작할 때 현재 위치 표시하기 위해 setMyLocationEnabeld(true) 메서드를 호출한다.이 메서드는 지도 초기화가 완료된 후에 호출되는 onMapReady 메서드 안에서 호출한다.그리고 액티비티가 화면에 보이는 시점에서 다시 표시하고 화면이 사라지기 전에 없애고 싶다면 onResume과 onPause 메서드 안에서 각각 setMyLocationEnabled(ture)와 setMyLocationEnabled(false)를 호출한다.마커를 사용해 내 위치나 카페 위치 표시하기... 중략MarkerOptions myLocationMarker;... 중략private void showCurrentLocation(Location location){... 중략 showMyLocationMarker(curPoint);}private void showMyLocationMarker(LatLng curPoint) { if (myLocationMarker == null) { myLocationMarker = new MarkerOptions(); myLocationMarker.position(curPoint); myLocationMarker.title(&quot;● 내 위치\\n&quot;); myLocationMarker.snippet(&quot;● GPS로 확인한 위치&quot;); myLocationMarker.icon(BitmapDescriptorFactory.fromResource(R.drawable.mylocation)); map.addMarker(myLocationMarker); } else { myLocationMarker.position(curPoint); } } ... 중략참고로 /app/res/drawable 폴더에 mylocation 이미지 파일이 있어야 한다.결과전체 소스코드package org.techtown.location; import android.content.Context; import android.location.Location; import android.location.LocationListener; import android.location.LocationManager; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.Toast; import androidx.appcompat.app.AppCompatActivity; import com.google.android.gms.maps.CameraUpdateFactory; import com.google.android.gms.maps.GoogleMap; import com.google.android.gms.maps.MapsInitializer; import com.google.android.gms.maps.OnMapReadyCallback; import com.google.android.gms.maps.SupportMapFragment; import com.google.android.gms.maps.model.BitmapDescriptorFactory; import com.google.android.gms.maps.model.LatLng; import com.google.android.gms.maps.model.MarkerOptions; import com.yanzhenjie.permission.Action; import com.yanzhenjie.permission.AndPermission; import com.yanzhenjie.permission.runtime.Permission; import java.util.List; public class MainActivity extends AppCompatActivity { SupportMapFragment mapFragment; GoogleMap map; MarkerOptions myLocationMarker; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mapFragment = (SupportMapFragment) getSupportFragmentManager().findFragmentById(R.id.map); mapFragment.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(GoogleMap googleMap) { Log.d(&quot;Map&quot;, &quot;지도 준비됨.&quot;); map = googleMap; } }); mapFragment.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(GoogleMap googleMap) { Log.d(&quot;Map&quot;, &quot;GoogleMap is ready&quot;); map = googleMap; map.setMyLocationEnabled(true); } }); try { MapsInitializer.initialize(this); } catch (Exception e) { e.printStackTrace(); } Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { startLocationService(); } }); AndPermission.with(this) .runtime() .permission( Permission.ACCESS_FINE_LOCATION, Permission.ACCESS_COARSE_LOCATION) .onGranted(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;허용된 권한 갯수 : &quot; + permissions.size()); } }) .onDenied(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;거부된 권한 갯수 : &quot; + permissions.size()); } }) .start(); } public void showToast(String message) { Toast.makeText(this, message, Toast.LENGTH_LONG).show(); } public void onResume(){ super.onResume(); if(map != null) map.setMyLocationEnabled(true); // 액티비티가 화면에 보일 때 내 위치 표시 활성화 } public void onPause(){ super.onPause(); if(map != null) map.setMyLocationEnabled(false); // 액티비티가 중지될 때 내 위치 표시 비활성화 } public void startLocationService() { LocationManager manager = (LocationManager) getSystemService(Context.LOCATION_SERVICE); try { Location location = manager.getLastKnownLocation(LocationManager.GPS_PROVIDER); if (location != null) { double latitude = location.getLatitude(); double longitude = location.getLongitude(); String message = &quot;최근 위치 -&amp;gt; Latitude : &quot; + latitude + &quot;\\nLongitude:&quot; + longitude; Log.d(&quot;Map&quot;, message); } GPSListener gpsListener = new GPSListener(); long minTime = 10000; float minDistance = 0; manager.requestLocationUpdates( LocationManager.GPS_PROVIDER, minTime, minDistance, gpsListener); Toast.makeText(getApplicationContext(), &quot;내 위치확인 요청함&quot;, Toast.LENGTH_SHORT).show(); } catch(SecurityException e) { e.printStackTrace(); } } class GPSListener implements LocationListener { public void onLocationChanged(Location location) { Double latitude = location.getLatitude(); Double longitude = location.getLongitude(); String message = &quot;내 위치 -&amp;gt; Latitude : &quot;+ latitude + &quot;\\nLongitude:&quot;+ longitude; Log.d(&quot;Map&quot;, message); showCurrentLocation(latitude, longitude); } public void onProviderDisabled(String provider) { } public void onProviderEnabled(String provider) { } public void onStatusChanged(String provider, int status, Bundle extras) { } } private void showCurrentLocation(Double latitude, Double longitude) { LatLng curPoint = new LatLng(latitude, longitude); map.animateCamera(CameraUpdateFactory.newLatLngZoom(curPoint, 15)); showMyLocationMarker(curPoint); } private void showMyLocationMarker(LatLng curPoint) { if (myLocationMarker == null) { myLocationMarker = new MarkerOptions(); myLocationMarker.position(curPoint); myLocationMarker.title(&quot;● 내 위치\\n&quot;); myLocationMarker.snippet(&quot;● GPS로 확인한 위치&quot;); myLocationMarker.icon(BitmapDescriptorFactory.fromResource(R.drawable.mylocation)); map.addMarker(myLocationMarker); } else { myLocationMarker.position(curPoint); } } }" }, { "title": "현재 위치 지도 보여주기", "url": "/posts/ViewGps/", "categories": "Android, GPS", "tags": "android, location, gps", "date": "2022-02-03 17:36:00 +0900", "snippet": "현재 위치 지도 보여주기대부분 위치기반 서비스를 활용한 앱은 사용자가 현재 위치를 잘 볼 수 있도록 지도를 이용해 위치를 나타낸다.지도는 어떻게 보여주는 걸까?안드로이드에서는 앱 화면 안에 지도를 넣을 수 있도록 맵프래그먼트(MapFragment)가 제공된다.맵 프래그먼트는 새로운 방식의 구글맵 서비스 v2 기능을 사용할 수 있도록 추가된 기능으로 GooglePlay service 모듈을 사용한다.다음은 맵프래그먼트를 추가해서 지도를 보여줄 때 필요한 과정이다.Google Play service 라이브러리 사용 설정하기 구글맵 서비스 v2는 Play services 라이브러리를 사용한다. 따라서 구글 맵을 사용하려면 이 라이브러리를 추가해야 한다.XML 레이아웃에 맵프래그먼트 추가하기 앱 화면에 지도를 넣으려면 XML 레이아웃에 맵프래그먼트를 추가한다.소스 코드에서 내 위치로 지도 이동시키기 지도를 띄울 때 내 위치가 보여야 하므로 소스 코드에 지도를 내 위치에 맞추어 기능을 추가한다.매니페스트에 설정 추가하기’ 지도를 사용하려면 권한이 필요하다. 이 외에도 필요한 설정 정보를 매니페스트에 등록해야 한다.지도 API 키 구글맵 서비스를 사용하려면 구글 콘솔에서 지도 API 키를 발급 받아 앱의 매니페스트에 넣어주어야 한다.Google Play services 라이브러리 사용 설정하기예제MainActivity.javapackage org.techtown.location; import android.content.Context; import android.location.Location; import android.location.LocationListener; import android.location.LocationManager; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.Toast; import androidx.appcompat.app.AppCompatActivity; import com.google.android.gms.maps.CameraUpdateFactory; import com.google.android.gms.maps.GoogleMap; import com.google.android.gms.maps.MapsInitializer; import com.google.android.gms.maps.OnMapReadyCallback; import com.google.android.gms.maps.SupportMapFragment; import com.google.android.gms.maps.model.BitmapDescriptorFactory; import com.google.android.gms.maps.model.LatLng; import com.google.android.gms.maps.model.MarkerOptions; import com.yanzhenjie.permission.Action; import com.yanzhenjie.permission.AndPermission; import com.yanzhenjie.permission.runtime.Permission; import java.util.List; public class MainActivity extends AppCompatActivity { SupportMapFragment mapFragment; GoogleMap map; MarkerOptions myLocationMarker; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mapFragment = (SupportMapFragment) getSupportFragmentManager().findFragmentById(R.id.map); mapFragment.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(GoogleMap googleMap) { Log.d(&quot;Map&quot;, &quot;지도 준비됨.&quot;); map = googleMap; } }); try { MapsInitializer.initialize(this); } catch (Exception e) { e.printStackTrace(); } Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { startLocationService(); } }); AndPermission.with(this) .runtime() .permission( Permission.ACCESS_FINE_LOCATION, Permission.ACCESS_COARSE_LOCATION) .onGranted(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;허용된 권한 갯수 : &quot; + permissions.size()); } }) .onDenied(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;거부된 권한 갯수 : &quot; + permissions.size()); } }) .start(); } public void showToast(String message) { Toast.makeText(this, message, Toast.LENGTH_LONG).show(); } public void startLocationService() { LocationManager manager = (LocationManager) getSystemService(Context.LOCATION_SERVICE); try { Location location = manager.getLastKnownLocation(LocationManager.GPS_PROVIDER); if (location != null) { double latitude = location.getLatitude(); double longitude = location.getLongitude(); String message = &quot;최근 위치 -&amp;gt; Latitude : &quot; + latitude + &quot;\\nLongitude:&quot; + longitude; Log.d(&quot;Map&quot;, message); } GPSListener gpsListener = new GPSListener(); long minTime = 10000; float minDistance = 0; manager.requestLocationUpdates( LocationManager.GPS_PROVIDER, minTime, minDistance, gpsListener); Toast.makeText(getApplicationContext(), &quot;내 위치확인 요청함&quot;, Toast.LENGTH_SHORT).show(); } catch(SecurityException e) { e.printStackTrace(); } } class GPSListener implements LocationListener { public void onLocationChanged(Location location) { Double latitude = location.getLatitude(); Double longitude = location.getLongitude(); String message = &quot;내 위치 -&amp;gt; Latitude : &quot;+ latitude + &quot;\\nLongitude:&quot;+ longitude; Log.d(&quot;Map&quot;, message); showCurrentLocation(latitude, longitude); } public void onProviderDisabled(String provider) { } public void onProviderEnabled(String provider) { } public void onStatusChanged(String provider, int status, Bundle extras) { } } private void showCurrentLocation(Double latitude, Double longitude) { LatLng curPoint = new LatLng(latitude, longitude); map.animateCamera(CameraUpdateFactory.newLatLngZoom(curPoint, 15)); showMyLocationMarker(curPoint); } private void showMyLocationMarker(LatLng curPoint) { if (myLocationMarker == null) { myLocationMarker = new MarkerOptions(); myLocationMarker.position(curPoint); myLocationMarker.title(&quot;● 내 위치\\n&quot;); myLocationMarker.snippet(&quot;● GPS로 확인한 위치&quot;); myLocationMarker.icon(BitmapDescriptorFactory.fromResource(R.drawable.mylocation)); map.addMarker(myLocationMarker); } else { myLocationMarker.position(curPoint); } } }animateCamera 메서드는 지도의 축적 (Scale)을 지정할 수 있다.축적 값이 클수록 가까이서 본 것처럼 확대되는데 18 정도의 값은 도시 지역의 경우 건물 몇 개를 한눈에 볼 수 있을 정도로 확대하여 보여준다.AndroidManifet.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.location&quot;&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&amp;gt; &amp;lt;application android:usesCleartextTraffic=&quot;true&quot; android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.SampleLocationMap&quot;&amp;gt; &amp;lt;meta-data android:name=&quot;com.google.android.geo.API_KEY&quot; android:value=&quot;Input Your API Key&quot;/&amp;gt; &amp;lt;activity android:name=&quot;.MainActivity&quot;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt; &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;/activity&amp;gt; &amp;lt;/application&amp;gt; &amp;lt;/manifest&amp;gt;buld.gradle(Module:name) dependencies { implementation &#39;androidx.appcompat:appcompat:1.2.0&#39; implementation &#39;com.google.android.material:material:1.3.0&#39; implementation &#39;androidx.constraintlayout:constraintlayout:2.0.4&#39; implementation &#39;com.google.android.gms:play-services-maps:17.0.0&#39; testImplementation &#39;junit:junit:4.+&#39; androidTestImplementation &#39;androidx.test.ext:junit:1.1.2&#39; androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.3.0&#39; implementation &#39;com.yanzhenjie:permission:2.0.3&#39; }" }, { "title": "GPS로 내 위치 확인하기 ", "url": "/posts/CheckLocation/", "categories": "Android, GPS", "tags": "android, location, gps", "date": "2022-02-03 15:58:00 +0900", "snippet": "GPS로 나의 위치 확인하기앱에서 내 위치를 확인하고 싶다면 위치 관리자 (LocationManager)를 사용한다.나의 현재 위치를 확인하는 가장 기본적인 방법은 위치 관리자에게 위치 정보를 요청하는 것으로 다음과 같은 단계를 거쳐야 한다.1. 위치 관리자 객체 참조하기 위치 관리자는 시스템 서비스로 제공되므로, getSystemService 메서드를 이용해 위치 관리자 객체를 참조한다.2. 위치 리스너 구현하기 위치 관리자가 알려주는 현재 위치는 위치 리스너 (LocationListener)를 통해 받게 되므로 새로운 리스너를 구현하여 전달 받은 위치 정보를 처리한다.3.위치 정보 업데이트 요청하기 위치 관리자에게 위치 정보가 변결될 때 마다 알려달라고 요청하기 위해 requestLocationUpdates 메서드를 호출한다. 이 메서드의 매개 변수로 2단계에서 구현한 위치 리스너 객체를 전달한다.4. 매니페스트에 권한 추가하기 GPS를 사용할 수 있도록 매니페스트 파일에 ACCESS_FINE_LOCATION 권한ㅇ를 추가하고 위험 권한을 위한 설정과 코드를 추가한다.예제package org.techtown.location; import androidx.appcompat.app.AppCompatActivity; import android.content.Context; import android.location.Location; import android.location.LocationListener; import android.location.LocationManager; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; import android.widget.Toast; import java.util.List; public class MainActivity extends AppCompatActivity { TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { startLocationService(); } }); AndPermission.with(this) .runtime() .permission( Permission.ACCESS_FINE_LOCATION, Permission.ACCESS_COARSE_LOCATION) .onGranted(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;허용된 권한 갯수 : &quot; + permissions.size()); } }) .onDenied(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;거부된 권한 갯수 : &quot; + permissions.size()); } }) .start(); } public void startLocationService(){ // LocationManager 객체 참조하기 LocationManager manager = (LocationManager) getSystemService(Context.LOCATION_SERVICE); try{ // 이전에 확인했던 위치 가져오기 Location location = manager.getLastKnownLocation(LocationManager.GPS_PROVIDER); if(location != null){ double latitude = location.getLatitude(); double longitude = location.getLongitude(); String message = &quot;최근 위치 -&amp;gt; Latitude : &quot; + latitude + &quot;\\nLongitude&quot; + longitude; textView.setText(message); } GPSListener gpsListener = new GPSListener(); long minTime = 10000; float minDistance = 0; // 위치 요청하기 manager.requestLocationUpdates(LocationManager.GPS_PROVIDER, minTime, minDistance,gpsListener); Toast.makeText(getApplicationContext(), &quot;내 위치확인 요청함&quot;, Toast.LENGTH_SHORT).show(); }catch(SecurityException e){ e.printStackTrace(); } } class GPSListener implements LocationListener{ // 위치가 확인되었을 때 자동으로 호출되는 onLocatioChanged 메서드 @Override public void onLocationChanged(Location location){ Double latitude = location.getLatitude(); Double longitude = location.getLongitude(); String message = &quot;내 위치 -&amp;gt; Latitude : &quot; + latitude + &quot;\\nLongitude:&quot; + longitude; textView.setText(message); } @Override public void onProviderDisabled(String provider){} @Override public void onProviderEnabled(String provider){} @Override public void onStatusChanged(String provider, int status, Bundle extras){} } }최근 위치 정보를 확인하기 위해 사용되는 getLastKnownLocation 메서드에는 위치 정보를 제공하는 위치 제공자 정보를 매개 변수로 전달한다.안드로이드 위치 제공자는 크게 GPS_PROVIDER와 NERWORK_PROVIDER로 구분하고 있으며, 이 두 개의 값 중 하나를 매개 변수로 전달하면 Location 객체가 반환된다.Location 객체는 위도와 경도 값을 가지고 있으며, getLatitude와 getLongitude 메서드로 그 값을 확인할 수 있다.위치 리스너는 위치 관리자에서 전달하는 정보를 받기 위해 정의된 인터페이스이다.위치 관리자가 위치 정보를 전달할 때 호출되므로 위치 정보를 받아 처리하려면 위치 리스너의 onLocationChanged 메서드를 구현해야 한다.위치 관리자는 일정한 시간 간격으로 위치 정보를 확인하거나 일정 거리 이상을 이동 했을 때 위치 정보를 전달하는 기능을 제공한다.위치 관리자에게 현재 위치를 요청하기 위해서는 requestLocationUpdated 메서드를 호출해야하는데 매개 변수로는 최소 시간, 최소 거리, 위치 리스너객체가 전달 되어야 한다.getLastKnwonLocation 메서드는 권한이 필요하기 때문에 Manifest파일에 권한을 추가한다.AndroidManifest.xml&amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&amp;gt;그리고 외부 권한을 추가해주기 위해 의존성을 추가해준다.dependencies { ... implementation &#39;com.yanzhenjie:permission:2.0.3&#39; }결과애뮬레이터로 가상 위치 정보 전송하기에뮬레이터에서는 GPS 모듈을 사용할 수 없다.따라서 위치 정보를 가상으로 전달하는 방법을 사용해야 한다.에뮬레이터 오른쪽에 … 을 클릭한 후 location 탭에서 위치를 전송하면 된다." }, { "title": "자바 런타임 에러(IllegalArgumentException)", "url": "/posts/Java-IllegalArgumentException/", "categories": "삽질_일기", "tags": "git, runtime, IllegalArgumentException", "date": "2022-02-03 04:49:00 +0900", "snippet": "자바 런타임 에러(IllegalArgumentException)백준 문제 풀다 제출을 해보니 런타임 에러가 나왔다.eclips에서 돌렸을 때는 문제가 없었는데 …무슨 문제인가 보니 Compareable 값을 비교할 때 어떻게 정렬 할지 판단하기 모호하다는 뜻이다.문제의 코드 @Override public int compareTo(Jewel other) { return (other.price - this.price); }아래와 같이 &amp;lt;= 로 수정해주면 된다. @Override public int compareTo(Jewel other) { return (other.price &amp;gt;= this.price); }Compareable 쓸 때 조심해야 할듯 !" }, { "title": "유튜브 영상 재생하기", "url": "/posts/Youtube/", "categories": "Android, Multimedia", "tags": "android, viedio, youtube", "date": "2022-02-03 03:00:00 +0900", "snippet": "Youtube 영상 재생하기유튜브에 있는 동영상을 어떻게 하면 재생할 수 있을까?구글에서는 유튜브의 동영상을 재생할 수 있는 API를 제공한다.이 API를 이용하면 동영상 재생 및 녹화를 진행할 수 있다.예제API를 사용할 수 있도록 도와주는 jar 파일을 추가해야 하므로 [Project Files]로 변경한다.프로젝트 폴더 안에 있는 폴더와 파일이 파일 탐색기의 경로처럼 나타난다.jar 파일은 YouTube API를 제공하고 아래 사이트에서 다운로드 받을 수 있다.https://developers.google.com/youtube/android/player/downloads/ 압축을 풀면 libs 폴더 안에 jar 파일이 하나 들어 있는데 아래와 같이 복사해서 넣습니다.라이브러리 파일을 추가 했으니 의존성을 추가 해준다.build.gradle(Module: name)dependencies { implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])인제 YouTubePlayerVIew를 추가 해주기 위해 activity_main.xml 파일을 수정 해준다.activity_main.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;시작&quot; /&amp;gt; &amp;lt;com.google.android.youtube.player.YouTubePlayerView android:id =&quot;@+id/playerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt;YouTubePlayerVIew 초기화하고 버튼을 눌렀을 때 동작하게 해주기 위해 MainActivity.java 파일을 작성하자.MainActivity.javapackage org.techtown.youtube;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import com.google.android.youtube.player.YouTubeInitializationResult;import com.google.android.youtube.player.YouTubePlayer;import com.google.android.youtube.player.YouTubePlayerView;public class MainActivity extends YouTubeBaseActivity{ YouTubePlayerView playerView; YouTubePlayer player; private static String API_KEY = &quot;Input Your API KEY&quot;; private static String videoId = &quot;qVxTd_8jfNY&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initPlayer(); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View view){ playVideo(); } }); } public void initPlayer(){ playerView = findViewById(R.id.playerView); /* YouTubePlayerView 초기화 하기 */ playerView.initialize(API_KEY, new YouTubePlayer.OnInitializedListener(){ @Override public void onInitializationSuccess(YouTubePlayer.Provider provider, YouTubePlayer youTubePlayer, boolean b){ player = youTubePlayer; player.setPlayerStateChangeListener(new YouTubePlayer.PlayerStateChangeListener() { @Override public void onLoading() {} @Override public void onLoaded(String id) { Log.d(&quot;PlayerView&quot;, &quot;onLoaded 호출됨: &quot; + id ); player.play(); // 동영상이 로딩되었으면 재생하기 } @Override public void onAdStarted() {} @Override public void onVideoStarted() {} @Override public void onVideoEnded() {} @Override public void onError(YouTubePlayer.ErrorReason errorReason) {} }); } @Override public void onInitializationFailure(YouTubePlayer.Provider provider, YouTubeInitializationResult youTubeInitializationResult){} }); } public void playVideo(){ if(player != null){ if(player.isPlaying()) player.pause(); } player.cueVideo(videoId); }}액티비티는 YouTubeBaseActivity를 상속 받도록 한다.API_KEY는 https://console.developers.google.com/apis 에서 받을 수 있다.videold 변수에는 재생할 동영상의 id 값을 할당한다.동영상 id는 재생하고 싶은 동영상을 유튜브에서 찾아 사이트 주소에 포함되어 있는 id 값을 확인할 수 있다.initialize 메서드를 호출할때 첫 번째 매개 변수로 API 키값, 두 번째는 OnInitializationListener 객체를 전달한다.이 객체는 초기화가 성공적으로 수행되었을 때 onInitializationSuccess 메서드를 호출해준다.이 메서드가 호출되면 YouTubePlayer 객체가 전달되므로 객체를 변수에 할당해 준다.그리고 YouTubePlayer 객체의 setPlayerStateChangeListener 메서드를 호출하여 리스너 객체를 등록하면 Player 상태가 어떻게 바뀌는지 확인할 수 있다.onLoaded 메서드는 동영상이 로딩되었을 때 자동으로 호출되므로 그 안에서 Player 객체의 play 메서드를 호출한다.유튜브 동영상을 재생하기 위해서는 인터넷 권한이 필요하므로 아래와 같이 권한을 추가한다.AndroidManifeset.xml&amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&amp;gt; &amp;lt;queries&amp;gt; &amp;lt;intent&amp;gt; &amp;lt;action android:name=&quot;com.google.android.youtube.api.service.START&quot; /&amp;gt; &amp;lt;/intent&amp;gt; &amp;lt;/queries&amp;gt;&amp;lt;quries&amp;gt; 태그는 유튜브 라이브러리를 초기화하는데 필요하므로 추가 해주자.결과" }, { "title": "동영상 녹화하기", "url": "/posts/RecordVideo/", "categories": "Android, Multimedia", "tags": "android, viedio, record", "date": "2022-02-03 02:00:00 +0900", "snippet": "동영상 녹화하기오디오 녹음에 사용하는 MediaRecorder 객체는 동영상 녹화에도 그대로 이용할 수 있다.동영상 녹화가 오디오 녹음과 다른 점은 영상을 녹음하기 위한 입력 소스로 카메라를 지정하여 사용자가 카메라 미리 보기를 할 수 있도록 만들어 주어야 한다는 것이다.입력 소스로 지정할 수 있는 마이크는 MIC라는 상수로 정의되어 있고, 카메라는 CAMERA라는 상수로 정의되어 있다.APIMediaRecorder.AudioSource.MICMediaRecorder.VideoSource.CAMERA예제package org.techtown.video.recorder;import androidx.appcompat.app.AppCompatActivity;import android.content.ContentValues;import android.content.Intent;import android.media.MediaPlayer;import android.media.MediaRecorder;import android.net.Uri;import android.os.Bundle;import android.os.Environment;import android.provider.MediaStore;import android.util.Log;import android.view.SurfaceHolder;import android.view.SurfaceView;import android.view.View;import android.widget.Button;import android.widget.FrameLayout;import android.widget.Toast;import java.io.File;import java.util.List;public class MainActivity extends AppCompatActivity { MediaPlayer player; MediaRecorder recorder; File file; String filename; SurfaceHolder holder; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); SurfaceView surface = new SurfaceView(this); // SurfaceView 객체 만들기 holder = surface.getHolder(); FrameLayout frame = findViewById(R.id.container); frame.addView(surface); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ startRecording(); } }); Button button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { stopRecording(); } }); Button button3 = findViewById(R.id.button3); button3.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { startPlay(); } }); Button button4 = findViewById(R.id.button4); button4.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { stopPlay(); } }); file = getOutputFile(); if (file != null) { filename = file.getAbsolutePath(); } AndPermission.with(this) .runtime() .permission( Permission.CAMERA, Permission.RECORD_AUDIO, Permission.READ_EXTERNAL_STORAGE, Permission.WRITE_EXTERNAL_STORAGE) .onGranted(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;허용된 권한 갯수 : &quot; + permissions.size()); } }) .onDenied(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;거부된 권한 갯수 : &quot; + permissions.size()); } }) .start(); } public void showToast(String message) { Toast.makeText(this, message, Toast.LENGTH_LONG).show(); } public File getOutputFile() { File mediaFile = null; try { File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES), &quot;MyApp&quot;); if (!mediaStorageDir.exists()){ if (!mediaStorageDir.mkdirs()){ Log.d(&quot;MyCameraApp&quot;, &quot;failed to create directory&quot;); return null; } } mediaFile = new File(mediaStorageDir.getPath() + File.separator + &quot;recorded.mp4&quot;); } catch(Exception e) { e.printStackTrace(); } return mediaFile; } public void startRecording(){ if(recorder == null) recorder = new MediaRecorder(); recorder.setAudioSource(MediaRecorder.AudioSource.MIC); recorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); recorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4); recorder.setAudioEncoder(MediaRecorder.AudioEncoder.DEFAULT); recorder.setOutputFile(filename); // MediaRecorder에 미리보기 화면을 보여줄 객체 설정하기 recorder.setPreviewDisplay(holder.getSurface()); try{ recorder.prepare(); recorder.start(); }catch(Exception e){ e.printStackTrace(); recorder.release(); recorder = null; } } public void stopRecording(){ if (recorder == null) return; recorder.stop(); recorder.reset(); recorder.release(); recorder = null; ContentValues values = new ContentValues(10); values.put(MediaStore.MediaColumns.TITLE, &quot;RecordedVideo&quot;); values.put(MediaStore.Audio.Media.ALBUM, &quot;Video Album&quot;); values.put(MediaStore.Audio.Media.ARTIST, &quot;Mike&quot;); values.put(MediaStore.Audio.Media.DISPLAY_NAME, &quot;Recorded Video&quot;); values.put(MediaStore.MediaColumns.DATE_ADDED, System.currentTimeMillis() / 1000); values.put(MediaStore.MediaColumns.MIME_TYPE, &quot;video/mp4&quot;); values.put(MediaStore.Audio.Media.DATA, filename); Uri videoUri = getContentResolver().insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, values); if(videoUri == null){ Log.d(&quot;SampleVideoRecorder&quot;, &quot;Video insert failed&quot;); return; } sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, videoUri)); } public void startPlay() { if (player == null) { player = new MediaPlayer(); } try { player.setDataSource(filename); player.setDisplay(holder); player.prepare(); player.start(); } catch (Exception e) { e.printStackTrace(); } } public void stopPlay() { if (player == null) { return; } player.stop(); player.release(); player = null; }}미디어 앨범에 녹화된 동영상을 저장하고 싶을 때는 오디오의 경우처럼 내용 제공자를 사용하면 된다.이때 미디어 앨범에 저장되었다는 정보를 다른 앱에도 알려주고 싶다면 Intent.ACTION_MEDIA_SCANNER_SCAN_FILE 액션을 이용해 새로 만들어진 URI 객체를 브로드 캐스팅하면 된다.접근 권한 추가AndroidManifest.xml&amp;lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&amp;gt;외부 라이브러리 추가build.gradle:appdependencies { ... implementation &#39;com.yanzhenjie:permission:2.0.3&#39; }결과" }, { "title": "오디오 녹음하여 저장하기", "url": "/posts/RecordAudio/", "categories": "Android, Multimedia", "tags": "android, audio, record", "date": "2022-02-03 01:31:00 +0900", "snippet": "오디오 녹음하여 저장하기오디오나 동영상을 재생할 때 미디어 플레이어가 사용되는 것처럼 오디오 녹음이나 동영상 녹화를 위해서는 미디어리코더(MediaRecorder) 가 사용된다.아래와 같은 과정을 거쳐 음성 녹음을 할 수 있다. 구분 설명 1. 미디어 리코더 객체 생성 new 연산자를 이용하여 만든다. 2. 오디오 입력 및 출력 형식 설정 오디오 정보를 입력받을 데이터 소스와 함께 출력 형식을 설정한다. 3. 오디오 인코더와 파일 지정 오디오 파일을 만들 때 필요한 인코더(Encorder)와 함께 파일 이름을 지정 4. 녹음 시작 녹음을 시작하면 오디오 파일이 만들어지고 인코딩된 바이트 스트림이 저장됨 5. 매니페스트 권한 설정 RECORDE_AUDIO 권한이 있어야 하므로 권한을 추가해준다. 예제MainActivity.javapackage org.techtown.myapplication;import android.content.ContentValues;import android.media.MediaPlayer;import android.media.MediaRecorder;import android.net.Uri;import android.os.Bundle;import android.os.Environment;import android.provider.MediaStore;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;import com.yanzhenjie.permission.Action;import com.yanzhenjie.permission.AndPermission;import com.yanzhenjie.permission.runtime.Permission;import java.io.File;import java.util.List;public class MainActivity extends AppCompatActivity { MediaRecorder recorder; MediaPlayer player; File file; String filename; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = findViewById(R.id.button2); button.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ startRecording(); } }); Button button2 = findViewById(R.id.button3); button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { stopRecording(); } }); Button button3 = findViewById(R.id.button4); button3.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { startPlay(); } }); Button button4 = findViewById(R.id.button5); button4.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { stopPlay(); } }); file = getOutputFile(); if (file != null) { filename = file.getAbsolutePath(); } AndPermission.with(this) .runtime() .permission( Permission.RECORD_AUDIO, Permission.READ_EXTERNAL_STORAGE, Permission.WRITE_EXTERNAL_STORAGE) .onGranted(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;허용된 권한 갯수 : &quot; + permissions.size()); } }) .onDenied(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;거부된 권한 갯수 : &quot; + permissions.size()); } }) .start(); } public void showToast(String message) { Toast.makeText(this, message, Toast.LENGTH_LONG).show(); } public File getOutputFile() { File mediaFile = null; try { File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES), &quot;MyApp&quot;); if (!mediaStorageDir.exists()){ if (!mediaStorageDir.mkdirs()){ Log.d(&quot;MyCameraApp&quot;, &quot;failed to create directory&quot;); return null; } } mediaFile = new File(mediaStorageDir.getPath() + File.separator + &quot;recorded.mp4&quot;); } catch(Exception e) { e.printStackTrace(); } return mediaFile; } public void startRecording(){ if(recorder == null){ recorder = new MediaRecorder(); } /* MediaRecorder 설정하기 */ recorder.setAudioSource(MediaRecorder.AudioSource.MIC); // 마이크로 입력 받기 recorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4); // MPEG4 포맷으로 지정 recorder.setAudioEncoder(MediaRecorder.AudioEncoder.DEFAULT); // 디폴트 인코터 사용 recorder.setOutputFile(filename); // 결과물 파일을 설정하는데 사용 try{ /* MediaRecorder 시작하기 */ recorder.prepare(); recorder.start(); } catch(Exception e){ e.printStackTrace(); } } public void stopRecording() { if (recorder == null) { return; } recorder.stop(); recorder.release(); // 리소스 해제하는 역할 recorder = null; // 내용 제공자에 새로운 값을 추가하기 위해 CotentValue 객체에 필요한 정보를 put ContentValues values = new ContentValues(10); values.put(MediaStore.MediaColumns.TITLE, &quot;Recorded&quot;); values.put(MediaStore.Audio.Media.ALBUM, &quot;Audio Album&quot;); values.put(MediaStore.Audio.Media.ARTIST, &quot;Mike&quot;); values.put(MediaStore.Audio.Media.DISPLAY_NAME, &quot;Recorded Audio&quot;); values.put(MediaStore.Audio.Media.IS_RINGTONE, 1); values.put(MediaStore.Audio.Media.IS_MUSIC, 1); values.put(MediaStore.MediaColumns.DATE_ADDED, System.currentTimeMillis()/1000); values.put(MediaStore.MediaColumns.MIME_TYPE, &quot;audio/mp4&quot;); values.put(MediaStore.Audio.Media.DATA, filename); // ContentValues를 내용 제공자에 넣어준다. Uri audioUri = getContentResolver().insert(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, values); if (audioUri == null) { Log.d(&quot;SampleAudioRecorder&quot;, &quot;Audio insert failed.&quot;); return; } } public void startPlay() { killMediaPlayer(); try { player = new MediaPlayer(); player.setDataSource(filename); player.prepare(); player.start(); } catch(Exception e) { e.printStackTrace(); } } public void stopPlay() { if (player != null) { player.stop(); } } private void killMediaPlayer() { if (player != null) { try { player.release(); } catch (Exception e) { e.printStackTrace(); } } }}권한 추가 &amp;lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&amp;gt; &amp;lt;application android:requestLegacyExternalStorage=&quot;true&quot;결과" }, { "title": "동영상 재생하기", "url": "/posts/PlayVideo/", "categories": "Android, Multimedia", "tags": "android, video", "date": "2022-02-02 20:30:00 +0900", "snippet": "동영상 재생하기동영상을 재생하고 싶으면 Video View 위젯을 사용하면 되는데 XML 레이아웃에 &amp;lt;Video View&amp;gt; 태그를 추가하기만 하면 동영상 플레이어를 바로 만들 수 있다. 동영상 화면에 디스플레이 되는 영역이 있으므로 위젯으로 XML 레이아웃에 추가할 수 있다. XML 레이아웃에 태그를 추가하고 한두줄의 코드만 구현하면 동영상을 재생할 수 있다.예제위 처럼 VideoView를 추가 해준다.그 다음 레이아웃에 추가한 비디오 뷰 객체를 자바 코드에서 참조한 후 동영상 파일의 위치를 setVideoURI 메서드로 지정하기만 하면 동영상을 재생할 수 있다.동영상의 상태를 보거나 동영상을 제어할 때 사용되는 미디어 컨트롤러 객체는 setMediaController 메서드로 설정할 수 있는데 손가락으로 터치하면 컨트롤러 부분을 보여주게 된다.이 컨트롤러로 비디오 재생 상태를 확인할 수 있다.비디오 뷰 객체에는 getDuration 이나 pause와 같이 동영상을 제어하는데 필요한 다른 메서드들로 정의되어 있다.이제 버튼을 클릭했을때 동작하는 코드를 작성해보자.MainActivity.javapublic class MainActivity extends AppCompatActivity { public static final String VIDEO_URL = &quot;https://sites.google.com/site/ubiaccessmobile/sample_video.mp4&quot;; VideoView videoView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); videoView = findViewById(R.id.videoView); MediaController mc = new MediaController(this); videoView.setMediaController(mc); // Video View에 MediaController 설정하기 Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ videoView.setVideoURI(Uri.parse(VIDEO_URL)); // VideoView에 재생할 대상 설정하고 재생 시작 videoView.requestFocus(); videoView.start(); } }); } }이 앱도 인터넷에서 파일을 받아 오기 때문에 INTERNET 권한이 필요하다.AndroidManifest.xml 파일을 열고 INTERNET 권한을 추가한 후&amp;lt;application&amp;gt; 태그에 속성을 하나 더 추가한다.AndroidManifest.xml&amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&amp;gt; &amp;lt;application android:usesCleartextTraffic=&quot;true&quot;결과동영상을 좀 더 세밀하게 제어하고 싶을때는 미디어 플레이어 객체를 사용하면 된다." }, { "title": "음악 파일 재생하기", "url": "/posts/PlayMusic/", "categories": "Android, Multimedia", "tags": "android, music", "date": "2022-02-02 19:56:00 +0900", "snippet": "음악 파일 재생하기멀티미디어를 위해 제공하는 미디어 API는 android.media 패키지에 들어 있다.그 안의 클래스들 중에서 핵심이 되는 것은 MediaPlayer 클래스이다.미디어 플레이어 클래스는 음악 파일과 같은 오디오의 재생은 물론 동영상 재생까지 담당한다.출시되는 단말에 따라 지원하는 음성/영상 코덱이 다르므로 재생할 수 있는 파일의 종류가 다를 수 있다. 하지만 기본적으로 제공되는 코덱만으로도 오디오와 동영상 재생을 할 수 있다.오디오 파일을 재생하려면 대상을 지정해야 하는데 이때 사용되는 데이터 소스 지정 방법은 크게 세가지로 나눌 수 있다. 구분 설명 인터넷에 있는 파일 위치 지정 미디어가 있는 위치를 URL로 지정한다. 프로젝트 파일에 포함한 후 위치 지정 앱을 개발하여 배포하는 과정에서 프로젝트의 리소스 또는 애셋 폴더에 넣은 후 그 위치를 지정한다. 단말 SD 카드에 넣은 후 위치 지정 단말에 넣어 둔 SD 카드에 파일을 넣은 후 그 위치를 지정한다. 미디어플레이어로 음악 파일을 재생하는 과정은 다음 그림처럼 세 단계로 나눌 수 있다.1.setDataSource 메서드로 URL을 지정한다. prepare 메서드를 호출하여 재생을 준비한다. start 메서드를 호출하여 음악 파일을 재생한다.예제public class MainActivity extends AppCompatActivity { public static final String AUDIO_URL = &quot;https://sites.google.com/site/ubiaccessmobile/sample_audio.mp3&quot;;; MediaPlayer mediaPlayer; int position = 0; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ playAudio(AUDIO_URL); Toast.makeText(getApplicationContext(), &quot;음악 파일 재생 시작됨.&quot;,Toast.LENGTH_LONG).show(); } }); Button button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view){ if(mediaPlayer != null){ mediaPlayer.stop(); Toast.makeText(getApplicationContext(), &quot;음악 파일 재생 중지됨.&quot;, Toast.LENGTH_LONG).show(); } } }); Button button3 = findViewById(R.id.button3); button3.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View view){ if(mediaPlayer != null){ position = mediaPlayer.getCurrentPosition(); mediaPlayer.pause(); Toast.makeText(getApplicationContext(), &quot;음악 파일 재생 일시 정지됨.&quot;, Toast.LENGTH_LONG).show(); } } }); Button button4 = findViewById(R.id.button4); button4.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View view){ if(mediaPlayer != null &amp;amp;&amp;amp; !mediaPlayer.isPlaying()){ mediaPlayer.start(); mediaPlayer.seekTo(position); Toast.makeText(getApplicationContext(),&quot;음악 파일 재생 재시작됨.&quot;, Toast.LENGTH_LONG).show(); } } }); } private void playAudio(String url){ killMediaPlayer(); try{ /* MediaPlayer 객체 만들어 시작하기 */ mediaPlayer = new MediaPlayer(); mediaPlayer.setDataSource(url); mediaPlayer.prepare(); mediaPlayer.start(); }catch(Exception e){ e.printStackTrace(); } } protected void onDestroy(){ super.onDestroy(); killMediaPlayer(); } private void killMediaPlayer(){ if (mediaPlayer != null){ try{ /* MediaPlayer 객체의 리소스 해체하기 */ mediaPlayer.release(); }catch(Exception e){ e.printStackTrace(); } } } }MediaPlayer 객체를 이용해 음악을 재생하는 playAudio 메서드의 구조를 보면 killMediaPlayer 메서드를 호출한 후 차례로 setDataSource, prepare, start 메서드를 호출하고 있다.killMediaPlayer 메서드는 미디어플레이어 객체가 이미 리소스를 사용하고 있을 경우에 release 메서드를 호출하여 리소스 해체하는 역할을 한다.이렇게 하는 이유는 미디어 플레이어를 앱 내에서 재사용하려면 기존에 사용하던 리소스를 먼저 해제 해주어야 한다.재생을 중지하고 다시 시작하기 위해서는 중지한 지점의 위치를 알아야 하므로 일시정지 버튼을 눌렀을 때는 getCurrentPosition 메서드를 이용해 현 지점의 위치를 알아오고 재시작 버튼을 눌렀을 때는 seekTo 메서드로 중지 했을 때의 지점에서부터 재생하도록 만든다.위의 예제는 인터넷의 다른 서버에 미리 올려둔 음악 파일을 사용하고 있다.인터넷을 사용하기 때문에 INTERNET 권한이 필요하다.따라서 AndroidManifest.xml` 파일을 열고 다음과 같이 INTERNET 권한을 추가한다.그리고 &amp;lt;application&amp;gt; 태그에 속성을 하나 더 추가한다.AndroidManifest.xml&amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&amp;gt; &amp;lt;application android:usesCleartextTraffic=&quot;true&quot;결과미디어 플레이어의 stop 메서드로 재생을 중지했을 때 또 다른 작업을 수행하고 싶다면 MediaPlayer.OnCompletionListener 를 구현한 후 미디어 플레이어 객체에 등록하면 된다.재생이 중지되었을 때 호출되는 메서드는 다음과 같다.APIpublic abstarct void onCompletoin (MediaPlayer mp)" }, { "title": "카메라에 미리보기 넣기", "url": "/posts/CameraPreview/", "categories": "Android, Multimedia", "tags": "android, camera, preview", "date": "2022-02-02 18:55:00 +0900", "snippet": "카메라에 미리보기 넣기카메라 미리보기 화면에 증강 현실을 표현할 아이콘이나 그래픽 등을 보여주고 싶다면 어떻게 해야할까?우리가 만든 앱에 카메라 미리보가와 사진찍기 기능을 넣을 수 있지만 코드는 좀 더 많이지고 서피스(Surface View) 라는 것으로 미리보기 화면이 구현되기 때문에 서피스 뷰가 무엇인지 이해해야 한다.카메라 미리보기 기능을 구현 하려면 일반 뷰(View)가 아니라 서피스 뷰를 사용해야 한다.서피스 뷰는 서피스홀더에 의해 제어 된다.만약 카메라 객체를 만든 후 미리보기 화면을 서피스 뷰에 보여주고 싶다면 서피스 홀더 객체의 setPreviewDisplay 메서드로 미리 보기를 설정해 주어야 한다.APIpublic void setPreviewDisplay (Surface sv)필요한 초기화 작업이 끝나면 카메라 객체의 startPreview 메서드를 호출할 수 있으며,이때부터 입력된 영상을 서피스 뷰로 화면을 보여주게 된다.예제activity_main,xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;사진 찍기&quot; /&amp;gt; &amp;lt;FrameLayout android:id=&quot;@+id/previewFrame&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;/FrameLayout&amp;gt; &amp;lt;/LinearLayout&amp;gt;카메라 미리보기 화면을 FrameLayout안에 추가하기 위해 소스코드에서 CameraSufaceView라는 새로운 클래스를 MainActivity 클래스 안에 내부 클래스로 정의하고 그 클래스의 인스턴스 객체를 만들어 추가하자.우선 CameraSurfaceVIew 클래스가 있다고 가정하고 메인 액티비트 코드를 작성해보자.MainActivity.javapublic class MainActivity extends AppCompatActivity { CameraSurfaceView cameraView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FrameLayout previewFrame = findViewById(R.id.previewFrame); cameraView = new CameraSurfaceView(this); previewFrame.addView(cameraView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { public void onClick(View v){ takePicture(); } }); } public void takePicture(){ /* CameraSurfaceView의 capture 메서드 호출하기 */ cameraView.capture(new Camera().PictureCallback() { try { /* 전달 받은 바이트 배열을 Bitmap 객체로 만들기 */ Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length); String outUriStr = MediaStore.Images.Media.insertImage( getContentResolver(), bitmap, &quot;Caputred Image&quot;, &quot;Caputred Image using Camera.&quot;); if (outUriStr == null) { Log.d(&quot;SampleCapture&quot;, &quot;Image insert failed.&quot;); return; } else { Uri outUri = Uri.parse(outUriStr); sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, outUri)); } camera.startPreview(); } catch (Exception e) { e.printStackTrace(); } }); } }카메라 미리보기를 구현하는 CameraSurfaceView는 SurfaceView를 상속받아 새로 정의한 후 XML 레이아웃에 정의된 FameLayout에 추가한다.사진 찍기 버튼을 누르면 사진을 한장 찍어 미디어 앨범에 추가하게 되는데 사진을 찍은 결과를 처리하는 코드는 PictureCallback 인터페이스를 구현하는 부분에 들어 있다.APIpublic abstarct void onPictureTaken (byte[] data, Camera camera)즉, 사진을 찍을 때 자동으로 호출되는 onPictureTaken 메서드로 캡쳐한 이미지 데이터가 전달된다.그런 다음 데이터 비트맵으로 만들고 MediaStore.Images.Media에 정의된 insertImage 메서드를 이용하여 미디어 앨범에 추가한다.이미지 데이터를 비트맵으로 만들기 위해서는 BitmapFactory 클래스에 정의된 decodebyteArray 메서드를 이용한다.insertImage 메서드는 간단한 방법으로 이미지를 추가할 수 있도록 정의된 메서드이다.자세히 봐보자.APIpublic static final String insertImage(ContentResolver cr, Bitmap source, String title,String description)다음은 서피스 뷰를 확장하여 정의한 CameraSurfaceView 클래스이다.이 클래스는 SurfaceHolder에 정의된 Callback 인터페이스를 구현하고 있으므로 서피스 뷰의 상태가 변경될 때 자동으로 호출되는 세가지 메서드 (surfaceCreate, surfaveChanged, surfaceDestoryed)가 구현되어 있다.이 클래스는 MainActivity.java 클래스 안에 내부 클래스로 정의 한다.CameraSurfaceView.javapublic class MainActivity extends AppCompatActivity { CameraSurfaceView cameraView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FrameLayout previewFrame = findViewById(R.id.previewFrame); cameraView = new CameraSurfaceView(this); previewFrame.addView(cameraView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { public void onClick(View v) { takePicture(); } }); AndPermission.with(this) .runtime() .permission( Permission.CAMERA, Permission.READ_EXTERNAL_STORAGE, Permission.WRITE_EXTERNAL_STORAGE) .onGranted(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;허용된 권한 갯수 : &quot; + permissions.size()); } }) .onDenied(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;거부된 권한 갯수 : &quot; + permissions.size()); } }) .start(); } public void showToast(String message) { Toast.makeText(this, message, Toast.LENGTH_LONG).show(); } public void takePicture() { cameraView.capture(new Camera.PictureCallback() { public void onPictureTaken(byte[] data, Camera camera) { try { Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length); String outUriStr = MediaStore.Images.Media.insertImage( getContentResolver(), bitmap, &quot;Captured Image&quot;, &quot;Captured Image using Camera.&quot;); if (outUriStr == null) { Log.d(&quot;SampleCapture&quot;, &quot;Image insert failed.&quot;); return; } else { Uri outUri = Uri.parse(outUriStr); sendBroadcast(new Intent( Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, outUri)); } camera.startPreview(); } catch (Exception e) { e.printStackTrace(); } } }); } private class CameraSurfaceView extends SurfaceView implements SurfaceHolder.Callback { private SurfaceHolder mHolder; private Camera camera = null; public CameraSurfaceView(Context context) { super(context); mHolder = getHolder(); mHolder.addCallback(this); } public void getCameraInstance(){ try { camera = Camera.open(); } catch (Exception e){ showToast(&quot;카메라가 다른 앱에서 사용중입니다.&quot;); } } public void surfaceCreated(SurfaceHolder holder) { getCameraInstance(); setCameraOrientation(); try { camera.setPreviewDisplay(mHolder); } catch (Exception e) { e.printStackTrace(); } } public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) { try { camera.startPreview(); } catch (Exception e) { e.printStackTrace(); } } public void surfaceDestroyed(SurfaceHolder holder) { try { camera.stopPreview(); camera.release(); camera = null; } catch (Exception e) { e.printStackTrace(); } } public boolean capture(Camera.PictureCallback handler) { if (camera != null) { camera.takePicture(null, null, handler); return true; } else { return false; } } public void setCameraOrientation() { if (camera == null) { return; } Camera.CameraInfo info = new Camera.CameraInfo(); Camera.getCameraInfo(0, info); WindowManager manager = (WindowManager) getSystemService(Context.WINDOW_SERVICE); int rotation = manager.getDefaultDisplay().getRotation(); int degrees = 0; switch (rotation) { case Surface.ROTATION_0: degrees = 0; break; case Surface.ROTATION_90: degrees = 90; break; case Surface.ROTATION_180: degrees = 180; break; case Surface.ROTATION_270: degrees = 270; break; } int result; if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) { result = (info.orientation + degrees) % 360; result = (360 - result) % 360; } else { result = (info.orientation - degrees + 360) % 360; } camera.setDisplayOrientation(result); } } }서피스 뷰가 만들어지면서 호출되는 surfaceCreated 메서드 안에서는 Camera.open 메서드를 이용해 카메라를 오픈하고 이를 통해 참조한 카메라 객체에 서피스 홀더 객체를 지정해야 한다.카메라 객체에 서피스홀더 객체를 지정하기 위해 setPreviewDisplay 메서드를 사용한다.서피스뷰의 크기가 변경되거나 할 때 호출되는 surfaceChanged 메서드 안에서는 startPreview 메서드를 이용해 미리보기를 시작한다.서피스 뷰의 리소스를 해체하면서 호출되는 surfaceDestroyed 메서드 안에서는 카메라 객체의 stopPreview 메서드를 호출하여 미리보기를 끝낸 후 변수를 NULL 값으로 지정한다.버튼을 클릭했을 때 사진을 찍기 위해 호출하는 caputre 메서드 안을 보면 카메라 객체의 takePicture 메서드를 호출하여 사진을 찍고 있으며, 이때 PictureCallback 인터페이스를 구현한 객체를 매개변수로 전달함으로써 사진을 찍었을 때 이 객체의 onPictureTaken 메서드가 자동으로 호출되도록 한다.우리가 만드는 앱은 Camera와 SD 카드를 접근하므로 이 권한을 매니페스트에 추가하고 위험권한에 대한 권한 부여를 요청하는 코드를 추가해야 한다.먼저 AndroidManifest.xml 파일을 열고 다음과 같이 권한을 추가한다.&amp;lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&amp;gt; &amp;lt;uses-feature android:name=&quot;android.hardware.camera&quot; /&amp;gt;이 권한들은 위험 권한으로 분류 되어 있으므로 자동으로 위험 권한을 부여를 위한 대화상자를 보여주는 코드를 추가한다.build.gradle(Module: SampleCaputre.app 파일을 열고 자동으로 위험 권한을 부여하기 위한 외부 라이브러리를 추가한다.dependencies { ... implementation &#39;com.yanzhenjie:permission:2.0.3&#39; }카메라 미리보기의 화면이 세로모드로 보이도록 하고 싶다면 MainActivity 클래스의 내부 클래스로 정의한 CameraSurfaceView 클래스 안의 surfaceCreated 메서드를 수정한다.public void surfaceCreated(SurfaceHolder holder) { camera = Camera.open(); setCameraOrientation(); try { camera.setPreviewDisplay(mHolder); } catch (Exception e) { e.printStackTrace(); } }public void setCameraOrientation() { if (camera == null) { return; } Camera.CameraInfo info = new Camera.CameraInfo(); Camera.getCameraInfo(0, info); WindowManager manager = (WindowManager) getSystemService(Context.WINDOW_SERVICE); int rotation = manager.getDefaultDisplay().getRotation(); int degrees = 0; switch (rotation) { case Surface.ROTATION_0: degrees = 0; break; case Surface.ROTATION_90: degrees = 90; break; case Surface.ROTATION_180: degrees = 180; break; case Surface.ROTATION_270: degrees = 270; break; } int result; if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) { result = (info.orientation + degrees) % 360; result = (360 - result) % 360; } else { result = (info.orientation - degrees + 360) % 360; } camera.setDisplayOrientation(result); }setCameraOrientation 메서드는 onSurfaceCreated 메서드 안에서 호출되는 메서드이며 카메라 미리 보기 방향을 설정한다." }, { "title": "백준 바이러스(2606)", "url": "/posts/back-2606/", "categories": "PS, DFS-BFS", "tags": "backjoon, DFS, BFS, silver3", "date": "2022-02-02 05:23:00 +0900", "snippet": "백준 바이러스(2606)풀이bfs, dfs 구현만 해주면 되는 문제 bfs (너비 우선 탐색)을 통해 연결된 노드의 수 세주기 dfs (깊이 우선 탐색)을 통해 연결된 노드의 수 세주기아래 풀이는 bfs 방식으로 작성했습니다.import java.util.*;import java.io.*;class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); }}public class Main{ static int n; static int m; static boolean visited[]; static int count; static ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; computer; public static void main(String[] args)throws Exception{ FastScanner sc=new FastScanner(); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); // 노드의 수, 정점의 n = sc.nextInt()+1; m = sc.nextInt()+1; computer = new ArrayList&amp;lt;&amp;gt;(); for(int i=0; i&amp;lt;n; i++) computer.add(new ArrayList&amp;lt;Integer&amp;gt;()); // 양 방향 연결 for(int i=0; i&amp;lt;m-1; i++) { int v1 = sc.nextInt(); int v2 = sc.nextInt(); computer.get(v1).add(v2); computer.get(v2).add(v1); } bfs(); bw.write(Integer.toString(count)); bw.close(); } public static void bfs() { Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); visited = new boolean[n]; queue.add(1); visited[1] = true; while (!queue.isEmpty()) { int tmp = queue.poll(); Iterator&amp;lt;Integer&amp;gt; it = computer.get(tmp).iterator(); while (it.hasNext()) { int i = it.next(); if (!visited[i]) { queue.add(i); visited[i] = true; count ++; } } } }}" }, { "title": "백준 보석도둑 (1202)", "url": "/posts/back-1202/", "categories": "PS, Greedy", "tags": "backjoon, greedy, gold2", "date": "2022-02-02 04:43:00 +0900", "snippet": "백준 보석도둑 (1202) 가방의 무게가 낮은 순으로 정렬 보석의 무게가 낮은 순으로 정렬 가방에 담을 수 있는 보석들을 우선순위 큐에 집어 넣는다 (보석 가격 높은 순) 가방을 다 사용했으면 가방의 수 만큼 보석을 꺼내서 더해준다.import java.io.*;import java.util.*;class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); }}class Jewel implements Comparable&amp;lt;Jewel&amp;gt;{ int weight; int price; public Jewel(int weight, int price) { this.weight = weight; this.price = price;; } @Override public int compareTo(Jewel other) { return this.weight - other.weight; }}public class Main { public static void main(String[] args) throws NumberFormatException, IOException { FastScanner sc = new FastScanner(); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int jewel_num = sc.nextInt(); int bag_num = sc.nextInt(); Jewel [] jewel = new Jewel[jewel_num]; int [] bag = new int[bag_num]; for(int i=0; i&amp;lt;jewel_num; i++) jewel[i] = new Jewel(sc.nextInt(), sc.nextInt()); for(int i=0; i&amp;lt;bag_num; i++) bag[i] = sc.nextInt(); // 내림차순 Arrays.sort(jewel); Arrays.sort(bag); // 높은 숫자 우선순위 Queue&amp;lt;Integer&amp;gt; queue = new PriorityQueue&amp;lt;&amp;gt;(Collections.reverseOrder()); // 가방의 무게보다 같거나 작은 보석들을 담기 위한 큐 long sum = 0; int idx = 0; for(int weight : bag) { for(; idx &amp;lt; jewel_num; ) { if(weight &amp;gt;= jewel[idx].weight) queue.add(jewel[idx++].price); else break; } if(!queue.isEmpty()) // 가방의 무게보다 더 무거운 보석들만 있는지 체크 sum+= queue.poll(); // 넣을때 큰 가격부터 꺼내기 위해 음수로 넣는다. } bw.write(Long.toString(sum)); bw.close(); } }" }, { "title": "백준 배 (1092)", "url": "/posts/back-1092/", "categories": "PS, Greedy", "tags": "backjoon, greedy, gold5", "date": "2022-02-02 02:49:00 +0900", "snippet": "백준 배 (1092)import java.io.*;import java.util.*;public class Main { public static void main(String[] args) throws NumberFormatException, IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int craneSize = Integer.parseInt(br.readLine()); int crane[] = new int[craneSize]; StringTokenizer st = new StringTokenizer(br.readLine()); /* 크레인이 옮길 수 있는 무게 제한 입력 받기 */ for(int i=0; i&amp;lt;craneSize; i++) crane[i]= Integer.parseInt(st.nextToken()); /* 크레인이 옮길 수 있는 무게제한 오름차순 정렬 */ Arrays.sort(crane); int boxSize = Integer.parseInt(br.readLine()); Integer box[] = new Integer[boxSize]; /* 상자의 무게 입력 받기 */ st = new StringTokenizer(br.readLine()); for(int i=0; i&amp;lt;boxSize; i++) box[i] = Integer.parseInt(st.nextToken()); /* 상자의 무게 오름차순 정렬 */ Arrays.sort(box); if(box[boxSize - 1] &amp;gt; crane[craneSize - 1]) { bw.write(&quot;-1&quot;); bw.close(); return; } int moveable = 0; /* 상자를 옮길 수 있는 크레인의 수 구하기 */ for(int limit : crane){ if(box[0]&amp;lt;= limit) moveable ++; } int ans = (boxSize % moveable == 0) ? (boxSize / moveable) : (boxSize / moveable) +1; bw.write(Integer.toString(ans)); bw.close(); } }예제 입력 1~4의 출력은 다 맞았는데 제출해보니 틀렸다고 나온다.31 1 251 1 2 2 2출력: 3만약에 위 처럼 중복 값들이 있으면 3이 나와야 하는데 계속 2가 나왔다.수정후import java.io.*;import java.util.*;public class Main { public static void main(String[] args) throws NumberFormatException, IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int craneSize = Integer.parseInt(br.readLine()); int crane[] = new int[craneSize]; StringTokenizer st = new StringTokenizer(br.readLine()); /* 크레인이 옮길 수 있는 무게 제한 입력 받기 */ for(int i=0; i&amp;lt;craneSize; i++) crane[i]= Integer.parseInt(st.nextToken()); int boxSize = Integer.parseInt(br.readLine()); int box[] = new int[boxSize]; /* 상자의 무게 입력 받기 */ st = new StringTokenizer(br.readLine()); for(int i=0; i&amp;lt;boxSize; i++) box[i] = Integer.parseInt(st.nextToken()); /* 오름차순 정렬 */ Arrays.sort(box); Arrays.sort(crane); if(box[boxSize - 1] &amp;gt; crane[craneSize - 1]) { bw.write(&quot;-1&quot;); bw.close(); return; } int idx = 0; int moveAble[] = new int [craneSize]; for(int i=0; i&amp;lt;boxSize; i++) { /* 옮길 수 크레인 찾기 */ for(; crane[idx] &amp;lt; box[i]; ) idx ++; /* 옮길 수 있는 박수 개수 증가 */ moveAble[idx] ++; } int ans =0; int sum = 0; int tmp; for(int i = craneSize-1; i&amp;gt;=0; i--) { // 무거운거 들 수 있는 크레인 순 sum += moveAble[i]; // 옮긴 박스 합 2, 5 /* 역순이기 때문에 (craneSize - i) 1, 2, 3, 4, 5 ... */ if( (tmp = sum / (craneSize - i)) &amp;gt;= ans) { ans = tmp; // 1, 2 /* 나누어 떨어지면 그대로 나누어 떨어지지 않으면 +1 */ ans += (sum % (craneSize - i) != 0) ? 1 : 0; } } bw.write(Integer.toString(ans)); bw.close(); } }예외 잡는데서 시간을 많이 쓴 듯 .." }, { "title": "카메라로 사진 찍어 저장하기", "url": "/posts/CameraSaveImage/", "categories": "Android, Multimedia", "tags": "android, camera, saveimage", "date": "2022-02-01 15:46:00 +0900", "snippet": "카메라로 사진 찍어 저장하기카메라로 사진을 찍기 위해 사용되는 방법은 크게 두가지로 나눌 수 있다. 인텐트로 단말의 카메라 앱을 실행한 후 결과 사진을 받아 처리하기 앱 화면에 카메라 미리보기를 보여주고 직접 사진을 찍어 처리하기스마트폰 단말에는 카메라 앱이 미리 설치되어 있는데 이 앱을 사용하면 가장 간단하게 다른 기능의 앱을 구현할 수 있다.단말의 카메라 앱은 다른 개발자가 미리 만들어 설치해둔 것이므로 우리가 만들려는 앱에서 카메라 앱의 화면을 띄우려면 인텐트를 만들어 시스템에 요청하면 된다.인텐트를 사용해 단말의 카메라 앱을 실행한 후 결과 사진 처리하기MainActivity.javapublic class MainActivity extends AppCompatActivity { ImageView imageView; File file; Uri uri; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView = findViewById(R.id.imageView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { takePicture(); } }); } public void takePicture() { try { file = createFile(); if (file.exists()) { file.delete(); } file.createNewFile(); } catch(Exception e) { e.printStackTrace(); } if(Build.VERSION.SDK_INT &amp;gt;= 24) { uri = FileProvider.getUriForFile(this, BuildConfig.APPLICATION_ID, file); } else { uri = Uri.fromFile(file); } Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent.putExtra(MediaStore.EXTRA_OUTPUT, uri); startActivityForResult(intent, 101); } private File createFile() { String filename = &quot;capture.jpg&quot;; File outFile = new File(getFilesDir(), filename); Log.d(&quot;Main&quot;, &quot;File path : &quot; + outFile.getAbsolutePath()); return outFile; } @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == 101 &amp;amp;&amp;amp; resultCode == RESULT_OK) { try { Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(uri)); imageView.setImageBitmap(bitmap); } catch (FileNotFoundException e) { e.printStackTrace(); } } } }버튼을 클릭하면 takePicture 메서드를 호출한다.이 메서드가 호출되면 먼저 파일을 만드는데 이 파일은 카메라 앱에서 사진을 찍은 후에 그 결과물을 저장할 파일이다.FileProvider.getUriForFile 메서드를 사용하면 카메라 앱에서 공유하며 사용할 수 있는 파일의 정보를 Uri 객체로 만들 수 있다.putExtra 메서드는 다른 액티비티에 부가 데이터를 전달할 때 사용하는데 &amp;lt;키,value&amp;gt;로 전달한다.Uri 객체는 MediaStore.EXTRA_OUTPUT 키를 사용해서 인텐트에 부가 데이터를 추가한다.인텐트 객체를 만들었으므로 startActivityForResult 메서드를 이용해서 시스템으로 인텐트 객체를 전달한다.단말의 카메라 앱을 띄워달라는 액션 정보는 MediaStore.ACTION_IMAGE_CAPTURE이다.인텐트 객체를 만들어 카메라 앱을 실행한 후 사진을 찍고 나면 카메라 앱의 액티비티를 닫게 되는데 그때 응답을 받는 부분은 onActicityResult 메서드이다.onActicityResult 호출되면 카메라 앱에서 찍은 사진을 파일에서 확인할 수 있다.일반적으로 카메라 해상도가 높은 경우 비트맵 객체의 크기도 커지므로 적당한 비율로 축소하여 만들게된다. 여기에서는 1/8 크기로 축소했으며 bitmap 객체로 만들때는 BitmapFactory 클래스의 decodeFile 메서드를 호출하면 된다.external.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt; &amp;lt;cache-path name=&quot;cache&quot; path=&quot;/&quot; /&amp;gt; &amp;lt;files-path name=&quot;files&quot; path=&quot;/&quot; /&amp;gt; &amp;lt;external-files-path name=&quot;external_files&quot; path=&quot;.&quot; /&amp;gt; &amp;lt;/paths&amp;gt;external.xml 파일 안에 있는 &amp;lt;path&amp;gt; 태그는 &amp;lt;cache-path&amp;gt;, &amp;lt;files-path&amp;gt;, &amp;lt;\\external-files-path&amp;gt; 태그를 포함하고 있으며 이는 앱의 cache 폴더, files 폴더, externalFiles 폴더를 접근할 수 있도록 허용한다.AndroidManifest.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.capture.intent&quot;&amp;gt; &amp;lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.SampleCaptureIntent&quot;&amp;gt; &amp;lt;activity android:name=&quot;.MainActivity&quot; android:exported=&quot;true&quot;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt; &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;/activity&amp;gt; &amp;lt;provider android:name=&quot;androidx.core.content.FileProvider&quot; android:authorities=&quot;${applicationId}&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&amp;gt; &amp;lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/external&quot; /&amp;gt; &amp;lt;/provider&amp;gt; &amp;lt;/application&amp;gt; &amp;lt;/manifest&amp;gt;AndroidManifest.xml 파일을 열고 &amp;lt;provider&amp;gt; 태그로 내용 제공자를 추가한다.내용 제공자는 androidx 패키지 안에 들어 있는 FileProvider를 사용한다.&amp;lt;provider&amp;gt; 태그 안에는 name 속성이 들어 있고 android.core.content.FileProvider 클래스를 지정하고 있다.FileProvider 특정 폴더를 공유하는데 사용하는 내용 제공자이다.&amp;lt;authorities&amp;gt; 속성에 설정한 값은 이 앱의 패키지 이름이다.&amp;lt;meta-data&amp;gt; 태그 안에는 name과 resource 속성이 들어가며 resource 속성으로 /app/res/xml 폴더 안에 만들었던 external.xml 파일을 지정한다.이때 파일 확장자는 제외하므로 @xml/external 값으로 설정된다.결과" }, { "title": "백준 ATM (11399)", "url": "/posts/back-11399/", "categories": "PS, Greedy", "tags": "backjoon, greedy", "date": "2022-01-31 18:08:00 +0900", "snippet": "백준 ATM(11399번)그리디 문제이다.돈을 인출하는데 가장 적게 걸리는 시간순으로 정렬을 한 후 개인별로 대기해야하는 시간을 계산 해준 후 다 더해서 구하면 끝import java.io.*; import java.util.*; class Time implements Comparable&amp;lt;Time&amp;gt;{ int time; public Time(int time) { this.time = time; } @Override public int compareTo(Time tm) { return (this.time &amp;gt; tm.time) ? 1 : -1; } } public class Main { static int arr[]; public static void main(String[] args) throws NumberFormatException, IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int N = Integer.parseInt(br.readLine()); Time [] arr = new Time[N]; StringTokenizer st = new StringTokenizer(br.readLine()); for(int i=0; i&amp;lt;N; i++) arr[i] = new Time(Integer.parseInt(st.nextToken())); Arrays.sort(arr); int sum = 0; int ans = arr[0].time; for(int i=0; i&amp;lt;N-1; i++) { sum = arr[i].time + arr[i+1].time; arr[i+1].time = sum; ans += sum; } bw.write(ans + &quot;\\n&quot; ); bw.close(); } }" }, { "title": "멀티 터치 이미지 뷰어", "url": "/posts/MultiTouch/", "categories": "Android, User_Interface", "tags": "android, layout, bitmap", "date": "2022-01-31 17:14:00 +0900", "snippet": "멀티터치 이미지 뷰어 만들기애플이 아이폰을 처음 시연할 때 사람들이 놀라워했던 기능 중의 하나가 멀터터치 기능이다.즉, 두 손가락을 이용해 손가락 사이를 벌리면 이미지가 점차 확대되고 손가락 사이를 좁히면 이미지가 작아지도록 만들 때 사용하는 기능인데 지금은 아주 일반적인 기능이 되어 있다.멀티터치는 실제 앱을 만들 때 그렇게 자주 활용되지는 않지만 생각보다 어렵지 않기 때문에 간단히 살펴보자.일반적인 이벤트 처리 과정에서 알 수 있는, 한 손가락으로 터치 했을 때의 x,y 좌표 값 뿐만 아니라 두 번째 손가락으로 터치 했을 때의 x,y 좌표 값까지 알 수 있다면 여러 손가락을 이용하는 기능을 만들 수 있다.물론 손가락으로 눌렀을 때, 드래그 할 때 그리고 떨어졌을 때를 구분할 수 있어야 한다.하나의 손가락에 대한 좌표 값은 getX와 getY 메서드를 이용해 알 수 있고, 눌린 상태는 getAction 메서드를 이용해 구분 할 수 있다.이 정보를 두 개의 손가락마다 구분하기 위해 다음과 같은 메서드가 제공된다.APIpublic final int getPointerCount()public final float getX(int pointerIndex)public final float getY(int pointerIndex)세 가지 메서드는 뷰의 onTouch 메서드로 전달되는 MotionEvent 객체에 정의 되어 있으며, 여러개의 손가락으로 터치된 정보를 알기 위해 필요한 기본적인 메서드들이다.getPointerCount 메서드는 몇 개의 손가락이 터치되었는지를 알 수 있도록 해주는 것이고,만약 반환된 값이 1이라면 한 개의 손가락, 2라면 두개의 손가락이 터치된 상태이다.이벤트 처리에 자주 사용되는 getX와 getY 메서드는 손가락이 하나일 때 X와 Y의 좌표 값을 가져오지만 getX(int pointerIndex)와 getY(int pointerIndex) 메서드는 여러 개의 손가락이 터치되었을 때 각각의 손가락이 가지는 인덱스의 값을 이용해 좌표 값을 확인할 수 있다.예를 들어, 두 개의 손가락이 터치되면 첫 번째 손가락은 인덱스 0 , 두번 째 손가락은 인덱스 1이 되고, getPointerCount 메서드를 호출했을 때 반환되는 값은 2가 된다.첫 번째 손가락으로 터치한 지점을 알고 싶으면 getX(0) 과 getY(0)를 호출하면 된다.예제ImageDisplayView.javapublic class ImageDisplayView extends View implements View.OnTouchListener { private static final String TAG = &quot;ImageDisplayView&quot;; Context mContext; Canvas mCanvas; Bitmap mBitmap; Paint mPaint; int lastX; int lastY; Bitmap sourceBitmap; Matrix mMatrix; float sourceWidth = 0.0F; float sourceHeight = 0.0F; float bitmapCenterX; float bitmapCenterY; float scaleRatio; float totalScaleRatio; float displayWidth = 0.0F; float displayHeight = 0.0F; int displayCenterX = 0; int displayCenterY = 0; public float startX; public float startY; public static float MAX_SCALE_RATIO = 5.0F; public static float MIN_SCALE_RATIO = 0.1F; float oldDistance = 0.0F; int oldPointerCount = 0; boolean isScrolling = false; float distanceThreshold = 3.0F; public ImageDisplayView(Context context) { super(context); mContext = context; init(); } public ImageDisplayView(Context context, AttributeSet attrs) { super(context, attrs); mContext = context; init(); } private void init() { mPaint = new Paint(); mMatrix = new Matrix(); lastX = -1; lastY = -1; setOnTouchListener(this); } /* 뷰가 초기화 되고 나서 화면에 보이기 전 크기가 정해지면 호출되는 메서드 안에서 메모리 상에 새로운 비트맵 객체 생성 */ protected void onSizeChanged(int w, int h, int oldw, int oldh) { if (w &amp;gt; 0 &amp;amp;&amp;amp; h &amp;gt; 0) { newImage(w, h); redraw(); } } public void newImage(int width, int height) { Bitmap img = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(); canvas.setBitmap(img); mBitmap = img; mCanvas = canvas; displayWidth = (float)width; displayHeight = (float)height; displayCenterX = width/2; displayCenterY = height/2; } public void drawBackground(Canvas canvas) { if (canvas != null) { canvas.drawColor(Color.BLACK); } } /* 뷰가 화면에 그려지는 메서드 안에서 메모리 상의 비트맵 객체 그리기 */ protected void onDraw(Canvas canvas) { if (mBitmap != null) { canvas.drawBitmap(mBitmap, 0, 0, null); } } public void setImageData(Bitmap image) { recycle(); sourceBitmap = image; sourceWidth = sourceBitmap.getWidth(); sourceHeight = sourceBitmap.getHeight(); bitmapCenterX = sourceBitmap.getWidth()/2; bitmapCenterY = sourceBitmap.getHeight()/2; scaleRatio = 1.0F; totalScaleRatio = 1.0F; } public void recycle() { if (sourceBitmap != null) { sourceBitmap.recycle(); } } public void redraw() { if (sourceBitmap == null) { Log.d(TAG, &quot;sourceBitmap is null in redraw().&quot;); return; } drawBackground(mCanvas); float originX = (displayWidth - (float)sourceBitmap.getWidth()) / 2.0F; float originY = (displayHeight - (float)sourceBitmap.getHeight()) / 2.0F; mCanvas.translate(originX, originY); mCanvas.drawBitmap(sourceBitmap, mMatrix, mPaint); mCanvas.translate(-originX, -originY); invalidate(); } /* 뷰를 터치할 때 호출되는 메서드 다시 정의 */ public boolean onTouch(View v, MotionEvent ev) { final int action = ev.getAction(); int pointerCount = ev.getPointerCount(); // 터치했을 때 몇개의 손가락으로 터치하는지 개수 확인 Log.d(TAG, &quot;Pointer Count : &quot; + pointerCount); switch (action) { case MotionEvent.ACTION_DOWN: // 손가락으로 눌렀을때의 기능 추가 if (pointerCount == 1) { float curX = ev.getX(); float curY = ev.getY(); startX = curX; startY = curY; } else if (pointerCount == 2) { oldDistance = 0.0F; isScrolling = true; } return true; case MotionEvent.ACTION_MOVE: // 손가락으로 움직일 때의 기능 추가 if (pointerCount == 1) { if (isScrolling) { return true; } float curX = ev.getX(); float curY = ev.getY(); if (startX == 0.0F) { startX = curX; startY = curY; return true; } float offsetX = startX - curX; float offsetY = startY - curY; if (oldPointerCount == 2) { } else { Log.d(TAG, &quot;ACTION_MOVE : &quot; + offsetX + &quot;, &quot; + offsetY); if (totalScaleRatio &amp;gt; 1.0F) { moveImage(-offsetX, -offsetY); // 한손가락으로 움직이고 있을 때는 moveImage 메서드 호출 } startX = curX; startY = curY; } } else if (pointerCount == 2) { float x1 = ev.getX(0); float y1 = ev.getY(0); float x2 = ev.getX(1); float y2 = ev.getY(1); float dx = x1 - x2; float dy = y1 - y2; float distance = new Double(Math.sqrt(new Float(dx * dx + dy * dy).doubleValue())).floatValue(); float outScaleRatio = 0.0F; if (oldDistance == 0.0F) { oldDistance = distance; break; } if (distance &amp;gt; oldDistance) { if ((distance-oldDistance) &amp;lt; distanceThreshold) { return true; } outScaleRatio = scaleRatio + (oldDistance / distance * 0.05F); } else if (distance &amp;lt; oldDistance) { if ((oldDistance-distance) &amp;lt; distanceThreshold) { return true; } outScaleRatio = scaleRatio - (distance / oldDistance * 0.05F); } if (outScaleRatio &amp;lt; MIN_SCALE_RATIO || outScaleRatio &amp;gt; MAX_SCALE_RATIO) { Log.d(TAG, &quot;Invalid scaleRatio : &quot; + outScaleRatio); } else { Log.d(TAG, &quot;Distance : &quot; + distance + &quot;, ScaleRatio : &quot; + outScaleRatio); scaleImage(outScaleRatio); // 두 손가락으로 움직이고 있을 때는 scaleImage 호출 } oldDistance = distance; } oldPointerCount = pointerCount; break; case MotionEvent.ACTION_UP: // 손가락을 떄었을 때의 기능 추가 if (pointerCount == 1) { float curX = ev.getX(); float curY = ev.getY(); float offsetX = startX - curX; float offsetY = startY - curY; if (oldPointerCount == 2) { } else { moveImage(-offsetX, -offsetY); } } else { isScrolling = false; } return true; } return true; } /* 매트릭스 객체를 사용해 이미지 크기 변경 */ private void scaleImage(float inScaleRatio) { Log.d(TAG, &quot;scaleImage() called : &quot; + inScaleRatio); mMatrix.postScale(inScaleRatio, inScaleRatio, bitmapCenterX, bitmapCenterY); mMatrix.postRotate(0); totalScaleRatio = totalScaleRatio * inScaleRatio; redraw(); } /* 매트릭스 객체를 사용해 이미지 이동 */ private void moveImage(float offsetX, float offsetY) { Log.d(TAG, &quot;moveImage() called : &quot; + offsetX + &quot;, &quot; + offsetY); mMatrix.postTranslate(offsetX, offsetY); redraw(); } }이미지를 보여주고 터치했을 때의 이벤트를 이용해 이미지를 확대/축소하거나 이동하기 위해 새로 정의하는 ImageDisplayView 클래스는 일반 View 클래스를 상속한다.또한 이 클래스는 터치 이벤트를 처리하므로 onTouchListener 인터페이스를 구현 하도록 한다. 이 인터페이스는 onTouch 메서드를 포함하고 있어서, 뷰에 설정할 경우 터치 이벤트가 발생할 때마다 onTouch 메서드를 호출한다.우리가 원하는 대로 두 손가락을 이용해 이미지를 크게 만들려고 하면 이 메서드 안에서 터치할 때의 좌표 값을 받아 이미지의 크기를 바꾸어야 한다.이미지의 크기를 확대 또는 축소하거나 이미지를 이동하기 위해 사용할 수 있는 방법은 Matrix 객체를 사용하는 것이다. 이 객체는 수학적인 연산을 통해 비트맵 이미지의 각 픽셀 값을 변경해주는데, 이 객체를 사용하기 쉽도록 다음과 같이 비트맵 이미지를 확대하거나 이동하는 메서드가 이미 정의되어 있으므로 단순히 이 메서드를 호출하는 것만으로도 원하는 기능을 만들 수 있다.Matrix APIpublic boolean postScale(float sx, float sy, float px, float py)public boolean postTranslate(float dx, float dy)public boolean postRotate(float degress)postScale 메서드는 비트맵 이미지를 확대 또는 축소 할 수 있다. 첫 번째 매개 변수는 X축을 기준으로 확대하는 비율 두 번째 매개 변수는 Y축을 기준으로 확대하는 비율 세 번째, 네 번째 매개 변수는 확대 또는 축소할 때 기준이 되는 위치가 되는데 일반적으로 비트맵 이미지의 중심점을 지정한다.postTranslate 메서드는 비트맵 이미지를 이동시킬 때 사용한다. 첫 번째, 두 번째 매개 변수는 이동할 만큼의 X와 Y 좌표 값을 의미postRotate 메서드는 비트맵 이미지를 회전시킬 때 사용한다. 첫 번째 매개 변수는 회전 각도를 의미한다.이렇게 세가지 메서드를 통해 비트맵 이미지를 확대/축소 할 수 있지만 터치 이벤트를 처리해 기능을 구현하기 전에 먼저 뷰에 사진 이미지를 보여줄 수 있어야 한다.또한 터치 이벤트를 지속적으로 처리해 다시 그려주는 과정이 필요하므로 메모리에 비트맵 이미지를 만들어 두고 onDraw 메서드 안에서 메모리에 만들어둔 비트맵 이미지를 화면에 보여주는 더블 버퍼링 방식을 사용해야한다.비트맵 이미지를 초기화하는 부분은 init 메서드가 아닌 onSizeChanged 메서드에 들어 있는데 그 이유는 뷰가 화면에 보이기 전에 onSizeChanged메서드가 호출되므로 이 메서드 안에서 비트맵 이미지를 만드는 것이 효율적이기 때문이다.MainActivity.javapublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); LinearLayout container = findViewById(R.id.container); Resources res = getResources(); Bitmap bitmap = BitmapFactory.decodeResource(res, R.drawable.beach); ImageDisplayView view = new ImageDisplayView(this); view.setImageData(bitmap); LinearLayout.LayoutParams params = new LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT); container.addView(view, params); } }결과" }, { "title": "페인트 보드", "url": "/posts/PaintBoard/", "categories": "Android, User_Interface", "tags": "android, layout, paintboard", "date": "2022-01-31 15:40:00 +0900", "snippet": "페인트 보드 만들기페인트 보드는 손가락으로 터치하는 방식의 터치 이벤트를 처리하여 빈 화면 위에 손가락으로 그림을 그릴 수 있는 가장 단순한 형태이다.즉, onTouchEvent 메서드로 터치한 곳의 좌표 값을 이용하여 그리기 기능을 구현한 것이다.터치 이벤트가 동작하는 방식은 크게 (1)눌렀을 때와 (2) 누른 상태로 움직일 때 그리고 (3) 떼었을 때로 나눌 수 있다.각각의 경우에 대하여 이벤트를 처리하면서 drawLine 메서드로 선을 그리면 된다.이런 페인트 보드는실제 업무용으로 많이 사용되는 물류/택배 분에서 고객들에게 사인을 받을때 사용되기도 한다.예제PaintBoard.javapublic class PaintBoard extends View { Canvas mCanvas; Bitmap mBitmap; Paint mPaint; int lastX; int lastY; public PaintBoard(Context context){ super(context); init(context); } public PaintBoard(Context context, AttributeSet attrs){ super(context, attrs); init(context); } private void init(Context context){ this.mPaint = new Paint(); this.mPaint.setColor(Color.BLACK); this.lastX = -1; this.lastY = -1; } protected void onSizeChanged(int w, int h, int oldw, int oldh){ Bitmap img = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(); canvas.setBitmap(img); canvas.drawColor(Color.WHITE); mBitmap = img; mCanvas = canvas; } protected void onDraw(Canvas canvas){ if (mBitmap != null) canvas.drawBitmap(mBitmap,0 ,0, null); } public boolean onTouchEvent(MotionEvent event){ int action = event.getAction(); int X = (int) event.getX(); int Y = (int) event.getY(); switch (action){ case MotionEvent.ACTION_UP: lastX = -1; lastY = -1; break; case MotionEvent.ACTION_DOWN: if(lastX != -1){ if(X != lastX || Y != lastY) mCanvas.drawLine(lastX, lastY, X, Y, mPaint); lastX = X; lastY = Y; break; } case MotionEvent.ACTION_MOVE: if(lastX != -1) mCanvas.drawLine(lastX, lastY, X, Y, mPaint); lastX = X; lastY = Y; break; } invalidate(); return true; } }손가락으로 누른 ACTION_DOWN 상태에서 좌표 값을 변수에 저장한 후 ACTION_MOVE 상태에서 이전 좌표 값과 현재의 좌표 값을 연결하여 선을 그리는 것이다.MainActivity.javapublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); PaintBoard view = new PaintBoard(this); setContentView(view); } }결과그런데 그림을 그리 때 손가락을 빨리빨리 움직여보면 선이 부드러운 곡선이 아니라 일부분이 직선으로 그려지는 것을 볼 수 있다. 그 이유는 터치 이벤트를 처리할 때 직선으로 각각의 좌표 값을 연결했기 때문이다.이 부분을 좀 더 부드럽게 처리하려면 어떻게 해야할까?여라가지 그리기 메서드 중에서 패스를 이용하면 연속적인 점들을 이용하여 직선 또는 부드러운 곡선을 그릴 수 있다.흔히 아크(Arc) 또는 커브(Curve) 로도 표현되는 곡선 그리기 방법은 drawLine 메서드를 이용하여 직선을 그려 점들을 연결할 때 발생하는 격자형의 딱딱함을 없앨 수 있다.BestPaintBoard.javapublic class BestPaintBoard extends View { public boolean changed = false; Canvas mCanvas; Bitmap mBitmap; Paint mPaint; float lastX; float lastY; Path mPath = new Path(); float mCurveEndX; float mCurveEndY; int mInvaliadteExtraBorder = 10; static final float TOUCH_TOLERANCE = 8; public BestPaintBoard(Context context){ super(context); init(context); } public BestPaintBoard(Context context, AttributeSet attrs){ super(context); init(context); } private void init(Context context){ mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setColor(Color.BLACK); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeJoin(Paint.Join.ROUND); mPaint.setStrokeCap(Paint.Cap.ROUND); mPaint.setStrokeWidth(3.0F); this.lastX = -1; this.lastY = -1; } protected void onSizeChanged(int w, int h, int oldw, int oldh){ Bitmap img = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(); canvas.setBitmap(img); canvas.drawColor(Color.WHITE); mBitmap = img; mCanvas = canvas; } protected void onDraw(Canvas canvas){ if(mBitmap != null) canvas.drawBitmap(mBitmap, 0, 0 ,null); } public boolean onTouchEvent(MotionEvent event){ int action = event.getAction(); switch (action){ case MotionEvent.ACTION_UP: changed = true; Rect rect = touchUp(event, false); // Rect는 사각형을 만드는 클래스 if(rect != null){ invalidate(rect); } mPath.rewind(); // 라인 커브는 지우고 내부 정보는 다시 사용 return true; case MotionEvent.ACTION_DOWN: rect = touchDown(event); if(rect != null){ invalidate(rect); } return true; case MotionEvent.ACTION_MOVE: rect = touchMove(event); if(rect != null){ invalidate(rect); } return true; } return false; } private Rect touchDown(MotionEvent event){ float x = event.getX(); float y = event.getY(); lastX = x; lastY = y; Rect mInvalidRect = new Rect(); mPath.moveTo(x,y); final int border = mInvaliadteExtraBorder; mInvalidRect.set((int) x - border, (int) y - border, (int) x + border, (int) y + border); mCurveEndX = x; mCurveEndY = y; mCanvas.drawPath(mPath, mPaint); return mInvalidRect; } private Rect touchMove(MotionEvent event){ return processMove(event); } private Rect touchUp(MotionEvent event, boolean cancel){ return processMove(event); } private Rect processMove(MotionEvent event){ final float x = event.getX(); final float y = event.getY(); final float dx = Math.abs(x - lastX); final float dy = Math.abs(y - lastY); Rect mInvalidRect = new Rect(); if(dx &amp;gt;= TOUCH_TOLERANCE || dy &amp;gt;= TOUCH_TOLERANCE){ // 단순 터치인지 선을 그린 것인지 판단 final int border = mInvaliadteExtraBorder; mInvalidRect.set((int) mCurveEndX - border, (int) mCurveEndY - border, (int) mCurveEndX + border, (int) mCurveEndY + border); float cX = mCurveEndX = (x + lastX) / 2; float cY = mCurveEndY = (y + lastY) / 2; mPath.quadTo(lastX, lastY, cX, cY); mInvalidRect.union((int) lastX - border, (int) lastY - border, (int) cX + border, (int) cY + border); lastX = x; lastY = y; mCanvas.drawPath(mPath, mPaint); } return mInvalidRect; } }결과" }, { "title": "비트맵 객체로 그래픽 그리기", "url": "/posts/DrawBitmapGraphic/", "categories": "Android, User_Interface", "tags": "android, layout, bitmap", "date": "2022-01-31 00:08:00 +0900", "snippet": "비트맵 객체로 그래픽 그리기Bitmap을 다루기 위해 주로 사용되는 녀석은 Bitmap안에 있는 메소드가 아니라BitmapFactory안에 있는 메소드를 주로 사용한다.BitmapFactory 클래스는 파일(file), 스트림(stream), 바이트-배열(byte-array) 등의 다양한 소스(source)로부터 이미지 데이터를 읽어들여 Bitmap객체를 생성하는 클래스이다.BitmapFactory 클래스에 정의된 대표적인 메서드들은 다음과 같다.     파일에서 읽기 파일 path를 지정하면 해당 위치의 이미지 파일을 읽어온다. -&amp;gt; public static Bitmap decodeFile(String pathName) 리소스에서 읽기 리소스에 저장한 이미지 파일을 읽어온다. -&amp;gt; public static Bitmap decodeResource(Resources res, int id) 바이트 배열에서 읽기 바이트 배열로 되어 있는 이미지 파일을 읽어 온다. -&amp;gt; public static Bitmap decodeByteArray(byte [] data, int offset, int length) 스트림에서 읽기 입력 스트림에서 이미지 파일을 읽어 온다. -&amp;gt; public static Bitmap decodeStream(InputStream is) 바이트 배열이나 스트림에서 읽을 수 있다는 것은 원격지에 있는 이미지 파일도 손쉽게 읽어 들일 수 있다는 것을 의미한다.원격지의 소켓 서버나 웹 서버에 있는 이미지 파일은 서버에 연결한 후 입력 스트림으로 이미지를 읽어 들이거나 바이트 배열의 형태로 읽어 들인 데이터를 decodeBtyeArray 메서드를 이용해서 이미지로 변환 할 수 있다.예제CustomViewImg.javapublic class CustomViewImage extends View { // View를 상속하여 새로운 View 정의 private Bitmap cacheBitmap; // 메모리에 만들어질 Bitmap 객체 선언 private Canvas cacheCanvas; // Bitmap 객체를 그리기 위한 Canvas 객체 선언 private Paint mPaint; public CustomViewImage(Context context){ super(context); init(context); } public CustomViewImage(Context context, AttributeSet attrs){ super(context); init(context); } private void init(Context context){ mPaint = new Paint(); } /* 뷰가 화면에 보이기 전에 Bitmap 객체 만들고 그 위에 그리기 */ protected void onSizeChanged(int w, int h, int oldw, int oldh){ createCacheBitmap(w, h); testDrawing(); } /* 메모리에 Bitmap 객체를 만들고 Canvas 객체 설정 */ private void createCacheBitmap(int w, int h){ cacheBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); cacheCanvas = new Canvas(); cacheCanvas.setBitmap(cacheBitmap); } /* 빨간 사각형 그리기 */ private void testDrawing(){ cacheCanvas.drawColor(Color.WHITE); mPaint.setColor(Color.RED); cacheCanvas.drawRect(100, 100, 200, 200, mPaint); /* 리소스의 이미지 파일을 읽어 들여 화면에 그리기) */ Bitmap srcImg = BitmapFactory.decodeResource(getResources(), R.drawable.water); cacheCanvas.drawBitmap(srcImg, 30, 30, mPaint); /* Matrix 객체를 이용해 좌우 대칭이 되는 비트맵 이미지 만들어 그리기 */ Matrix horInverseMatrix = new Matrix(); horInverseMatrix.setScale(-1,1); Bitmap horInverseImg = Bitmap.createBitmap(srcImg, 0, 0, srcImg.getWidth(), srcImg.getHeight(),horInverseMatrix, false); cacheCanvas.drawBitmap(horInverseImg,30,130,mPaint); /* Matrix 객체를 이용해 상하 대칭이 되는 비트맵 이미지 만들어 그리기 */ Matrix verInverseMatrix = new Matrix(); verInverseMatrix.setScale(1,-1); Bitmap verInverseImg = Bitmap.createBitmap(srcImg, 0,0, srcImg.getWidth(), srcImg.getHeight(), verInverseMatrix, false); cacheCanvas.drawBitmap(verInverseImg,30,230,mPaint); mPaint.setMaskFilter(new BlurMaskFilter(10, BlurMaskFilter.Blur.NORMAL)); Bitmap scaledImg = Bitmap.createScaledBitmap(srcImg, srcImg.getWidth() *3, srcImg.getHeight() * 3, false); } /* 메모리에 Bitmap을 이용해 화면에 그리기 */ protected void onDraw(Canvas canvas){ if(cacheBitmap != null){ canvas.drawBitmap(cacheBitmap,0 ,0, null); } } }이미지를 다양 한 효과를 주기 위해 마스크(Mask)를 사용하기도 한다.여러 마스크 필터 중에서 BlurMaskFilter는 번짐 효과를 낼 수 있는 마스크 필터로 페인트 객체에 설정하여 사용할 수 있다.비트맵 이미지를 확대할 때는 createScaledBitmap 메서드를 사용할 수 있다.결과" }, { "title": "드로어블 객체로 만들어 그리기", "url": "/posts/DrawDrawable/", "categories": "Android, User_Interface", "tags": "android, layout", "date": "2022-01-30 21:54:00 +0900", "snippet": "드로어블 객체로 만들어 그리기그래픽 그리기가 가능한 요소들은 드로어블(Drawable) 객체로 만들어 그릴 수 있다.드로어블 객체는 이미 XML 파일로 정의할 수 있다는 것을 알고 있다.이 드로어블 객체는 그릴 수 있는 모든 것을 의미하는데 대표적으로 ShapeDrawable,BitmapDrawable, PicutreDrawable, LayerDrawable등이 있다.그리기 객체의 형태로는 PNG, JPEG 이미지 등을 표현하는 비트맵(Bitmap), 이미지가 자동으로 늘어나는 부분을 설정하여 사용하는 나인패치(NinePatch), 도형 그리기가 가능한 셰이프(Shape), 세로축의 순서에 따라 그리는 레이어 (Layer) 등이 있다.그리기 메서드를 사용하면 다양한 그래픽을 그릴 수 있는데 왜 굳이 그리기 객체르 만들어서 그리는 방법이 따로 있는 걸까?그래픽을 그리는 하나의 단위를 그리기 객체로 만들어 두면 각각의 그래픽 그리기 작업을 독립적인 객체로 나누어 관리 할 수 있는 장점이 생기기 때문이다.그리기 객체를 사용하는 방법은 크게 세 가지로 나눌 수 있다. 구분 설명 리소스 파일의 사용 프로젝트 리소스에 이미지와 같은 파일을 포함시킨 후 읽어 들여 사용한다. XML로 정의하여 사용 그리기 객체의 속성을 정의한 XML 파일을 정의하여 사용한다. 소스 코드에서 객체를 만들어 사용 소스 코드에서 new 연산자를 이용하여 그리기 객체를 만든 후 사용한다. 비트맵 이미지를 주어진 좌표 값에 그린다. ShapeDrawable에 정의된 정보를 이용해 그라데이션 효과 주기CustomViewDrawable.javapublic class CustomViewDrawable extends View { private ShapeDrawable upperDrawable; private ShapeDrawable lowerDrawable; public CustomViewDrawable(Context context){ super(context); init(context); } public CustomViewDrawable(Context context, AttributeSet attrs){ super(context, attrs); init(context); } private void init(Context context){ /* 윈도우 매니저를 이용해 뷰의 폭과 높이 확인 */ WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); Display display = manager.getDefaultDisplay(); int width = display.getWidth(); int height = display.getHeight(); /* 리소스에 정의된 색상 값을 변수에 설정*/ Resources curRes = getResources(); int blackColor = curRes.getColor(R.color.color01); int grayColor = curRes.getColor(R.color.color02); int darkGrayColor = curRes.getColor(R.color.color03); upperDrawable = new ShapeDrawable(); // Drawable 객체 생성 RectShape rectangle = new RectShape(); rectangle.resize(width, height * 2 / 3); upperDrawable.setShape(rectangle); upperDrawable.setBounds(0,0,width,height * 2 / 3); LinearGradient gradient = new LinearGradient(0, 0, 0, height * 2 / 3, grayColor,blackColor, Shader.TileMode.CLAMP); Paint paint = upperDrawable.getPaint(); paint.setShader(gradient); // Paint 객체에 새로 생성한 LinearGradient 객체를 Shader로 설정 lowerDrawable = new ShapeDrawable(); RectShape rectangle2 = new RectShape(); rectangle2.resize(width, height * 1 / 3); lowerDrawable.setShape(rectangle2); lowerDrawable.setBounds(0, height * 2 / 3, width, height); LinearGradient gradient2 = new LinearGradient(0, 0, 0, height * 1 / 3, blackColor, darkGrayColor, Shader.TileMode.CLAMP); Paint paint2 = lowerDrawable.getPaint(); paint2.setShader(gradient2); } protected void onDraw(Canvas canvas){ super.onDraw(canvas); upperDrawable.draw(canvas); // onDraw 메서드 안에서 Drawable 객체 그리기 lowerDrawable.draw(canvas); } }뷰가 채워지는 화면의 크기를 알아오기 위해 시스템 서비스 객체인 윈도우 매니저를 참조한다. 색상 정보는 XML 파일로 저장되었으며, /app/res/values/ 폴더 밑에 color.xml 이라는 이름으로 저장되어 있다.이렇게 색상을 지정할 때는 소스 코드에서 설정하는 경우와 XML 리소스에 설정하는 경우로 나눌 수 있다. 소스 코드에서는 Color 클래스에 정의된 상수 또는 argb 메서드를 이용한다.int color = Color.BLUE; // 파란색 사용int transColor = Color.argb(128, 0, 0, 255); // 반투명 파란색 사용XML 리소스를 이용하는 겨웅에는 XML 파일에 &amp;lt;color&amp;gt; 태그로 정의된 색상 값을 지정한 후, 소스 코드에서 리소스 객체의 getColor 메서드를 이용하여 읽어 온다.위와 같은 효과를 줄 수 있다. 이번 예제에서는 XML 소스를 이용한다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;resources&amp;gt; &amp;lt;color name=&quot;transcolor&quot;&amp;gt;#6600000ff&amp;lt;/color&amp;gt;&amp;lt;/resources&amp;gt;// 소스코드int transcolor = getResources().getColor(R.color.transcolor);XML 에서 색상 값을 설정하기 위해 /app/res/values/colors.xml 파일을 열고 color01, coloro2, color03 이라는 이름을 가진 색상 값을 추가한다. ....&amp;lt;color name=&quot;color01&quot;&amp;gt;#FF000000&amp;lt;/color&amp;gt; &amp;lt;color name=&quot;color02&quot;&amp;gt;#FF888888&amp;lt;/color&amp;gt; &amp;lt;color name=&quot;color03&quot;&amp;gt;#FF333333&amp;lt;/color&amp;gt; ....그리기 객체는 draw 메서드를 직접 호출하여 그릴 수 있으므로 onDraw 메서드 내에서 호출하되 파라미터로 캔버스 객체를 전달한다.LinearGradinent를 이용하면 뷰 영역의 위쪽 2/3와 아래 쪽 1/3을 따로 채워줌으로써 위쪽에서부터 아래쪽으로 색상이 조금씩 변하는 배경 화면을 만들 수 있다.LinearGradient는 선의 형태로 그라데이션 효과를 준다.마지막으로 MainActivity.java를 수정한다.public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); CustomViewDrawable view = new CustomViewDrawable(this); setContentView(view); } }결과" }, { "title": "더블 버퍼링 (Double Buffering)", "url": "/posts/DoubleBuffering/", "categories": "Android, User_Interface", "tags": "android, layout, bitmap", "date": "2022-01-30 11:00:00 +0900", "snippet": "더블 버퍼링 (Double Buffering)비트맵 객체는 메모리에 만들어지는 이미지이다.예를 들어,사진을 찍었을 때 만들어지는 이미지 파일을 읽을 때 메모리에 비트맵 객체로 만들 수 있다.비트맵 객체를 이용하면 화면에 이미지를 그릴 수 있고 다양한 조작도 할 수 있다.특히, 비트맵은 그래픽을 그릴 수 있는 메모리 공간을 제공한다.흔히 더블 버퍼링(Double Buffering) 이라 불리는 방법인데, 별도의 메모리 공간에 미리 그래픽을 그린 후 뷰가 다시 그려져야 할 필요가 있을 때 미리 그려놓은 비트맵을 화면에 표시하는 방법이다.별도의 메모리 공간에 미리 그래픽을 그린 후 뷰가 다시 그려져야 할 필요가 있을 때 미리 그려놓은 비트맵을 화면에 표시하는 방법이다.더블 버퍼링 왜 사용하는가 ?API를 시작하다보면 비트맵 이미지를 사용하게 된다. 그 때 이미지들이 전환되면서 영상처럼 부드럽게 움직일 거라 생각하지만 실제로 이미지들이 움직일 때마다 화면이 깜빡이는 현상이 눈에 들어온다. 쉽게 말하자면 아래와 같은 상황인 것이다.▶ 게임 캐릭터이미지를 구현할 때 이미지를 움직이게 하고 싶다.그러나 캐릭터가 띄엄띄엄 움직임과 동시에 깜빡거리는 화면 때문에 게임할 맛이 안난다.그 이유는 컴퓨터가 이미지를 지웠다가 새 이미지를 다시 그리는 방식을 반복하기 때문이다.이미지 그리는데 시간이 소요되므로 이미지의 출력이 잦을수록 깜빡거리는 현상이 심해진다.이에 대한 해결방안으로 버퍼 역할을 해줄 메모리 장치 컨텍스트(보이지 않는 화면)를 하나 더 사용하여 그곳에 이미지를 그리고, 기존화면을 유지하다가 이미지가 완성되면 실제 화면 장치 컨텍스트로 한꺼번에 베껴 그리는 것이다.아래는 이를 그림으로 표현한 것이다.우선 /app/res/drawable 폴더에 이미지를 넣어준다.그 후 CustomViewImage.java 클래스를 만들어 준 후 코드를 작성해 준다.CustomViewImage.javapublic class CustomViewImage extends View { // View를 상속하여 새로운 View 정의 private Bitmap cacheBitmap; // 메모리에 만들어질 Bitmap 객체 선언 private Canvas cacheCanvas; // Bitmap 객체를 그리기 위한 Canvas 객체 선언 private Paint mPaint; public CustomViewImage(Context context){ super(context); init(context); } public CustomViewImage(Context context, AttributeSet attrs){ super(context); init(context); } private void init(Context context){ mPaint = new Paint(); } /* 뷰가 화면에 보이기 전에 Bitmap 객체 만들고 그 위에 그리기 */ protected void onSizeChanged(int w, int h, int oldw, int oldh){ createCacheBitmap(w, h); testDrawing(); } /* 메모리에 Bitmap 객체를 만들고 Canvas 객체 설정 */ private void createCacheBitmap(int w, int h){ cacheBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); cacheCanvas = new Canvas(); cacheCanvas.setBitmap(cacheBitmap); } /* 빨간 사각형 그리기 */ private void testDrawing(){ cacheCanvas.drawColor(Color.WHITE); mPaint.setColor(Color.RED); cacheCanvas.drawRect(100, 100, 200, 200, mPaint); } /* 메모리에 Bitmap을 이용해 화면에 그리기 */ protected void onDraw(Canvas canvas){ if(cacheBitmap != null){ canvas.drawBitmap(cacheBitmap,0 ,0, null); } } }인제 MainActivity에 CustomViewImage 클래스를 추가 해주자.CustomViewImage.javapublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); CustomViewImage view = new CustomViewImage(this); setContentView(view); } }–결과뷰가 새로 그려질 때 호출되는 onDraw 메서드를 보면 단순히 메모리에 만들어 두었던 cacheBitmap을 그리는 코드만 들어가 있다. 실제 그래픽이 그려지는 시점은 testDrawing 메서드가 호출되었을 때 초기화된 후, testDrawing 메서드에 의해 그려지게 된다.더블 버퍼링을 이용한 그래픽 그리기 개념도" }, { "title": "뷰에 그래픽 그리기", "url": "/posts/DrawView/", "categories": "Android, User_Interface", "tags": "android, layout", "date": "2022-01-29 20:34:00 +0900", "snippet": "뷰에 그래픽 그리기안드로이드에서 그래픽을 사용할 때 자바와의 차이점은 그래픽스(Graphics) 객체가 아니라 캔버스(Canvas) 객체에 그려야 한다는 것이다.일반적으로 뷰를 그리는 단계는 아래와 같다. 구분 설명 1단계 새로운 클랫를 만들고 뷰를 상속 받는다. 2단계 페인트 객체를 초기화하고 필요한 속성을 설정한다. 3단계 onDraw 메서드 내에 사각형을 그리는 메서드를 호출한다. 4단계 onTouchEvent 메서드 내에서 터치 이벤트를 처리하는 코드를 넣는다. 5단계 새로 만든 뷰를 메인 액티비티에 추가한다. 화면에 빨간 사각형 그리기그래픽을 새로 그려주기 위해 CustomView를 정의 해줍니다. CustomView.javapublic class CustomView extends View { private Paint paint; public CustomView(Context context) { super(context); } public CustomView(Context context, @Nullable AttributeSet attrs) { super(context, attrs); init(context); } private void init(Context context){ paint = new Paint(); paint.setColor(Color.RED); } @Override protected void onDraw(Canvas canvas){ super.onDraw(canvas); canvas.drawRect(100, 100, 200 , 200, paint); // 사각형 그리기 } @Override public boolean onTouchEvent(MotionEvent event){ if(event.getAction() == MotionEvent.ACTION_DOWN){ Toast.makeText(super.getContext(), &quot;MotionEvent.ACTION_DOWN: &quot; + event.getX() + &quot;, &quot; + event.getY(), Toast.LENGTH_LONG).show(); } return super.onTouchEvent(event); } }페인트 객체는 그래픽을 그리기 위해 필요한 속성을 담고 있다.Paint 자료형으로 된 변수를 하나 선언하고 init 메서드 안에서 객체를 생성한다.onDraw 메서드는 뷰가 화면에 그려질 때 자동으로 호출된다.따라서 뷰에 그래픽을 그리기 위해서는 onDraw 메서드 안에서 재정의하여 사용한다onTouchEvent 메서드는 터치 이벤트를 처리하는 일반적인 방법을 제공한다.onTouchEvent 메서드 또한 부모 클래스인 View 클래스의 것을 재정의하여 사용한다.MainActivity.javapublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); CustomView view = new CustomView(this); setContentView(view); } }결과그래픽을 그릴 때 필요한 클래스와 메서드 클래스 설명 캔버스(Canvas) 뷰의 표면에 직접 그릴 수 있도록 만들어 주는 객체로 그래픽 그리기를 위한 메서드가 정의 되어 있다. 페인트(Paint) 그래픽 그리기를 위해 필요한 색상 등의 속성을 담고 있다. 비트맵(bitmap) 픽셀로 구성된 이미지로 메모리에 그래픽을 그리는 데 사용한다. 드러어블 객체(Drawable) 사각형, 이미지 등의 그래픽 요소가 객체로 정의되어 있다. 여러가지 도형 그리기MainActivity.javapublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); CustomViewStyle view = new CustomViewStyle(this); setContentView(view); } }CustomViewStyle.java public class CustomViewStyle extends View { Paint paint; public CustomViewStyle(Context context) { super(context); init(context); } public CustomViewStyle(Context context, @Nullable AttributeSet attrs) { super(context, attrs); init(context); } private void init(Context context){ paint = new Paint(); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); paint.setStyle(Paint.Style.FILL); // 첫 번째 사각형을 Fill 스타일로 설정 paint.setColor(Color.RED); canvas.drawRect(10, 10, 100, 100, paint); paint.setStyle(Paint.Style.STROKE); // 두 번째 사각형을 Stroke 스타일로 설정하고 PathEffect 적용 paint.setStrokeWidth(2.0F); // 선의 두께 paint.setColor(Color.GREEN); canvas.drawRect(10, 10, 100, 100, paint); paint.setStyle(Paint.Style.FILL); paint.setARGB(120, 0, 0, 255); // 투명도 설정 canvas.drawRect(120, 10, 210, 100, paint); // 점선으로 그리고 싶을 경우에 사용 DashPathEffect dashEffect = new DashPathEffect(new float[]{5,5}, 1); paint.setStyle(Paint.Style.STROKE); paint.setStrokeWidth(3.0F); paint.setPathEffect(dashEffect); paint.setColor(Color.GREEN); canvas.drawRect(120, 10, 210, 100, paint); paint = new Paint(); paint.setColor(Color.MAGENTA); // 첫 번째 원에 색상 적용 canvas.drawCircle(50,160,40,paint); paint.setAntiAlias(true); // 두 번째 원에 AntiAlias (선을 부드럽게) canvas.drawCircle(160,160,40,paint); paint.setStyle(Paint.Style.STROKE); // 첫 번째 텍스트를 Stroke 스타일로 설정 paint.setStrokeWidth(1); paint.setColor(Color.MAGENTA); paint.setTextSize(30); canvas.drawText(&quot;Text (Stroke)&quot;,20,260,paint); paint.setStyle(Paint.Style.FILL); paint.setTextSize(30); canvas.drawText(&quot;Text&quot;, 20, 320, paint); } }결과" }, { "title": "백준 Sport Climbing Combined (23246)", "url": "/posts/back-23246/", "categories": "PS, Sort", "tags": "backjoon, sort", "date": "2022-01-29 02:11:00 +0900", "snippet": "백준 Sport Climbing Combined (23246)단순 정렬 문제 입니다. 백준 Sport Climbing Combined import java.util.*;import java.io.*;class Player { public int sum; public int div; public int num; Player(Scanner sc) { this.num = sc.nextInt(); int lead = sc.nextInt(); int speed = sc.nextInt(); int bolder = sc.nextInt(); this.div = lead * speed * bolder; this.sum = lead + speed + bolder; }}public class Main { public static void main(String[] args) throws IOException { Scanner sc = new Scanner(System.in); // 참가 선수 인원 int n = sc.nextInt(); // 선수들의 정보가 담겨있는 배열 Player p[] = new Player[n]; // 선수들 정보 입 for (int i = 0; i &amp;lt; n; i++) p[i] = new Player(sc); for (int i = 0; i &amp;lt; n - 1; i++) { for (int j = 0; j &amp;lt; n - 1 - i; j++) { Player tmp; if (p[j].div == p[j + 1].div) { // 만약 곱이 같으 if (p[j].sum == p[j + 1].sum) { // 합도 같으면 등번호가 낮은 선수가 이김 if (p[j].num &amp;lt; p[j + 1].num) { tmp = p[j]; p[j] = p[j + 1]; p[j + 1] = tmp; } } else { if (p[j].sum &amp;lt; p[j + 1].sum) { tmp = p[j]; p[j] = p[j + 1]; p[j + 1] = tmp; } } } else { if (p[j].div &amp;lt; p[j + 1].div) { tmp = p[j]; p[j] = p[j + 1]; p[j + 1] = tmp; } } } } System.out.println(p[n - 1].num + &quot; &quot; + p[n - 2].num + &quot; &quot; + p[n - 3].num); }}" }, { "title": "백준 회의실 배정 (1931)", "url": "/posts/back-1931/", "categories": "PS, Greedy", "tags": "backjoon, greedy", "date": "2022-01-29 02:04:00 +0900", "snippet": "백준 회의실 배정 (1931) 백준 회의실 배정 그리디 문제이다.커스텀 정렬을 이용하여 문제를 해결하였다.import java.io.*; import java.util.*; class Metting implements Comparable&amp;lt;Metting&amp;gt;{ public int start; public int end; public Metting(int start, int end) { this.start = start; this.end = end; } // 이른 종료시간 우선 정렬 @Override public int compareTo(Metting mt) { return (this.end == mt.end) ? this.start - mt.start : this.end - mt.end; } } public class Main { public static void main(String[] args) throws NumberFormatException, IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); Metting rooms[] = new Metting[Integer.parseInt(br.readLine())]; int count = 0; for(int i=0; i&amp;lt;rooms.length; i++) { StringTokenizer st = new StringTokenizer(br.readLine()); rooms[i] = new Metting(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken())); } int time = 0; // 현재 시간 Arrays.sort(rooms); for(int i=0; i&amp;lt;rooms.length; i++) { if(time &amp;lt;= rooms[i].start) { // 회의실을 사용할 수 있으면 count ++; // 사용할 수 있는 회의 수 증가 time = rooms[i].end; // 현재시간을 회의 끝나는 시간으로 } } System.out.println(count); } }" }, { "title": "백준 설탕 배달 (2839)", "url": "/posts/back-2839/", "categories": "PS, Greedy", "tags": "backjoon, greedy", "date": "2022-01-29 01:42:00 +0900", "snippet": "백준 설탕 배달 (2839) 백준 설탕배달 전형적인 그리디 문제이다.대학교 갓 들어와서 c언어 배울 때 이 문제를 3일동안 머리 싸매고 풀었던 기억이 있는데알고리즘을 공부하고 그리디 개념을 알고나서 보니 엄청 쉬운 문제import java.io.*; public class Main { public static void main(String[] args) throws NumberFormatException, IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int ans = 0; while(n&amp;gt;=0) { if(n % 5 ==0) { ans += (n/5); System.out.println(ans); return; } n -= 3; ans++; } System.out.println(&quot;-1&quot;); } }" }, { "title": "Cotent Provider 이용하여 연락처 가져오기", "url": "/posts/Contacts/", "categories": "Android, Database", "tags": "anroid, database, contentprovider", "date": "2022-01-29 00:43:00 +0900", "snippet": "연락처 가져오기MainActivity.javapublic class MainActivity extends AppCompatActivity { TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ chooseContacts(); } }); } public void chooseContacts(){ // 연락처 화면을 띄우기 위한 인텐트 Intent contactPickerIntent = new Intent(Intent.ACTION_PICK, ContactsContract.Contacts.CONTENT_URI); startActivityForResult(contactPickerIntent, 101); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data){ super.onActivityResult(requestCode, resultCode, data); if(resultCode == RESULT_OK){ if(requestCode == 101){ try{ Uri contactsUri = data.getData(); // 선택한 연락처 id값 확인하기 String id = contactsUri.getLastPathSegment(); getContacts(id); }catch (Exception e){ e.printStackTrace(); } } } } public void println(String data){ textView.append(data + &quot;\\n&quot;); } public void getContacts(String id){ Cursor cursor = null; String name =&quot;&quot;; try{ // ContentResolver 객체의 query 메서드 호출하기 cursor = getContentResolver().query(ContactsContract.Data.CONTENT_URI, null, ContactsContract.Data.CONTACT_ID + &quot;=?&quot;, new String[] { id}, null); if(cursor.moveToFirst()){ name = cursor.getString(cursor.getColumnIndex(ContactsContract.Data.DISPLAY_NAME)); println(&quot;Name : &quot; + name); String columns[] = cursor.getColumnNames(); for(String column : columns){ int index = cursor.getColumnIndex(column); String columnOutput = (&quot;#&quot; + index + &quot; -&amp;gt; [&quot; + column + &quot;]&quot; + cursor.getString(index)); println(columnOutput); } cursor.close(); } }catch(Exception e){ e.printStackTrace(); } } }onActivityResult 란 ? 액티비티에는 main이 있고 sub가 있다. main액티비티에서 sub액티비티를 호출하여 넘어갔다가, 다시 main 액티비티로 돌아올때 사용되는 기본 메소드 이다.sub액티비티에서 뒤로가기 버튼을 만들던 핸드폰 내에있는 뒤로가기 버튼을 누르던 onActivityResult() 메소드는 실행이 된다.인텐트 객체를 만들 때 첫 번째 매개 변수로 Intent.ACTION_PICK이라는 액션 정보를 전달하는데 이것은 데이터로부터 아이템을 선택하고 선택한 아이템을 리턴시키라는 액션이다.그리고 두 번째 매개 변수는 연락처 정보를 조회하는데 사용하는 URI 값이다.startActivityForReuslt 메서드가 호출되면 연락처를 선택할 수 있는 화면이 표시된다.이 메서드로 전달되는 인텐트 객체의 getData 메서드를 호출하면 선택된 연락처 정보를 가르키는 Uri 객체가 반환된다.getLastPathSegment 메서드는 Uri 객체의 id 값을 확인하는데 사용된다.id 값을 확인하는 이유는 선택한 연락처의 상세 정보가 다른 곳에 저장되어 있기 때문이다.getContacts 메서드를 호출하면서 id값을 매개 변수로 전달하고 getContacts 메서드를 추가한다.getContacts 안에서는 ContentResolver 객체의 query 메서드를 호출한다.query 메서드의 첫 번째 매개 변수로는 ContactsContract.Data.CONTENT_URI를 전달한다. 이 Uri 값은 앞에서 인텐트를 만들 때 넣어 주었던 Uri 값과는 다르다.왜냐하면 이 Uri 값은 연락처의 상세 정보를 조회하는데 사용되는 Uri이다.세 번째 매개 변수로는 id 칼럼의 이름과 함께 =? 라는 글자를 붙여서 전달하였다. 연락처의 상세 정보를 저장하는 테이블에는 많은 칼럼들이 있는데 그 칼럼의 이름 중에서 id 칼럼의 이름은 ContactsContract.Data.CONTACT_ID 상수로 확인할 수 있다.연락처를 조회 하려면 READ_CONTACTS와 WRITE_CONTACTS 권한이 필요하다.매니페스트 파일을 열고 이 두개의 권한을 추가한다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.contacts&quot;&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&amp;gt; .... &amp;lt;/manifest&amp;gt;결과" }, { "title": "Cotent Provider 이용하여 앨범 사진 가져오기", "url": "/posts/getAlbum/", "categories": "Android, Database", "tags": "anroid, database, contentprovider", "date": "2022-01-28 23:54:00 +0900", "snippet": "앱 제공자를 이용한 앨범과 연락처 조회하기MainActivity.javapublic class MainActivity extends AppCompatActivity { ImageView imageView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView = findViewById(R.id.imageView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ openGallery(); } }); } public void openGallery(){ Intent intent = new Intent(); intent.setType(&quot; image/*&quot;); intent.setAction(Intent.ACTION_GET_CONTENT); startActivityForResult(intent, 101); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data){ super.onActivityResult(requestCode, resultCode, data); if(requestCode == 101){ if(resultCode == RESULT_OK){ Uri fileUri = data.getData(); ContentResolver resolver = getContentResolver(); try{ // ContentResolver 객체의 openInoutStream 메서드로 파일 읽어 들이기 InputStream instream = resolver.openInputStream(fileUri); Bitmap imgBitmap = BitmapFactory.decodeStream(instream); imageView.setImageBitmap(imgBitmap); instream.close(); }catch(Exception e){ e.printStackTrace(); } } } } }openGallery 메서드 안에서는 인텐트 객체를 하나 만들고 Intent.ACTION_GET_CONTENT라는 액션 정보를 설정한다. setType 메서드를 이용해 image/*라는 값을 설정한다. 이렇게 하면 MIME 타입이 image로 시작하는 데이터를 가져오라는 의미이다.startActivityForResult 메서드를 호출하면서 이 인텐트 객체를 파라미터로 전달하면 앨범에서 사진을 선택할 수 있는 화면을 띄워주게 된다.이미지 파일은 보통 SD 카드에 저장 되므로 매니페스트 파일에 READ_EXTERNAL_STORAGE와 WRITE_EXTERNAL_STORAGE 권한을 추가한다.이 권한은 위험 권한이므로 위험 권한을 부여하기 위한 코드를 추가한다.AndroidMainfest.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.album&quot;&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&amp;gt; &amp;lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; ....결과" }, { "title": "Content Provider", "url": "/posts/ContentProvider/", "categories": "Android, Database, AppComponents", "tags": "anroid, database, contentprovider", "date": "2022-01-27 17:24:00 +0900", "snippet": "Content ProviderContent Provider는 내용 제공자라고 부르며, 한 앱에서 관리하는 데이터를 다른 앱에서 접근할 수 있도록 해준다.쉽게 말해서 응용 프로그램끼리 데이터를 공유하는 유일한 방법이다.내용 제공자도 앱 구성요소이기 때문에 시스템에서 관리하며 매니페스트 파일에 등록해야 사용할 수 있다.다른 사람이 만든 앱이 나의 앱 데이터를 마음대로 바꾸면 안되므로 내용 제공자가 필요하다.그래서 각 앱은 자신의 프로세스와 권한 안에서만 데이터를 접근할 수 있도록 되어 있다.즉, A라는 앱과 B라는 앱은 각각 독립된 프로세스를 가지고 있으며 A는 A의 데이터를,B는 B의 데이터만 사용해야 한다.하지만 가끔 서로 다른 앱의 데이터에 접근해야 하는 경우 내용 제공자를 사용하면 된다.내용 제공자를 사용하면 다른 앱에게 데이터를 접근 통로를 열어 줄 수 있다.주의해야 할 점은 반드시 허용된 통로로만 접근해야 한다는 것이다.내용 제공자에서 공유할 수 있는 데이터는 아래와 같다. 데이터 베이스 파일 SharedPreferences위의 세가지 중 데이터베이스에 접근하는 것이 가장 일반적이다.왜냐하면 내용 제공자는 CRUD 동작을 기준으로 하고 있기 때문이다.CRUD란 데이터를 생성(Create), 조회(Read), 수정(Update), 삭제(Delete) 하는 과정을말하며 내용 제공자는 CRUD에 대응되는 insert, query, update, delete 메서드를 지원한다.내용 제공자에서 허용한 통로로 접근하려면 콘텐트 리졸버(ContentResolver)객체가 필요하다.예제앱 화면 레이아웃 구성도activity_main.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot; &amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&amp;gt; &amp;lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:text=&quot;insert&quot; /&amp;gt; &amp;lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:text=&quot;query&quot; /&amp;gt; &amp;lt;Button android:id=&quot;@+id/button3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:text=&quot;update&quot; /&amp;gt; &amp;lt;Button android:id=&quot;@+id/button4&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:text=&quot;delete&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;ScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/holo_blue_bright&quot;&amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;20sp&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/ScrollView&amp;gt; &amp;lt;/LinearLayout&amp;gt;MainActivity.javapublic class MainActivity extends AppCompatActivity { TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { insertPerson(); } }); Button button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { queryPerson(); } }); Button button3 = findViewById(R.id.button3); button3.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { updatePerson(); } }); Button button4 = findViewById(R.id.button4); button4.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { deletePerson(); } }); } public void insertPerson() { println(&quot;insertPerson 호출됨&quot;); String uriString = &quot;content://org.techtown.provider/person&quot;; Uri uri = new Uri.Builder().build().parse(uriString); Cursor cursor = getContentResolver().query(uri, null, null, null, null); String[] columns = cursor.getColumnNames(); println(&quot;columns count -&amp;gt; &quot; + columns.length); for (int i = 0; i &amp;lt; columns.length; i++) { println(&quot;#&quot; + i + &quot; : &quot; + columns[i]); } ContentValues values = new ContentValues(); values.put(&quot;name&quot;, &quot;john&quot;); values.put(&quot;age&quot;, 20); values.put(&quot;mobile&quot;, &quot;010-1000-1000&quot;); uri = getContentResolver().insert(uri, values); println(&quot;insert 결과 -&amp;gt; &quot; + uri.toString()); } public void queryPerson() { try { String uriString = &quot;content://org.techtown.provider/person&quot;; Uri uri = new Uri.Builder().build().parse(uriString); String[] columns = new String[] {&quot;name&quot;, &quot;age&quot;, &quot;mobile&quot;}; Cursor cursor = getContentResolver().query(uri, columns, null, null, &quot;name ASC&quot;); println(&quot;query 결과 : &quot; + cursor.getCount()); int index = 0; while(cursor.moveToNext()) { String name = cursor.getString(cursor.getColumnIndex(columns[0])); int age = cursor.getInt(cursor.getColumnIndex(columns[1])); String mobile = cursor.getString(cursor.getColumnIndex(columns[2])); println(&quot;#&quot; + index + &quot; -&amp;gt; &quot; + name + &quot;, &quot; + age + &quot;, &quot; + mobile); index += 1; } } catch(Exception e) { e.printStackTrace(); } } public void updatePerson() { String uriString = &quot;content://org.techtown.provider/person&quot;; Uri uri = new Uri.Builder().build().parse(uriString); String selection = &quot;mobile = ?&quot;; String[] selectionArgs = new String[] {&quot;010-1000-1000&quot;}; ContentValues updateValue = new ContentValues(); updateValue.put(&quot;mobile&quot;, &quot;010-2000-2000&quot;); int count = getContentResolver().update(uri, updateValue, selection, selectionArgs); println(&quot;update 결과 : &quot; + count); } public void deletePerson() { String uriString = &quot;content://org.techtown.provider/person&quot;; Uri uri = new Uri.Builder().build().parse(uriString); String selection = &quot;name = ?&quot;; String[] selectionArgs = new String[] {&quot;john&quot;}; int count = getContentResolver().delete(uri, selection, selectionArgs); println(&quot;delete 결과 : &quot; + count); } public void println(String data) { textView.append(data + &quot;\\n&quot;); } }DatabaseHelper.javapublic class DatabaseHelper extends SQLiteOpenHelper { private static final String DATABASE_NAME = &quot;person.db&quot;; private static final int DATABASE_VERSION = 1; public static final String TABLE_NAME = &quot;person&quot;; public static final String PERSON_ID = &quot;_id&quot;; public static final String PERSON_NAME = &quot;name&quot;; public static final String PERSON_AGE = &quot;age&quot;; public static final String PERSON_MOBILE = &quot;mobile&quot;; public static final String[] ALL_COLUMNS = {PERSON_ID, PERSON_NAME,PERSON_AGE,PERSON_MOBILE}; private static final String CREATE_TABLE = &quot;CREATE TABLE &quot; + TABLE_NAME + &quot; (&quot; + PERSON_ID + &quot; INTEGER PRIMARY KEY AUTOINCREMENT, &quot; + PERSON_NAME + &quot; TEXT, &quot; + PERSON_AGE + &quot; INTEGER, &quot; + PERSON_MOBILE + &quot; TEXT&quot; + &quot;)&quot;; public DatabaseHelper(Context context) { super(context, DATABASE_NAME, null, DATABASE_VERSION); } @Override public void onCreate(SQLiteDatabase db) { db.execSQL(CREATE_TABLE); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { db.execSQL(&quot;DROP TABLE IF EXISTS &quot;+ TABLE_NAME); onCreate(db); } }PersonProvider.javapublic class PersonProvider extends ContentProvider { private static final String AUTHORITY = &quot;org.techtown.provider&quot;; private static final String BASE_PATH = &quot;person&quot;; public static final Uri CONTENT_URI = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/&quot; + BASE_PATH ); private static final int PERSONS = 1; private static final int PERSON_ID = 2; private static final UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); static { uriMatcher.addURI(AUTHORITY, BASE_PATH, PERSONS); uriMatcher.addURI(AUTHORITY, BASE_PATH + &quot;/#&quot;, PERSON_ID); } private SQLiteDatabase database; @Override public boolean onCreate() { DatabaseHelper helper = new DatabaseHelper(getContext()); database = helper.getWritableDatabase(); return true; } @Nullable @Override public Cursor query(Uri uri, String[] strings, String s, String[] strings1, String s1) { Cursor cursor; switch (uriMatcher.match(uri)) { case PERSONS: cursor = database.query(DatabaseHelper.TABLE_NAME, DatabaseHelper.ALL_COLUMNS, s,null,null,null,DatabaseHelper.PERSON_NAME +&quot; ASC&quot;); break; default: throw new IllegalArgumentException(&quot;알 수 없는 URI &quot; + uri); } cursor.setNotificationUri(getContext().getContentResolver(), uri); return cursor; } @Nullable @Override public String getType(Uri uri) { switch (uriMatcher.match(uri)) { case PERSONS: return &quot;vnd.android.cursor.dir/persons&quot;; default: throw new IllegalArgumentException(&quot;알 수 없는 URI &quot; + uri); } } @Nullable @Override public Uri insert(Uri uri, ContentValues contentValues) { long id = database.insert(DatabaseHelper.TABLE_NAME, null, contentValues); if (id &amp;gt; 0) { Uri _uri = ContentUris.withAppendedId(CONTENT_URI, id); getContext().getContentResolver().notifyChange(_uri, null); return _uri; } throw new SQLException(&quot;추가 실패 -&amp;gt; URI :&quot; + uri); } @Override public int delete(Uri uri, String s, String[] strings) { int count = 0; switch (uriMatcher.match(uri)) { case PERSONS: count = database.delete(DatabaseHelper.TABLE_NAME, s, strings); break; default: throw new IllegalArgumentException(&quot;알 수 없는 URI &quot; + uri); } getContext().getContentResolver().notifyChange(uri, null); return count; } @Override public int update(Uri uri, ContentValues contentValues, String s, String[] strings) { int count = 0; switch (uriMatcher.match(uri)) { case PERSONS: count = database.update(DatabaseHelper.TABLE_NAME, contentValues, s, strings); break; default: throw new IllegalArgumentException(&quot;알 수 없는 URI &quot; + uri); } getContext().getContentResolver().notifyChange(uri, null); return count; } }내용 제공자를 만들기 위해서는 고유한 값을 가진 content URI를 만들어야 한다.위에서는 앱의 패키지 이름과 person 테이블의 이름을 합쳐 content URI를 정의했다.content URI를 정의하는 형식은 다음과 같다. content://org.techtown.provider/person/1 content:// -&amp;gt; 내용 제공자에 의해 제어되는 데이터라는 의미로 항상 content://로 시작Authority -&amp;gt; org.techtown.provider 부분을 가르키며 특정 내용 제공자를 구분하는 고유한 값Base Path -&amp;gt; person 부분을 가르키며 요청할 데이터의 자료형을 결정함 (위에서는 테이블 이름)ID -&amp;gt; 맨 뒤의 1과 같은 숫자를 가르키며 요청할 데이터 레코드를 지정함PersonProvider 클래스에는 insert, query, update, delete 메서드가 정의되어 있다.UriMatcher 객체는 URI를 매칭하는데 사용된다.match 메서드를 호출하면 UriMatcher에 addURI 메서드를 이용해 추가된 URI 중에서 실행 가능한 것이 있는지 확인해준다.그리고 내용 제공자에 접근하기 위해 ContentResolver 객체도 사용된다.액티비티에서 getContentResolver 메서드를 호출하면 ContentResolvoer객체를 반환한다이 객체는 query, insert, update, delete 등의 메서드가 정의되어 있어 내용 제공자의 URI를 매개변수로 전달하면서 데이터를 조회, 추가, 수정, 삭제 등을 할 수 있다.notifiyChange 메서드는 레코드가 추가, 수정, 삭제되었을 때 변경이 일어났음을 알려주는 역할을 한다.내용 제공자를 이용해 값을 조회하고 싶으면 아래와 같은 query 메서드를 사용한다.Cursor query(Uri uri, String[] projection//어떤 칼럼들을 조회할지 지정(null 모든 칼럼 조회) String selection, // SQL에서 where 절에 들어갈 조건을 지정 // 세 번째 파라미터가 있을 경우 그 안에 들어갈 조건 값을 대체하기 위해 사용 String[] selectionArgs, String sortOrder // 정렬 칼럼을 지정하고, null이면 정렬 x )내용 제공자를 위해 값을 추가하고 싶다면 다음과 같은 insert 메서드를 사용한다.Uri insert(Uri uri, CotentValues values )첫 번째 파라미터는 URI이고 두번째 파라미터는 저장할 칼럼명과 값들이 들어간 ContentValues 객체이다.ContentValues는 ContentResolver가 사용하는 데이터 운송 수단이다.결과 값으로는 새로 추가된 값의 Uri 정보가 반환된다.내용 제공자를 이용해 값을 수정하고 싶다면 다음과 같은 updata 메서드 사용int update(Uri uri, ContentValues values, String selection, String[] selectionArgs )첫 번째 매개 변수는 URI이고, 두 번째 매개변수 저장할 칼럼명과 값들이 들어간 ContentValues 객체이다. 이 값은 null이 되면 안되니까 주의하자.세 번째 매개변수는 SQL에서 where 절에 들어갈 조건을 지정한다.네 번째 매개변수는 세 번째 매개 변수 값이 있을 경우 그 안에 들어갈 조건 값을 대체하기 위해 사용된다.내용 제공자를 이해하고 삭제하고 싶다면 다음과 같은 delete 메서드를 사용한다.int delete(Uri uri, String selection, String[] selectionArgs )결과 값으로 영향을 받은 레코드의 개수를 반환한다.getType메서드는 MIME 타입이 무엇인지를 알고 싶을 때 사용한다.MIME 타입이란 Multipurpose Internet Mail Extension의 약자로, 파일 변환을 위한 포맷이다.MIME은 이메일에 첨부된 파일을 텍스트 문자 형태로 변환해서 이메일과 함께 전송하기 위해 개발된 포맷이다.인제 매니페스트 파일에 내용 제공자를 등록 하자.AndroidManifest.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.provider&quot;&amp;gt; &amp;lt;permission android:name=&quot;org.techtown.provider.READ_DATABASE&quot; android:protectionLevel=&quot;normal&quot; /&amp;gt; &amp;lt;permission android:name=&quot;org.techtown.provider.WRITE_DATABASE&quot; android:protectionLevel=&quot;normal&quot; /&amp;gt; &amp;lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.SampleProvider&quot;&amp;gt; &amp;lt;activity android:name=&quot;.MainActivity&quot; android:exported=&quot;true&quot;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt; &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;/activity&amp;gt; &amp;lt;provider android:authorities=&quot;org.techtown.provider&quot; android:name=&quot;.PersonProvider&quot; android:exported=&quot;true&quot; android:readPermission=&quot;org.techtown.provider.READ_DATABASE&quot; android:writePermission=&quot;org.techtown.provider.WRITE_DATABASE&quot; /&amp;gt; &amp;lt;/application&amp;gt; &amp;lt;/manifest&amp;gt;결과여기에서는 내용 제공자를 정의한 앱에서 데이터를 추가하고 조회했지만 다른 앱에서도 내용 제공자를 이용하면 이 앱에서 관리하는 데이터를 조회할 수 있게 된다.정리Content Resolver폰 안에 여러 앱, 여러 프로바이더가 있기 때문에 이들을 관리하고 흐름을 통제. 앱이 접근하고자 하는 프로바이더 사이에서 중개자 역할.query(읽기), insert, update, delete 작업이 가능." }, { "title": "DB 데이터 조회하기", "url": "/posts/SearchDB/", "categories": "Android, Database", "tags": "anroid, database, cursor", "date": "2022-01-27 02:11:00 +0900", "snippet": "데이터 조회하기MainActivity.javapublic class MainActivity extends AppCompatActivity { EditText editText; EditText editText2; TextView textView; DatabaseHelper dbHelper; SQLiteDatabase database; String tableName; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText = findViewById(R.id.editText); editText2 = findViewById(R.id.editText2); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { String databaseName = editText.getText().toString(); createDatabase(databaseName); } }); Button button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { tableName = editText2.getText().toString(); createTable(tableName); insertRecord(); } }); Button button3 = findViewById(R.id.button3); button3.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { executeQuery(); } }); } private void createDatabase(String name) { println(&quot;createDatabase 호출됨.&quot;); dbHelper = new DatabaseHelper(this); database = dbHelper.getWritableDatabase(); println(&quot;데이터베이스 생성함 : &quot; + name); } private void createTable(String name) { println(&quot;createTable 호출됨.&quot;); if (database == null) { println(&quot;데이터베이스를 먼저 생성하세요.&quot;); return; } database.execSQL(&quot;create table if not exists &quot; + name + &quot;(&quot; + &quot; _id integer PRIMARY KEY autoincrement, &quot; + &quot; name text, &quot; + &quot; age integer, &quot; + &quot; mobile text)&quot;); println(&quot;테이블 생성함 : &quot; + name); } private void insertRecord() { println(&quot;insertRecord 호출됨.&quot;); if (database == null) { println(&quot;데이터베이스를 먼저 생성하세요.&quot;); return; } if (tableName == null) { println(&quot;테이블을 먼저 생성하세요.&quot;); return; } database.execSQL(&quot;insert into &quot; + tableName + &quot;(name, age, mobile) &quot; + &quot; values &quot; + &quot;(&#39;John&#39;, 20, &#39;010-1000-1000&#39;)&quot;); println(&quot;레코드 추가함.&quot;); } public void println(String data) { textView.append(data + &quot;\\n&quot;); } public void executeQuery() { println(&quot;executeQuery 호출됨.&quot;); // SQL 실행하고 Cursor 객체 반환하기 Cursor cursor = database.rawQuery(&quot;select _id, name, age, mobile from emp&quot;, null); int recordCount = cursor.getCount(); println(&quot;레코드 개수 : &quot; + recordCount); for (int i = 0; i &amp;lt; recordCount; i++) { cursor.moveToNext(); // 다음 결과 레코드로 넘어가기 int id = cursor.getInt(0); String name = cursor.getString(1); int age = cursor.getInt(2); String mobile = cursor.getString(3); println(&quot;레코드 #&quot; + i + &quot; : &quot; + id + &quot;, &quot; + name + &quot;, &quot; + age + &quot;, &quot; + mobile); } cursor.close(); }}표준 SQL은 데이터를 조회하기 select 구문을 사용하게 되는데 이 구문을 통해 반환되는 Cursor 객체를받기 위해 rawQuery 메서드를 실행한다.rawQuery는 결과 값으로 Cursor 객체를 받을 수 있는 SQL 실행 방법이다.APIpublic Cursor rawQuery (String sql, Sting [] selectionArgs)Cursor 객체는 결과 테이블에 들어있는 각각의 레코드를 순서대로 접근할 수 있는 방법을 제공한다.Cursor 객체는 처음에 아무런 레코드를 가르키지 않으며, moveToNext 메서드를 이용해 그 다음 레코드를가르키도록 해야 레코드 값을 가져올 수 있다.보통 while 구문을 이용해 moveToNext가 false 값을 반환할 때 까지 레코드 값을 가져오는 방법을 사용한다.Cursor APIcursor를 사용하고 close 메서드를 이용하여 닫아 줘야 한다.결과데이터 베이스를 사용할 때 기억해야 할 것 순서 내용 사용 메서드 1. 데이터베이스 만들기 데이터베이스를 만들면 SQLiteDatabase 객체 반환 openOrCreateDatabase() 2. 테이블 만들기 ‘CREATE TABLE …’ SQL을 정의한 후 실행함 execSQL() 3. 레코드 추가하기 ‘INSERT INTO …’ SQL을 정의한 후 실행함 execSQL() 4. 데이터 조회하기 ‘SELECT FROM …’ SQL을 정의한 후 실행함 Cursor 객체가 반환되며 Cursor를 통해 확인한 레코드를 리스트뷰 등에 표시함 rawQuery() " }, { "title": "SQLiteOpenHelper", "url": "/posts/SQLiteOpenHelper/", "categories": "Android, Database", "tags": "anroid, database, sqlliteopenhelper", "date": "2022-01-26 19:02:00 +0900", "snippet": "SQLiteOpenHelper란?많은 수의 사용자가 사용하고 있어 저장된 데이터의 양이 많을 때, 테이블을 수정하려면 어떻게 해야 할까?사용중인 테이블의 column을 수정하거나 테이블을 삭제하는 것은 어려운 작업이다.SQLiteOpenHelper는 이런 상황에서 테이블의 수정, 삭제를 도와준다.새로운 기능을 앱에 추가하려 테이블 구조와 코드를 수정했는데,사용자가 앱을 업데이트 하지 않았다면 수정된 테이블과테이블에 접근하는 코드가 맞지 않아 오류가 발생할 수 있다.이 때 SQLiteOpenHelper를 통해 버전 관리를 해 코드 상태에 맞춰 db 구조를 변경할 수 있다.예를 들어 DB와 소스코드를 모두 version1에서 version2로 수정했을 때,SQLiteOpenHelper를 통해 현재 코드 버전이 version1이라면 DB를 version2로 수정하지 않고,현재 코드 버전이 version2일 때에만 DB를 version2로 수정하도록 구현할 수 있다.헬퍼 클래스로 업그레이드 지원하기SQLiteOpenHelper 클래스는 데이터베이스를 만들거나 열기 위해 필요한 작업들을 도와주는 역할을 한다.SQLiteOpenHelper 객체는 new 연산자로 만들며 생성자에 들어가는 매개 변수는 다음과 같다.APIpublic SQLiteOpenHelper (Context context, String name, SQLiteDatabase.CursorFactory factory, int version)첫 번째 매개변수는 Context 객체이므로 액티비티 안에서 만들 경우 this로 지정할 수 있다.두 번째 매개변수는 데이트베이스 이름이며,세 번째 매개변수는 데이터 조회 시 반환하는 CursorFactory 객체이다.네 번째 매개변수로 전달되는 정수 타입의 버전 정보는 데이터 베이스 업그레이드를 위해 사용하며,기존에 생성되어 있는 데이터베이스의 버전 정보와 다르게 지정하여 데이터베이스의 스키마나 데이터를 바꿀 수 있다.SQLiteOpenHelper 객체는 데이터베이스를 만들거나 열기 위해 필요한 작업을 도와주는 역할을 한다고 했다.하지만, SQLiteHelper 객체를 만든다고 데이터베이스 파일이 바로 만들어지는 것이 아니고getReadableDatabase 또는 getWriteableDatabase 메서드를 호출해야 한다.이 SQLiteOpenHelper 이용하면 데이터베이스 생성, 업그레이드 등 여러 가지 상태에 따라 콜백 메서드를재정의하면 각각의 상태에 맞게 처리할 수 있다는 장점이 있다.APIpublic abstract void onCreate (SQLiteDatabase db)public abstract void onOpen(SQLiteDatabase db)public abstract void onUpgrade (SQLiteDatabase db, int oldVersion, int newVersion)현재의 데이터베이스 버전이 이미 사용하고 있는 SQLiteDatabase 파일의 버전과 다를 경우에 자동으로 호출되는onUpgrade 메서드에 SQLiteDatabase 객체와 함께 기존 버전 정보를 담고 있는 oldVersion, 현재 정보를 담고 있는newVersion 파라미터가 전달된다.헬퍼 클래스로 새로운 데이터 베이스를 구성할 때 사용하는 전형적인 구조 [출처] Do it ! 안드로이드 프로그래밍헬퍼 클래스 정의 해보기DatabaseHelper.javapublic class DatabaseHelper extends SQLiteOpenHelper { public static String NAME = &quot;employee.db&quot;; public static int VERSION = 1; public DatabaseHelper(Context context){ super(context, NAME, null, VERSION); } public void onCreate(SQLiteDatabase db){ println(&quot;onCreate 호출됨&quot;); String sql = &quot;create table if not exists emp(&quot; + &quot; _id integer PRIMARY KEY autoincrement, &quot; + &quot; name text, &quot; + &quot; age integer, &quot; + &quot;mobile text)&quot;; db.execSQL(sql); // onCreate 메서드 안에서 SQL문 실행 } public void onOpen(SQLiteDatabase db){ println(&quot;onOpen 호출 됨&quot;); } public void onUpgrade(SQLiteDatabase db, int oldVersoin, int newVersion){ println(&quot;onUpgrade 호출됨: &quot; + oldVersoin + newVersion); if(newVersion &amp;gt; 1) db.execSQL(&quot;DROP TABLE IF EXISTS emp&quot;); } public void println(String data){ Log.d(&quot;DatabaseHelper&quot;, data); }}SQLiteOpenHelper 클래스를 상속한 DatabaseHelper 클래스는 생성자에서 데이터베이스 이름과 버전 정보로상위 클래스의 생성자를 호출한다.데이터베이스를 열 때 호출되는 onOpen, 그리고 데이터베이스를 업그레이드할 때 호출되는 onUpgrade가 구현 되었으며,onCreate 안에서 테이블을 만든다.이렇게 만들어진 헬퍼 클래스는 메인 액티비티에서 데이터베이스를 사용할 경우 코드가더 간단해지는 장점이 있다.MainActivity.javapublic class MainActivity extends AppCompatActivity { EditText editText; EditText editText2; TextView textView; DatabaseHelper dbHelper; SQLiteDatabase database; String tableName; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText = findViewById(R.id.editText); editText2 = findViewById(R.id.editText2); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { String databaseName = editText.getText().toString(); createDatabase(databaseName); } }); Button button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { tableName = editText2.getText().toString(); createTable(tableName); insertRecord(); } }); } private void createDatabase(String name) { println(&quot;createDatabase 호출됨.&quot;); dbHelper = new DatabaseHelper(this); // dbhelper 객체 생성하고 database = dbHelper.getWritableDatabase(); // SQLiteDatabase 객체 참조하기 println(&quot;데이터베이스 생성함 : &quot; + name); } private void createTable(String name) { println(&quot;createTable 호출됨.&quot;); if (database == null) { println(&quot;데이터베이스를 먼저 생성하세요.&quot;); return; } database.execSQL(&quot;create table if not exists &quot; + name + &quot;(&quot; + &quot; _id integer PRIMARY KEY autoincrement, &quot; + &quot; name text, &quot; + &quot; age integer, &quot; + &quot; mobile text)&quot;); println(&quot;테이블 생성함 : &quot; + name); } private void insertRecord() { println(&quot;insertRecord 호출됨.&quot;); if (database == null) { println(&quot;데이터베이스를 먼저 생성하세요.&quot;); return; } if (tableName == null) { println(&quot;테이블을 먼저 생성하세요.&quot;); return; } database.execSQL(&quot;insert into &quot; + tableName + &quot;(name, age, mobile) &quot; + &quot; values &quot; + &quot;(&#39;John&#39;, 20, &#39;010-1000-1000&#39;)&quot;); println(&quot;레코드 추가함.&quot;); } public void println(String data) { textView.append(data + &quot;\\n&quot;); }}결과" }, { "title": "Data base 만들기", "url": "/posts/Database/", "categories": "Android, Database", "tags": "anroid, database", "date": "2022-01-26 17:07:00 +0900", "snippet": "모바일 데이터 베이스란?앱을 만들면서 데이터를 간단하게 저장하고 싶을 때는 SharedPreferences를 사용할 수 있다. 안드로이드에서 기본적으로 제공되는 SharedPreferences는 데이터의 양이 많거나 중요한 데이터라면 서버나 DB, 파일의 형태로 저장을 하면 되지만, 간단한 설정 값이나 문자열 같은 데이터들은 DB에 저장하기에는 부담스러울 경우 사용된다.하지만 많은 양의 데이터를 체계적으로 관리하려면 데이터베이스를 사용해야 한다.특히, SQL 문으로 데이터를 조회하는 관계형 데이터베이스를 휴대 단말에서 사용할 수 있다면적은 양의 데이터라도 접근이 가능하기 때문에 더 효율적이다.안드로이드는 임베디드 데이터베이스(Embedded Database)로 개발된 경량급(Light-weight)관계형 데이터베이스인 SQLite를 가지고 있다.SQLite 데이터베이스는 파일로 만들어진 하위 수준의 구조를 가지면서도,데이터베이스의 기능까지 그대로 사용할 수 있도록 만든 것이다.또한 저장될 때는 파일로 저장되므로 데이터베이스의 복사, 이동, 삭제가 매우 쉽다.SQLite 데이터베이스의 가장 큰 특징은 데이터 조회 속도가 빠르다는 것과 표준 SQL을 지원 한다는 점이다.즉, 기존에 웹이나 PC에서 사용하던 업무용 앱의 데이터 관리 기능을 그대로 사용할 수 있다는 것이다.앱의 생산성이 높아지고 향후 기능을 변경할 때도 간단한 SQL 수정만으로 데이터 처리 방식을 바꿀 수 있다.아래는 일반적인 데이터베이스 활용 순서이다.데이터 베이스와 테이블 만들기데이터베이스는 여러 개의 테이블을 담는 그릇이라고 볼 수 있다.따라서 데이터베이스를 사용하려면 우선 그릇을 만들거나 이미 만들어 놓은 그릇을 열고 닫을 수 있어야 한다.데이터 베이스를 만드는 가장 간단한 방법은 Context 클래스에 정의된 openOrCreateDatabase 메서드를 사용하는 것이다.즉, 앱에서 기본적으로 사용하는 Activity 클래스가 Context를 상속한 것이므로 결국 액티비티를 만들 때그 안에서 openOrCreateDatabase 메서드로 데이터를 만들거나 열 수 있다.또한 삭제하는 메서드인 deleteDatabase도 있다.APIpublic abstract SQLiteDatabase openOrCreateDatabase (String name, int mode, SQLiteDatabase.CursorFactory facroy)public abstract boolean deleteDatabase(String name)openOrCreateDatabase 첫 번째 매개변수는 데이터베이스 이름, 두 번째는 사용모드, 세 번째는 NULL이 아닌 객체를 지정할 경우 쿼리의 결과 값으로 반환되는 데이터를 참조하는 커서를 만들어 낼 수 있는 객체가 전달된다.반환 값은 우리가 지정한 데이터베이스를 접근할 수 있는 데이터 베이스 객체가 반환 되므로 SQLiteDatabase 객체를 참조해야 한다.SQLiteDatabase 객체에서 가장 중요한 메서드 중 하나는 execSQL이다.이 메서드는 데이터 베이스를 만들고 난 다음 SQL문을 실행할 때 사용된다. 따라서, 이 메서드를 사용하면 테이블을 만드는 것 뿐만 아니라 레코드 추가처럼 표준 SQL을 사용하는것처럼데이터 처리가 가능하다.APIpublic void execSQL(String sql) throws SQLExceptionMainActivity.javapublic class MainActivity extends AppCompatActivity { EditText editText; EditText editText2; TextView textView; SQLiteDatabase database; String tableName; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText = findViewById(R.id.editText); editText2 = findViewById(R.id.editText2); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ String databaseName = editText.getText().toString(); createDatabase(databaseName); } }); Button button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ tableName = editText2.getText().toString(); createTable(tableName); insertRecord(); } }); } private void createDatabase(String name){ println(&quot;createDatabase 호출됨.&quot;); // 데이터 베이스 생성 database = openOrCreateDatabase(name,MODE_PRIVATE, null); println(&quot;데이터베이스 생성함: &quot; + name); } private void createTable(String name){ println(&quot;createTable 호출됨.&quot;); if(database == null){ println(&quot;데이터베이스를 먼저 생성하세요.&quot;); return; } // 테이블을 만들기 위한 SQL문 실행하기 database.execSQL(&quot;create table if not exists &quot; + name + &quot;(&quot; + &quot; _id integer PRIMARY KEY autoincrement, &quot; + &quot; name text, &quot; + &quot; age integer, &quot; + &quot; mobile text)&quot;); println(&quot;테이블을 생성함: &quot; + name); } private void insertRecord(){ println(&quot;insertRecord 호출됨.&quot;); if(database == null){ println(&quot;데이터베이스를 먼저 생성하세요.&quot;); return; } if(tableName == null){ println(&quot;테이블을 먼저 생성하세요.&quot;); return; } database.execSQL(&quot;insert into &quot; + tableName + &quot;(name, age, mobile) &quot; + &quot; values &quot; + &quot;( &#39; John &#39;, 20, &#39; 010-1000-1000 &#39; )&quot;); println(&quot;레코드 추가됨&quot;); } public void println(String data){ textView.append(data + &quot;\\n&quot;); }}execSQL 메서드는 SQL문을 매개변수로 전달 받기 때문에 원하는 기능의 SQL을 먼저 정의해야 한다.위에서는 직원 id, 이름, 나이 휴대폰 번호로 정의 하였다.id 같은 경우 안드로이드에서 앞에 ‘_‘를 붙여 ‘_id’로 만드는 방법을 권장하므로 위와 같은 이름을 사용하였다.또한, 자동으로 1씩 증가하는 값(PRIMARY KEY autoincrement)으로 정의하였다.insertRecord 메서드에서 execSQL 메서드로 임의의 데이터 JON, 20 ,010-1000-1000을 삽입한다.SQLite는 각각의 레코드별로 입력되는 데이터 타입을 다르게 넣을 수 있다.아래는 column에 참조용으로 정의할 수 있는 데이터 타입이다. column type 설명 text, varchar 문자열 smallint, integer 정수 (2byte or 4byte) real, float, double 부동소수 (4byte or 8byte boolean true or false data, time, timestamp 시간 (날짜, 시간, 날짜 + 시간) blob,binary 바이너리 결과SQLite는 GUI 기반으로 만들어진 데이터베이스 관리 도구가 있는데, SQLite 의 경우 DB Browser for SQLite관리 도구를 사용할 수 있다. 사이트 바로가기 " }, { "title": "JSON 개념 및 GSON", "url": "/posts/JSON/", "categories": "Android, Network", "tags": "android, network, json, gson", "date": "2022-01-25 14:58:00 +0900", "snippet": "JSONJSON의 약자는 JavaScript Object Notation으로 Javascript 객체 문법으로 구조화된 데이터를 표현하기 위한문자 기반의 표준 포맷이다. 따라서 자바 스크립트 객체 포맷과 거의 동일하다.웹 어플리케이션에서 데이터를 전송할 때 사용하고,서버에서 클라이언트로 데이터를 전송하여 표현 하거나 반대의 경우에 사용한다.Gson은 자바스크립트에서처럼 JSON 문자열을 객체로 변환할 수 있도록 해준다.즉, JSON 문자열이 자바 객체로 만들어 질 수 있다.Volley를 사용해서 웹 서버로부터 JSON 응답을 받았다면 Gson을 이용해서 자바 객체로 바꾸고그 객체 안에 들어있는 데이터를 접근하여 사용할 수 있다.사용하기Gson도 Volley처럼 외부 라이브러리이기 때문에 라이브러리를 추가해야 사용할 수 있다.Gradle Scripts/build.gradle(Moudle: Project Name)dependencies { ... implementation &#39;com.android.volley:volley:1.2.0&#39; implementation &#39;com.google.code.gson:gson:2.8.6&#39;}Gson은 JSON 문자열을 자바 객체로 바꿔주는데 자바는 객체를 만들 때 클래스를 먼저 정의하는 과정을거치므로 JSON 문자열을 자바 객체로 바꿀 때도 클래스를 먼저 정의 해야한다.영화 정보를 가져온다고 가정하고 영화 정보 JSON 응답의 포맷에 맞추어 새로운 자바 클래스를 정의한다.MovieList.javapublic class MovieList { MovieListResult boxOfficeResult;}위의 변수 하나를 선언 했는데 이 변수의 자료형은 JSON 문자열 속성 값의 자료형과 같아야 하고,변수 이름은 JSON 문자열에서 속성의 이름이 같아야 한다.JSON 문자열에서 boxOfficeResult 속성의 값이 객체이므로 이 객체를 변환하여 담아둘 클래스를 선언하는데,MovieListResult 이름으로 추가한다.MovieListResult.javapublic class MovieListResult { String boxofficeType; String showRange; ArrayList&amp;lt;Movie&amp;gt; dailyBoxOfficeList = new ArrayList&amp;lt;Movie&amp;gt;();}또한, ArrayList 배열 안에 다시 객체가 들어가므로 그를 위한 클래스를 추가로 만들어줘야한다.Movie.javapublic class Movie { String rnum; String rank; String rankInten; String rankOldAndNew; String movieCd; String movieNm; String openDt; String salesAmt; String salesShare; String salesInten; String salesChange; String salesAcc; String audiCnt; String audiInten; String audiChange; String audiAcc; String scrnCnt; String showCnt;}참고로 위 문자열들은 영화 진흥 위원회 오픈 API에 명시되어 있는 응답 구조 변수들이다.영화 진흥 위원회 MainActivity.javapublic class MainActivity{ ... 중략 @Override public void onResponse(String response) { println(&quot;응답 -&amp;gt; &quot; + response); processResponse(response); } ... 중략 public void processResponse(String response) { Gson gson = new Gson(); // JSON 문자열을 MovieList 객체로 변환하기 MovieList movieList = gson.fromJson(response, MovieList.class); println(&quot;영화정보의 수 : &quot; + movieList.boxOfficeResult.dailyBoxOfficeList.size()); }}결과" }, { "title": "일별 오피스 데이터 파싱", "url": "/posts/PasingMovieData/", "categories": "Android, Network", "tags": "android, network, volley", "date": "2022-01-25 01:25:00 +0900", "snippet": "영화 정보 가져와 보여주기오픈 API 영화 포스터까지 받아 오고 싶으면 문화 진흥회 오픈 API 를 이용하면 되지만 밑의 데이터 파싱 방법과는 다른 것 같음.포스터 이미지 받아와서 이미지 뷰에 설정하려면 피카소 외부 라이브러리 이용activity_main.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;EditText android:id=&quot;@+id/editText&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:ems=&quot;10&quot; android:inputType=&quot;textPersonName&quot; android:text=&quot;http://kobis.or.kr/kobisopenapi/webservice/rest/boxoffice/searchDailyBoxOfficeList.json?key=f5eef3421c602c6cb7ea224104795888&amp;amp;#38;targetDt=20120101&quot;/&amp;gt; &amp;lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button&quot; /&amp;gt; &amp;lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&amp;gt;&amp;lt;/LinearLayout&amp;gt;movie_item.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:elevation=&quot;5dp&quot; android:orientation=&quot;vertical&quot;&amp;gt; &amp;lt;androidx.cardview.widget.CardView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;1dp&quot; android:layout_marginLeft=&quot;8dp&quot; android:layout_marginTop=&quot;4dp&quot; android:layout_marginRight=&quot;8dp&quot; android:layout_marginBottom=&quot;4dp&quot; app:cardCornerRadius=&quot;10dp&quot;&amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&amp;gt; &amp;lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;80dp&quot; android:padding=&quot;5dp&quot; app:srcCompat=&quot;@drawable/movie&quot; /&amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_margin=&quot;5dp&quot; android:layout_weight=&quot;1&quot; android:orientation=&quot;vertical&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;right&quot; android:maxLines=&quot;1&quot; android:text=&quot;제목&quot; android:textSize=&quot;22sp&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:gravity=&quot;right&quot; android:paddingRight=&quot;10dp&quot; android:text=&quot;관객수&quot; android:textSize=&quot;20sp&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/androidx.cardview.widget.CardView&amp;gt;&amp;lt;/LinearLayout&amp;gt;MovieAdapter.javapublic class MovieAdapter extends RecyclerView.Adapter&amp;lt;MovieAdapter.ViewHolder&amp;gt;{ ArrayList&amp;lt;Movie&amp;gt;items = new ArrayList&amp;lt;Movie&amp;gt;(); @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int viewType){ LayoutInflater inflater = LayoutInflater.from(viewGroup.getContext()); View itemView = inflater.inflate(R.layout.movie_item, viewGroup, false); return new ViewHolder(itemView); } @Override public void onBindViewHolder(@NonNull ViewHolder viewHolder, int position){ // 현재 인덱스에 맞는 Movie 객체를 찾아 뷰 홀더에 객체를 설정 Movie item = items.get(position); viewHolder.setItem(item); } @Override public int getItemCount(){ return items.size(); } public void addItem(Movie item){ items.add(item); } public void setItems(ArrayList&amp;lt;Movie&amp;gt; items){ this.items = items; } public Movie getItem(int position){ return items.get(position); } public static class ViewHolder extends RecyclerView.ViewHolder{ TextView textView; TextView textView2; public ViewHolder(View itemView){ super(itemView); this.textView = itemView.findViewById(R.id.textView); this.textView2 = itemView.findViewById(R.id.textView2); } public void setItem(Movie item){ textView.setText(item.movieNm); textView2.setText(item.audiCnt + &quot; 명&quot;); } }}MovieList.javapublic class MovieList { MovieListResult boxOfficeResult;}MovieResult.javapublic class MovieListResult { String boxofficeType; String showRange; ArrayList&amp;lt;Movie&amp;gt; dailyBoxOfficeList = new ArrayList&amp;lt;Movie&amp;gt;(); }Moviepackage org.techtown.movie;public class Movie { String rnum; String rank; String rankInten; String rankOldAndNew; String movieCd; String movieNm; String openDt; String salesAmt; String salesShare; String salesInten; String salesChange; String salesAcc; String audiCnt; String audiInten; String audiChange; String audiAcc; String scrnCnt; String showCnt;}MainActivity.javapublic class MainActivity extends AppCompatActivity { EditText editText; TextView textView; static RequestQueue requestQueue; RecyclerView recyclerView; MovieAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText = findViewById(R.id.editText); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { makeRequest(); } }); if (requestQueue == null) { requestQueue = Volley.newRequestQueue(getApplicationContext()); } recyclerView = findViewById(R.id.recyclerView); LinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false); recyclerView.setLayoutManager(layoutManager); adapter = new MovieAdapter(); recyclerView.setAdapter(adapter); } public void makeRequest() { String url = editText.getText().toString(); StringRequest request = new StringRequest( Request.Method.GET, url, new Response.Listener&amp;lt;String&amp;gt;() { @Override public void onResponse(String response) { println(&quot;응답 -&amp;gt; &quot; + response); processResponse(response); } }, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { println(&quot;에러 -&amp;gt; &quot; + error.getMessage()); } } ) { @Override protected Map&amp;lt;String, String&amp;gt; getParams() throws AuthFailureError { Map&amp;lt;String,String&amp;gt; params = new HashMap&amp;lt;String,String&amp;gt;(); return params; } }; request.setShouldCache(false); requestQueue.add(request); println(&quot;요청 보냄.&quot;); } public void println(String data) { Log.d(&quot;MainActivity&quot;, data); } public void processResponse(String response) { Gson gson = new Gson(); MovieList movieList = gson.fromJson(response, MovieList.class); println(&quot;영화정보의 수 : &quot; + movieList.boxOfficeResult.dailyBoxOfficeList.size()); for (int i = 0; i &amp;lt; movieList.boxOfficeResult.dailyBoxOfficeList.size(); i++) { Movie movie = movieList.boxOfficeResult.dailyBoxOfficeList.get(i); adapter.addItem(movie); } adapter.notifyDataSetChanged(); }}인터넷 권한 추가AndroidManifest.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.movie&quot;&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&amp;gt; &amp;lt;application android:usesCleartextTraffic=&quot;true&quot; android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.SampleMovie&quot;&amp;gt; &amp;lt;activity android:name=&quot;.MainActivity&quot; android:exported=&quot;true&quot;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt; &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;/activity&amp;gt; &amp;lt;/application&amp;gt;&amp;lt;/manifest&amp;gt;외부 라이브러리 추가build.gradle(Module : Name)dependencies { implementation &#39;com.squareup.picasso:picasso:2.71828&#39; implementation &#39;com.android.volley:volley:1.2.0&#39;결과" }, { "title": "Volley", "url": "/posts/Volley/", "categories": "Android, Network", "tags": "android, network, volley", "date": "2022-01-25 01:02:00 +0900", "snippet": "Volley 사용하기Volley 라이브러리는 웹 요청과 응답을 단순화하기 위해 만들어진 라이브러리이다.Volley를 사용하려면 먼저 요청(Request) 객체를 만들고 이 요청 객체를 Request Queue에 넣어주기만 하면 된다.Volley 라이브러리의 가장 큰 장점은 스레드를 신경 쓰지 않아도 된다.요청 큐가 내부에서 스레드를 만들어 웹 서버에 요청하고 응답 받는 과정을 진행하는데,응답을 처리할 수 있는 메서드를 호출 할 때는 메인 스레드에서 처리할 수 있도록 만들기 때문이다.예제Volley는 외부 라이브러리이므로 build.gradle 파일에 정보를 추가해 줘야 한다.(Module: SampleRequest.app)dependencies { ... implementation &#39;com.android.volley:volley:1.2.0&#39; ...또한 인터넷을 사용하므로 매니페스트 파일에 INTERNET 권한을 추가하는 것도 잊어서는 안된다.AndroidManifest.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.myapplication&quot;&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&amp;gt; &amp;lt;application android:usesCleartextTraffic=&quot;true&quot;ActivityMain.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;EditText android:id=&quot;@+id/editText&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:ems=&quot;10&quot; android:inputType=&quot;textPersonName&quot; android:text=&quot;사이트 주소 입력&quot; /&amp;gt; &amp;lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;요청하기&quot; /&amp;gt; &amp;lt;ScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; &amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/ScrollView&amp;gt;&amp;lt;/LinearLayout&amp;gt;MainActivity.javapublic class MainActivity extends AppCompatActivity { EditText editText; TextView textView; static RequestQueue requestQueue; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText = findViewById(R.id.editText); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { makeRequest(); } }); if (requestQueue == null) { // 요청 큐 생성 requestQueue = Volley.newRequestQueue(getApplicationContext()); } } public void makeRequest() { String url = editText.getText().toString(); StringRequest request = new StringRequest( Request.Method.GET, url, new Response.Listener&amp;lt;String&amp;gt;() { @Override public void onResponse(String response) { println(&quot;응답 -&amp;gt; &quot; + response); } }, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { println(&quot;에러 -&amp;gt; &quot; + error.getMessage()); } } ) { @Override protected Map&amp;lt;String, String&amp;gt; getParams() throws AuthFailureError { Map&amp;lt;String,String&amp;gt; params = new HashMap&amp;lt;String,String&amp;gt;(); return params; } }; request.setShouldCache(false); requestQueue.add(request); // 요청 큐에 요청 객체를 넣어 줌 println(&quot;요청 보냄.&quot;); } public void println(String data) { textView.append(data + &quot;\\n&quot;); }}사용자가 버튼을 클릭했을 때 요청 객체를 만들고 요청 큐에 넣어준다.요청 큐는 이 액티비티에서만 사용하는 것이 아니라 앱 전체에서 사용하는 것이 일반적이다.그래서 static 키워드로 클래스 변수를 선언한 후 할당했다.실제 앱을 만들 때는 Application 클래스 안에 넣어두거나 별도의 클래스를 하나 만들어서 넣어 둘 수 있다.String Request는 문자열을 주고 받기 위해 사용하는 객체이고 요청 객체는 StringRequest 클래스로 만들 수 있다.요청 객체를 만들 때 4가지의 파라미터를 전달하는데 내용은 아래와 같다. GET, POST 요청 방식 지정 웹사이트 주소 응답 받을 리스너 객체 전달 에러가 발생할 때 호출될 리스너 객체 전달위에서는 GET 방식을 사용했지만 POST 방식을 사용하면서 요청 파라미터를 전달하고자 한다면getParams 메서드에서 반환하는 HashMap 객체에 파라미터 값들을 넣어주면 된다.위에서는 파라미터가 없기 때문에 비워 뒀다.요청 큐의 add 메서드로 요청 객체를 넣으면 요청 큐가 자동으로 요청과 응답 과정을 진행한다.요청 객체는 cache 메커니즘을 지원하는데 만약 이전 응답 결과를 사용하지 않는다면setShouldCache 메서드를 사용해 false로 설정하면 된다.결과위처럼 스레드나 핸들러를 사용하지 않았는데도 웹 사이트 요청과 응답이 문제 없이 진행되는 것을 확인할 수 있다." }, { "title": "HttpURLConnection", "url": "/posts/HttpUrlConnection/", "categories": "Android, Network", "tags": "android, network, http, url", "date": "2022-01-24 11:20:00 +0900", "snippet": "HttpURLConnection으로 웹 서버 통신하기안드로이드 어플리케이션이 서버와 통신하기 위한 방법에는 HTTP통신과 Socket 통신 2가지가 있다.우리는 주로 DB에 존재하는 데이터를 가져오기 위해 서버 통신을 한다.하지만 안드로이드의 특성상 외부 DB에 직접 접근할 수 가 없도록 되어있어 중간 매체인 WEB을 활용해야한다.자신의 DB와 WEB에서 데이터를 가져오기 위해선 호스팅이나 개인서버를 구축한 후,자신이 만든 WEB문서가 포함된 로컬호스트 주소에 접속해서 데이터를 얻어와야한다.또한 안드로이드에서 HTTP통신으로 서버와 통신을 할 때 AsyncTask(비동기)로 통신을 해야한다.왜냐하면 안드로이드의 메인쓰레드는 전부 UI 관련 처리를 위해 사용되기 때문에,**비동기 방식을 사용하지 않고 개발자가 임의로 HTTPURLConnection을 하게되면 Runtime Exception, **android.os.NetworkOnMainThreadException이 뜨고 ANR(Android Not Responding) 상황에 놓이게 된다.HTTP로 웹 서버에 접속하는 방법도 소켓의 경우와 마찬가지로 표준 자바 방식을 그대로 사용할 수 있다.자바에서 HTTP 클라이언트를 만드는 가장 간단한 방법은 URL 객체를 만들고 openConnection메서드를 호출하여 HttpURLConnection 객체를 만드는 것이다.public URLConnection openConnection()URL 객체에 들어 있는 문자열이 “http://”를 포함하면 HTTP 연결을 위한 객체를 만들게 되므로 openConnection메서드가 반환하는 URLConnection 객체를 HttpURLConnectoin으로 형 변환하여 사용할 수 있다.HttpURLConnection에는 POST와 GET 2가지 방식이 존재한다.먼저 POST의 경우에는 앱에서 URI를 통해 요청하게 되면 리소스를 생성하게 되는 경우이며, (서버의 상태나 데이터를 변경시킬 때 사용)GET은 URL을 통해 접속해 리소스 값을 조회하는 행위이다. (서버로부터 정보 조회)또한 리소스를 조회하고 해당 도큐먼트에 대한 자세한 정보도 가져온다.POST의 경우에는 정상적으로 작동이 된다면 리소스 생성에 대한 응답 코드를 보낼 것이며,GET의 경우에는 해당 도큐먼트(ex. 그림파일, DB, etc…)에 대한 정보를 불러오게 됨으로두 가지 방식에는 약간의 차이가 존재하게 된다.따라서 POST와 GET에 대한 메소드를 만드는데 약간의 차이점이 존재하게 된다.예제activity.main.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;EditText android:id=&quot;@+id/editText&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:ems=&quot;10&quot; android:inputType=&quot;textPersonName&quot; android:text=&quot;사이트 주소 입력&quot; /&amp;gt; &amp;lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;요청하기&quot; /&amp;gt; &amp;lt;ScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; &amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/ScrollView&amp;gt;&amp;lt;/LinearLayout&amp;gt;MainActivity.javapublic class MainActivity extends AppCompatActivity { EditText editText; TextView textView; Handler handler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText = findViewById(R.id.editText); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ final String urlStr = editText.getText().toString(); new Thread(new Runnable() { @Override public void run() { request(urlStr); } }).start(); } }); } public void request(String urlStr){ StringBuilder output = new StringBuilder(); try{ URL url = new URL(urlStr); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); if(conn != null){ conn.setConnectTimeout(10000); // 웹 페이지 연결 대기 시간 최대 10초 conn.setRequestMethod(&quot;GET&quot;); // GET/POST 방식 설정 conn.setDoInput(true); // InputStream으로 읽겠다고 설정 int resCode = conn.getResponseCode(); // 응답 코드를 받아옴 BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line = null; while(true){ line = reader.readLine(); if(line == null) break; output.append(line + &quot;\\n&quot;); } reader.close(); conn.disconnect(); } }catch(Exception e){ println(&quot;예외 발생함: &quot; + e.toString()); } println(&quot;응답-&amp;gt; &quot; + output.toString()); } public void println(final String data){ handler.post(new Runnable() { @Override public void run() { textView.append(data + &quot;\\n&quot;); } }); }인터넷 권한을 사용하므로 Manifest 파일에 권한과 속성을 하나 추가해주자.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.myapplication&quot;&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&amp;gt; &amp;lt;application android:usesCleartextTraffic=&quot;true&quot;결과" }, { "title": "TCP/IP 기본 개념", "url": "/posts/NetWork/", "categories": "Java, TCP/IP", "tags": "android, network, socket", "date": "2022-01-23 00:54:00 +0900", "snippet": "TCP/IP 프로토콜TCP 프로토콜은 두 시스템 간에 신뢰성 있는 데이터의 전송을 관장하는 통신 프로토콜로서 IP 프로토콜 위에서 동작한다.TCP 프로토콜을 사용하는 응용프로그램으로는 e-mail, FTP, 웹 HTTP 등이 있다.IP는 패킷 교환 네트워크에서 송신 호스트와 수신 호스트가 데이터를 주고받는 것을 관장하는 프로토콜로서 TCP의하위 레벨 프로토콜이다. TCP는 IP 기능을 활용하여 두 시스템 사이에 데이터가 손상 없이 안전하게 전송되도록 하며,TCP와 IP를 묶어 TCP/IP로 표기한다.IP 주소와 PORT 번호IP 주소는 네트워크상에서 유일하게 식별될 수 있는 네트워크 장치의 주소로서 형태는 192.156.11.14와 같이4개의 숫자가 ’.’ 으로 연결된다. 하나의 숫자 범위는 0 ~ 255로서 한 바이트로 표현이 가능하다.IP 주소는 마치 전화번호나 집 주소와 같아 이 주소를 통해 네트워크에 연결된 장치를 식별할 수 있으며,동일한 주소를 여러 네트워크 장치에 중복해서 사용할 수 없다.숫자로 된 주소는 기억하기 어려우므로 https://sey2.github.io 같은 문자열로 구성된 도메인 이름으로 바꿔 사용한다.이렇게 사용자가 문자열로 구성된 도메인 이름을 사용하면 DNS 서버에 의해 숫자로 구성된 IP 주소로 자동 변환하게 된다.현재는 4개의 숫자로 구성된 IP 주소를 표현하기 위해 32비트 IPv4가 사용되고 있지만,세계적으로 네트워크 장치의 개수가 급격하게 증가하여 각 장치에 고유하게 부여할 수 있는 IP주소가 고갈됨에 따라128비트의 (IPv6)이 점점 사용되는 추세이다.한 컴퓨터에는 여러 응용 프로그램이 네트워크를 사용하고 있기 때문에, IP 주소만 가지고 통신하고자 하는응용프그램을 식별할 수 없다. 이를 위해 한 컴퓨터 내의 각 응용프로그램은 통신을 위해 가상의 연결단인PORT를 생성하고, 이 포트 번호로 상태방이 자신을 식별하게 된다.IP 주소는 아파트의 동 번호와 같고, 포트 번호는 그 동에 있는 호 번호에 비유할 수 있다.포트 번호는 응용프로그램 개발자가 임의로 선택하여 선택 할 수 있다.하지만 기존 응용 프로그램에서 사용하고 있는 포트 번호나 시스템 포트 번호는 피하는게 좋다.예를 들어 Telnet 23번 포트, HTTP는 80번 포트, FTP는 21번 포트 등이며, 이들은 주로 0 ~ 1023 사이의 번호를가지므로 이 범위의 포트 번호는 피해서 선택하는 것이 좋다.소켓소켓 통신은 개발자가 TCP/IP 네트워크를 이용하여 쉽게 통신 프로그램을 작성하도록 지원하는 기반 기술이다.TCP/IP의 네트워크 기능을 활용하여 다른 컴퓨터의 소켓과 데이터를 주고 받는다.소켓을 활용하는 통신의 모양은 아래와 같다.소켓을 이용하는 통신 사례응용 프로그램은 소켓과 연결한 후 소켓에 데이터를 주기만 하면, 소켓이 상대방 응용 프로그램에 연결된 소켓에데이터를 보낸다. 또는 응용 프로그램은 연결된 소켓으로부터 도착한 데이터를 단순히 받기만 하면 된다.소켓과 서버 클라이언트 통신소켓을 이용하는 통신에서는 서버 응용 프로그램과 클라이언트 응용 프로그램으로 구분된다.정보를 제공하는 쪽을 서버라고 하고, 정보를 이용하는 쪽을 클라이언트라고 부른다.서버가 먼저 클라이언트의 접속을 기다리고, 클라이언트에서 서버에 접속하면, 그 때부터 서버나 클라이언트가데이터를 주고 받을 수 있다.### 서버 소켓과 클라이언트 소켓 서버 소켓은 서버 응용 프로그램이 사용자의 접속을 기다리는 목적으로만 사용된다. 클라이언트 응용 프로그램에서는 클라이언트 소켓을 이용하여 서버에 접속한다. 서버 소켓은 클라이언트가 접속해오면, 클라이언트 소켓을 추가로 만들어 상대 클라이언트와 통신하게 한다.소켓을 이용한 서버 클라이언트 통신 프로그램의 전형적인 구조 서버 소켓 객체를 생성하고 클라이언트의 접속을 받기 위해 기다린다. 서버 소켓을 생성할 때 포트 번호를 주어 해당 포트로 접속해 오는 클라이언트를 기다리게 한다. 클라이언트 응용프로그램은 Client Socket 객체를 생성하고 서버에 접속을 시도한다. 객체를 생성할 때 접속할 서버 소켓의 IP 주소와 포트 번호를 지정한다. 서버와 클라이언트로부터 접속 요청을 받으면, accept() 메소드에서 접속된 클라이언트와 통신하도록 전용 클라이언트 소켓을 따로 생성한다. 서버와 클라이언트 모두 소켓으로부터 입출력 스트림을 얻어내고 데이터를 주고 받을 준비한다. 서버에 생성된 클라이언트 전용 소켓과 클라이언트의 소켓이 상호 연결된 채 스트림을 이용하여 양방향으로 데이터를 주고 받는다. 서버는 클라이언트가 접속해 올 때마다 accpet() 메소드에서 따로 전용 클라이언트 소켓을 생성하여 클라이언트와 통신하도록 한다. 통신이 끝나면 소켓을 닫는다. 소켓 클래스의 주요 메소드 메소드 설명 Socket 연결되지 않은 상태의 소켓 소켓을 생성 Socket(InetAddress address, int port) 소켓을 생성하고, 지정된 UP 주소와 포트 번호에서 대기하는원격 응용 프로그램의 소켓에 연결 Socket(String host, int port) 소켓을 생성하여 지정된 호스트와 포트 번호에 연결한다. 호스트 이름이 null인 경우 루프백 주소로 가정 void bind(SocketAddress bindpoint) 소켓에 local IP 주소와 local 포트 지정 void close() 소켓을 닫는다. void connect(SocketAddress endpoint) 서버에 연결 InetAddress getInetAddress() 소켓에 연결된 서버 IP 주소 반환 InputStream getInputStream() 소켓의 입력 스트림 반환. 이 스트림을 이용하여 소켓이 상대편으로부터 받은 데이터를 읽을 수 있음 InetAddress getLocalAddress() 소켓의 로컬 주소 반환 int getLocalPort() 소켓의 로컬 포트 번호 반횐 int getPort() 소켓에 연결된 서버의 포트 번호 반환 OutputStream getOutputStream() 소켓의 출력 스트림 반환. 이 스트림에 출력하면 소켓이 서버로 데이터 전송 boolean isBound() 소켓이 로컬 주소와 결합되어 있으면 true 반환 boolean isConnected() 소켓이 서버에 연결되어 있으면 true 반환 boolean isClosed() 소켓이 닫혀 있으면 true 반환 void setSoTimeout(int timeout) 데이터 읽기 타임아웃 시간 지정. 0이면 타임아웃 해제 ServerSocket 클래스Server Socket 클래스는 서버 소켓을 구현한다.ServerSocket은 클라이언트로부터 연결 요청을 기다리는 목적으로만 사용되며, 서버가 클라이언트의연결 요청을 수락하면 Socket 객체를 별도로 생성하고, 이 Socket 객체가 클라이언트와 데이터를 주고 받는다.서버 소켓 생성 예ServerSocket listener = new ServerSocket(9999);이 포트 번호는 클라이언트의 접속을 기다릴 자신의 포트 번호이다.이미 사용 중인 포트 번호를 지정하면 오류가 발생한다.Socket socket = listenr.accept(); ServerSocket 클래스의 accept() 메소드를 이용하여 클라이언트로부터의 연결 요청을 기다린다.acppet() 메소드가 연결을 수락하면 위와 같이 Socket 객체를 하나 생성하여 리턴한다.ServerSocket 클래스의 주요 메소드 메소드 설명 Socket accpet() 클라이언트로부터 연결 요청을 기다리다 요청이 들어오면 수락하고클라이언트와 데이터를 주고 받을 새 Socket 객체를 반환   void close() 서버 소켓을 닫는다. InetAddress getInetAddress() 서버 소켓의 로컬 IP 주소 반환 int getLocalPort() 서버 소켓의 로컬 포트 번호 반환 boolean isBound() 서버 소켓이 로컬 주소와 결합되어 있으면 true 반환 boolean isClosed() 서버 소켓이 닫혀 있으면 true 반환 void setSoTimeOut(int timeout) accpet()가 대기하는 타임 아웃 시간 지정. 0이면 무한정 대기 서버 클라이언트 채팅 프로그램Server.javapublic class Server { public static void main(String [] args) { BufferedReader in = null; BufferedWriter out = null; ServerSocket listener = null; Socket socket = null; Scanner scanner = new Scanner(System.in); try { listener = new ServerSocket(9999); System.out.println(&quot;연결을 기다리는 중..&quot;); socket = listener.accept(); System.out.println(&quot;연결되었습니다.&quot;); in = new BufferedReader(new InputStreamReader(socket.getInputStream())); out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); while(true) { String inputMessage = in.readLine(); // equalsIgnoreCase는 대소문자 구분하지 않는다. if(inputMessage.equalsIgnoreCase(&quot;bye&quot;)) { System.out.println(&quot;클라이언트에서 bye로 연결을 종료 하였음&quot;); break; // bye를 받으면 연결 종료 } System.out.println(&quot;클라이언트: &quot; + inputMessage); System.out.print(&quot;보내기&amp;gt;&amp;gt;&quot;); String outputMessage = scanner.nextLine(); out.write(outputMessage + &quot;\\n&quot;); out.flush(); } }catch(IOException e) { System.out.println(e.getMessage()); } finally { try { scanner.close(); socket.close(); // 통신용 소켓 닫기 listener.close(); // 서버 소켓 닫기 }catch(IOException e) { System.out.println(&quot;클라이언트와 채팅중 오류가 발생했습니다.&quot;); } } }}Client.javaimport java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.ServerSocket;import java.net.Socket;import java.util.Scanner;public class Client { public static void main(String[] args) { BufferedReader in = null; BufferedWriter out = null; Socket socket = null; Scanner scanner = new Scanner(System.in); try { // 다른 서버의 컴퓨터면 localhost 대신 IP 주소를 적어야함 socket = new Socket(&quot;localhost&quot;, 9999); // 클라이언트 소켓 생성, 서버에 연결 in = new BufferedReader(new InputStreamReader(socket.getInputStream())); out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); while(true) { System.out.print(&quot;보내기&amp;gt;&amp;gt;&quot;); String outputMessage = scanner.nextLine(); if(outputMessage.equalsIgnoreCase(&quot;bye&quot;)) { out.write(outputMessage + &quot;\\n&quot;); // bye 문자열 전송 out.flush(); // out의 스트림 버퍼에 있는 모든 문자열 전송 String inputMessage = in.readLine(); System.out.println(&quot;서버: &quot; + inputMessage); // 서버로 부터 받은 메시지를 화면에 출력 } out.write(outputMessage + &quot;\\n&quot;); out.flush(); String inputMessage = in.readLine(); System.out.println(&quot;서버: &quot;+ inputMessage); } }catch (IOException e) { System.out.println(e.getMessage()); }finally { try { scanner.close(); if(socket!=null) socket.close(); // 클라이언트 소켓ㅎ 닫기 }catch (IOException e) { System.out.println(&quot;서버와 채팅 중 오류가 발생 했습니다.&quot;); } } }}결과" }, { "title": "Socket 사용하기", "url": "/posts/Socket/", "categories": "Android, Network", "tags": "android, network, socket", "date": "2022-01-23 00:03:00 +0900", "snippet": "소켓 사용하기IP 주소로 목적지 호스트를 찾아내고 포트로 통신 접속점을 찾아내는 소켓 연결은TCP와 UDP 방식으로 나눌 수 있다. 하지만 일반적으로 프로그래밍에서는 대부분TCP 연결을 사용한다.HTTP 프로토콜과 소켓HTTP 프로토콜은 소켓으로 웹 서버에 연결한 후 요청을 전송하고 응답을 받은 후연결을 끊는다. 이런 특성을 비연결성 이라고 하는데 이러한 특성 때문에 실시간으로데이터를 처리하는 앱은 속도를 높이기 위해 연결성이 있는 소켓 연결을 선호 했다고 한다.하지만 지금은 인터넷 속도가 빨라져 HTTP 프로토콜을 사용하는 웹이 일반적이 되었고결국 속도가 그렇게 느리지 않으면서도 국제 표준을 따르는 장점을 가진 많은 웹서버가만들어지게 되었다.예제안드로이는 소켓 연결 등을 시도하거나 응답을 받아 처리할 때 반드시 스레드를 사용해야한다.이전에는 권장 사항이었으나 현재 플랫폼에서는 강제사항으로 바뀌었으므로 스레드를사용하지 않으면 네트워킹 기능이 동작하지 않는다.일단 아래와 같이 화면을 구성하자.그 후 아래와 같이 코드를 작성하자.MainActivity.javapublic class MainActivity extends AppCompatActivity { EditText editText; TextView textView; TextView textView2; Handler handler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText = findViewById(R.id.editText); textView = findViewById(R.id.textView); textView2 = findViewById(R.id.textView2); Button button = findViewById(R.id.button); button.setOnClickListener((v) -&amp;gt; { final String data = editText.getText().toString(); new Thread(new Runnable() { @Override public void run() { send(data); } }).start(); }); Button button2 = findViewById(R.id.button2); button2.setOnClickListener((v) -&amp;gt; { new Thread(new Runnable() { @Override public void run() { startServer(); } }).start(); }); } public void send(String data){ try{ int portNumber = 5001; Socket sock = new Socket(&quot;localhost&quot;, portNumber); printClientLog(&quot;소켓 연결함.&quot;); /* 소켓 객체로 데이터 보내기 */ ObjectOutputStream outstream = new ObjectOutputStream(sock.getOutputStream()); outstream.writeObject(data); outstream.flush(); printClientLog(&quot;데이터 전송함&quot;); ObjectInputStream instream = new ObjectInputStream(sock.getInputStream()); printClientLog(&quot;서버로부터 받음 &quot; + instream.readObject()); sock.close(); }catch (Exception ex){ ex.printStackTrace(); } } public void startServer(){ try{ int portNumber = 5001; // 소켓 서버 객체 만들기 ServerSocket server = new ServerSocket(portNumber); printServerLog(&quot;서버 시작함: &quot; + portNumber); while(true){ /* 클라이언트가 접속했을 때 만들어지는 소켓 객체 참조하기 */ Socket sock = server.accept(); InetAddress clientHost = sock.getLocalAddress(); int clientPort = sock.getPort(); printServerLog(&quot;클라이언트 연결됨: &quot; + clientHost + &quot; : &quot; + clientPort); ObjectInputStream instream = new ObjectInputStream(sock.getInputStream()); Object obj = instream.readObject(); printServerLog(&quot;데이터 받음: &quot; + obj); ObjectOutputStream outstream = new ObjectOutputStream(sock.getOutputStream()); outstream.writeObject(obj + &quot; from Server.&quot;); outstream.flush(); printServerLog(&quot;데이터 보냄.&quot;); sock.close(); } }catch(Exception ex){ ex.printStackTrace(); } } public void printClientLog(final String data){ Log.d(&quot;MainActivity&quot;,data); // 클라이언트 쪽 로그를 텍스트뷰에 출력하기 위한 Handler handler.post(new Runnable() { @Override public void run() { textView.append(data + &quot;\\n&quot;); } }); } public void printServerLog(final String data){ Log.d(&quot;MainActivity&quot;,data); // 서버 쪽 로그를 텍스트뷰에 출력하기 위한 Handler handler.post(new Runnable(){ @Override public void run(){ textView2.append(data+&quot;\\n&quot;); } }); }}여기서 ObjectInputStream 과 ObjectStream을 사용했지만 실제 앱을 만들때는 잘 사용하지 않는다.이유는 위 두 클래스는 자바의 객체 정보를 편리하게 주고 받을 수 있도록 만들어진 클래스이다.자바가 아닌 다른 언어로 만들어진 서버와 통신할 경우에는 데이터 송수신이 정상적으로 이루어지지 않을 수 있다.인제 위의 코드를 작성 했으면 INTERNET 권한을 추가해 주자.AndroidManifest.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.socket&quot;&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&amp;gt; ...결과" }, { "title": "NetWorking", "url": "/posts/Network/", "categories": "Android, Network", "tags": "android, network", "date": "2022-01-22 22:39:00 +0900", "snippet": "네트워킹이란?네트워킹은 인터넷에 연결되어 있는 원격지의 서버 또는 원격지의 단말과통신해서 데이터를 주고 받는 동작들을 말한다.이런 네트워킹은 우리가 가지고 있는 단말의 데이터만 사용하는 것이 아니라 멀리떨어져 있는 서버나 다른 사람의 단말의 데이터를 조회할 수 있다.네트워킹을 사용하는 이유는 인터넷에 연결되어 있는 단말을 동시에 사용할 수 있어서 다양한데이터 자원을 효율적으로 사용할 수 있다.네트워크 연결 방식원격지의 서버를 연결하는 가장 단순한 방식은 클라이언트와 서버가 1:1로 연결하는2-tier C/S (Client/Server) 방식이다.이 연결 방식은 가장 많이 사용하는 네트워킹 방식이며 대부분 클라이언트가서버에 연결되어 데이터를 요청하고 응답 받는 단순한 개념이다.HTTP 프로토콜, FTP 프로토콜, POP3 프로토콜 등 모두 2-tire C/S 방식을 사용한다.2-tire C/S 방식graph LRA(클라이언트) -- Request 요청 --&amp;gt; B(서버)B -- Response 응답 --&amp;gt; A또 다른 연결 방식으로 3-tier 방식이 있는데 이 방식을 사용하면 서버를 좀 더유연하게 구성할 수 있다. 또 응용서버와 데이터 서버로 서버를 구성하면 데이터베이스를분리할 수 있어 중간에 비지니스 로직을 처리하는 응용 서버가 좀 더 다양한 역할을할 수 있다는 장점이 생긴다.3-tire 방식graph LRA(클라이언트) -- Request 요청 --&amp;gt; B(서버)B -- Response 응답 --&amp;gt; AB -- 데이터 요청 --&amp;gt; C(데이터 서버)C -- 데이터 응답 --&amp;gt; B좀 더 많은 단계들을 추가한 N-tier 방식도 있지만 3-tier 까지만 이해해도 앱을 만드는데 큰 무리가 없다고 한다." }, { "title": "쓰레드로 여러 이미지 번갈아 보여주기", "url": "/posts/ThreadAnim/", "categories": "Android, Thread, Animation", "tags": "android, thread, handler, animation", "date": "2022-01-22 22:19:00 +0900", "snippet": "스레드로 애니메이션 만들기여러 이미지를 연속해서 바꿔가며 애니메이션 효과를 만들고 싶을 때 스레드를 사용하는 경우가 많다.아래 예제를 통해 우리 귀여운 꿀이를 보는 동시에 애니메이션 효과를 알아보자MainActivity.javapublic class MainActivity extends AppCompatActivity { ImageView imageView; ArrayList&amp;lt;Drawable&amp;gt; drawableList = new ArrayList&amp;lt;Drawable&amp;gt;(); Handler handler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Resources res = getResources(); drawableList.add(res.getDrawable(R.drawable.m1)); drawableList.add(res.getDrawable(R.drawable.m2)); drawableList.add(res.getDrawable(R.drawable.m3)); drawableList.add(res.getDrawable(R.drawable.m4)); imageView = findViewById(R.id.imageView); Button button = findViewById(R.id.button); button.setOnClickListener((v)-&amp;gt;{ AnimThread thread = new AnimThread(); thread.start(); }); } class AnimThread extends Thread{ public void run(){ int idx =0; for(int i=0; i&amp;lt;100; i++){ final Drawable drawable = drawableList.get(idx); idx+=1; if(idx&amp;gt;3) idx=0; handler.post(new Runnable() { @Override public void run() { imageView.setImageDrawable(drawable); } }); try{ Thread.sleep(1000); }catch(Exception e){ e.printStackTrace(); } } } }예제" }, { "title": "Handler 지연 시간 (postDelayed) ", "url": "/posts/Handler-postDelay/", "categories": "Android, Thread", "tags": "android, thread, handler, runnable, postdelayed", "date": "2022-01-22 20:44:00 +0900", "snippet": "일정 시간 후에 실행하기웹 서버와 같은 원격 서버에 접속한 후 웹페이지를 요청할 때 응답이 늦어지거나 응답이 없으면앱이 대기하고 있는 상황이 지속되는 문제가 생긴다.이런 경우에는 기본적으로 별도의 스레드를 만들어 처리하면 된다.버튼을 클릭해 간단하게 접속 처리하는 경우에는 메인 스레드내에서 Thread.sleep()을 사용해UI의 멈춤 현상을 방지 할 수 있다.하지만 핸들러로 실행되는 코드는 메시지 큐를 통과하면서 순차적으로 실행이 되기 때문에postDelayed을 이용해 지연시간을 주면 UI 객체들에게 영향을 주지 않게 된다.예제MainActivity.javapublic class MainActivity extends AppCompatActivity { TextView textView; Handler handler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { request(); } }); } private void request(){ String title = &quot;title&quot;; String message = &quot;데이터를 요청하시겠습니까?&quot;; String titleButtonYes=&quot;예&quot;; String titleButtonNo=&quot;아니오&quot;; AlertDialog dialog = makeRequestDialog(title, message, titleButtonYes, titleButtonNo); dialog.show(); textView.setText(&quot;대화상자 표시중..&quot;); } private AlertDialog makeRequestDialog(CharSequence title, CharSequence message, CharSequence titleButtonYes, CharSequence titleButtonNO){ AlertDialog.Builder requestDialog = new AlertDialog.Builder(this); requestDialog.setTitle(title); requestDialog.setMessage(message); requestDialog.setPositiveButton(titleButtonYes, new DialogInterface.OnClickListener(){ @Override public void onClick(DialogInterface dialogInterface, int i) { textView.setText(&quot;5초 후에 결과 표시됨.&quot;); handler.postDelayed(new Runnable() { @Override public void run() { textView.setText(&quot;요청 완료됨.&quot;); } }, 5000); } }); requestDialog.setNegativeButton(titleButtonNO, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) {} }); return requestDialog.create(); }결과postDelayed 메서드를 사용할 때 주의할 점이 있다.아래 첫 번째 메서드를 1초후에 실행한 후 두 번째 메서드를 첫 번째 메서드가 끝나고 나서3초뒤(실행 시간 기준 4초)에 실행하고 싶어서 아래처럼 코드를 짰다.handler.postDelayed(new DelayMessage(countTime,flag), 1000);handler.postDelayed(new DelayMessage(countTime,flag), 3000);이렇게 하면 우리가 의도한대로 작동하지 않는다.왜냐하면 위의 두 번째 postDelayed는 실행 시간 기준 3초뒤에 실행 되기 때문이다.따라서 우리가 의도하고 싶은대로 작동하게 할려면 특정한 시간 기준으로 누적되는 시간으로적용해주어야 한다.아래 코드로 그 예를 확인해보자.MainActivity.javapublic class MainActivity extends AppCompatActivity { TextView textView; Handler handler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { request(); } }); } private void request(){ String title = &quot;title&quot;; String message = &quot;데이터를 요청하시겠습니까?&quot;; String titleButtonYes=&quot;예&quot;; String titleButtonNo=&quot;아니오&quot;; AlertDialog dialog = makeRequestDialog(title, message, titleButtonYes, titleButtonNo); dialog.show(); textView.setText(&quot;대화상자 표시중..&quot;); } private AlertDialog makeRequestDialog(CharSequence title, CharSequence message, CharSequence titleButtonYes, CharSequence titleButtonNO){ AlertDialog.Builder requestDialog = new AlertDialog.Builder(this); requestDialog.setTitle(title); requestDialog.setMessage(message); requestDialog.setPositiveButton(titleButtonYes, new DialogInterface.OnClickListener(){ @Override public void onClick(DialogInterface dialogInterface, int i) { int delay = 1000; boolean flag = true; for(int countTime = 5; countTime &amp;gt;= 0; countTime--) { flag = (countTime!=0) ? true : false; handler.postDelayed(new DelayMessage(countTime,flag), delay); delay+=1000; } } }); requestDialog.setNegativeButton(titleButtonNO, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) {} }); return requestDialog.create(); } public class DelayMessage implements Runnable{ int time; boolean flag; public DelayMessage(int time,boolean flag){ this.time = time; this.flag = flag; } @Override public void run() { if(flag == true) textView.setText(time + &quot;초 후에 요청 됨&quot;); else if(flag == false) textView.setText(&quot;요청됨&quot;); } }}결과" }, { "title": "Thread and Handler", "url": "/posts/Thread_Handler/", "categories": "Android, Thread", "tags": "android, thread, handler, runnable", "date": "2022-01-20 00:16:00 +0900", "snippet": "Thread새로운 프로젝트를 만들면 자동으로 생성되는 메인 액티비티는 앱이 실행될 때 하나의 프로세스에서처리된다.따라서 메인 액티비티 내에서 이벤트를 처리하거나 특정 메서드를 정의하여 기능을 구현 할 때도같은 프로레스 안에서 실행된다. 같은 프로세스 안에서 일련의 기능이 순서대로 실행될 때 대부분은문제가 없지만, 대기시간이 길어지는 네트워크 요청 등의 기능을 수행할 때는 화면에 보이는 UI도멈춤 상태로 있게 되는 문제가 생길 수 있다.이런 문제를 해결하려면 멀티 스레드 방식을 사용하면된다.스레드란 동시 수행이 가능한 작업 단위이며, 현재 수행 중인 작업 이외의 기능을 동시에 처리할 때 새로운 스레드를 만들어 처리한다.이런 멀티 스레드 방식은 메모리 리소스를 공유해서 효울적인 처리가 가능해진다.하지만 동시에 리소스(자원)에 접근할 때 DeadLock이 발생하여 시스템이 비정상적으로 동작할 수 있다.앱 처음 실행 시별도의 스레드 생성시지연 시간이 길어질 수 있는 앱이라면 오랜 시간 작업을 수행하는 코드를 별도로 분리한 후UI에 응답하는 방식을 사용한다. 아래는 안드로이드가 제공하는 두 가지 시나리오이다. 구분 시나리오 (1) 서비스 사용하기 백그라운드 작업은 서비스로 실행하고 사용자에게는 알림 서비스로 알려준다. 만약 메인 액티비티로 결과 값을 전달하고 이를 이용해서 다른 작업을 수행하고자 한다면 브로드 캐스팅으로 결과 값을 전달할 수 있다. (2) 스레드 사용하기 스레드는 같은 프로세스 안에 있기 때문에 작업 수행의 결과를 바로 처리할 수 있다. 그러나 UI 객체는 직접 접근할 수 없으므로 핸들러(Handler) 객체를 사용한다. 안드로이드에서 UI 처리할 때 사용되는 기본 스레드를 메인 스레드라고 부른다.메인 스레드에서 이미 UI에 접근하고 있으므로 새로 생성한 다른 스레드에서는 Handler 객체를 사용해서메시지를 전달함으로써 메인 스레드에서 처리하도록 만들 수 있다.스레드 사용하기안드로이드에서는 표준 자바의 스레드를 그대로 사용할 수 있다.MainActiviy.javapublic class MainActivity extends AppCompatActivity { int value = 0; TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener(){ @Override public void onClick (View v){ // 스레드 객체 생성 후 실행 BackgroundThread thread = new BackgroundThread(); thread.start(); } }); } class BackgroundThread extends Thread{ public void run(){ for(int i=0; i&amp;lt;100; i++){ try{ sleep(1000); }catch(Exception e){} } value += 1; textView.setText(&quot;Value 값: &quot; + value); Log.d(&quot;Thread&quot; , &quot;value : &quot; + value); } }하지만 이렇게 하면 UI 객체를 직접 접근하지 못하기 때문에 Logcat 창에서 오류 메시지가 나오고앱이 제대로 실행되지 않는다.그 이유는 우리가 직접 만드는 스레드 객체에서는 UI객체에 접근 할 수 없기 때문이다.이 문제는 핸들러를 사용하면 해결 가능하다.핸들러로 메시지 전송하기앱을 실행할 때 프로세스가 만들어지면 그 안에 메인 스레드가 함께 만들어지고,최상위에서 관리되는 앱 구성 요소인 Activity, BroadCast Receiver 등과 새로 만들어지는 윈도우를 관리하기 위한 Message Queue를 실행한다.Message Queue를 사용하면 순차적으로 코드를 수행할 수 있다.이렇게 Message Queue로 메인 스레드에서 처리할 메시지를 전달하는 역할을 핸들러 클래스가 담당한다.핸들러를 이용하면 특정 메시지가 미래의 어떤 시점에 스케줄링 된다.핸들러를 사용할 때 필요한 세 가지 단계 출처 Do it! 안드로이드 프로그래밍 메소드 설명 obtainMessage() 메시지 큐에 있는 메시지 객체를 하나 참조 할 수 있다. sendMessage() 메시지 객체에 필요 정보를 넣은 후 메시지 큐로 전달 할 수 있다. HandleMessage() 이 메서드 안에 있는 코드가 메인 스레드에서 수행된다. 자 인제 사용 예시를 보자.MainActivity.javapublic class MainActivity extends AppCompatActivity { int value = 0; TextView textView; MainHandler handler; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener(){ @Override public void onClick (View v){ // 스레드 객체 생성 후 실행 BackgroundThread thread = new BackgroundThread(); thread.start(); } }); handler = new MainHandler(); } class BackgroundThread extends Thread{ public void run(){ for(int i=0; i&amp;lt;100; i++){ try{ sleep(1000); }catch(Exception e){} value += 1; Log.d(&quot;Thread&quot; , &quot;value : &quot; + value); Message message = handler.obtainMessage(); Bundle bundle = new Bundle(); bundle.putInt(&quot;value&quot;, value); message.setData(bundle); // message에 번들 집어 넣기 handler.sendMessage(message); // 핸들러로 메시지 객체 보내기 } } } class MainHandler extends Handler { @Override public void handleMessage(Message msg){ super.handleMessage(msg); // 번들은 Map 형태로 생긴 데이터 묶음 (key, value) Bundle bundle = msg.getData(); int value = bundle.getInt(&quot;value&quot;); textView.setText(&quot;value 값: &quot; + value); } }결과Runnable 객체 실행하기위 방법이 가장 일반적이지만 코드가 복잡해 보이는 단점이 있다.조금 더 간단한 방법으로 메인 스레드에서 실행 시킬 수 있다.핸들러 클래스는 메시지 전송 방법 이외에 Runnable 객체를 실행시킬 수 있는 방법을 제공하는데Runnable 객체를 핸들러의 post 메서드로 전달해주면 이 객체에 정의된 run 메서드 안의 코드들은메인 스레드에서 실행된다.예제를 봐보자 !MainActivity.javapublic class MainActivity extends AppCompatActivity { int value = 0; TextView textView; Handler handler = new Handler(); // API의 기본 핸들러 객체 생성 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener(){ @Override public void onClick (View v){ // 스레드 객체 생성 후 실행 BackgroundThread thread = new BackgroundThread(); thread.start(); } }); } class BackgroundThread extends Thread{ public void run(){ for(int i=0; i&amp;lt;100; i++){ try{ sleep(1000); }catch(Exception e){} value += 1; Log.d(&quot;Thread&quot; , &quot;value : &quot; + value); handler.post(new Runnable() { // 핸들러의 post 메서드 호출 @Override public void run() { textView.setText(&quot;value 값: &quot; + value); } }); } } }}이렇게 하면 메시지 처리를 위해 새로 정의했던 MainHandler 클래스는 이제 더 이상 필요가 없으므로일반적으로 사용하는 Handler 객체를 생성한다.Handler 객체를 만들어 변수에 할당해두면 이 객체의 post 메서드를 호출 할 수 있다.이 코드에서 보는 것처럼 post 메서드로 전달되는 Runnable 객체는 스레드의 작업 결과물로 만들어지는데이터를 처리해야 한다. 따라서 결과물을 화면에 보여주어야 하는 부분이 있을 경우 new 연산자로Runnable 인터페이스를 구현하는 새로운 객체를 만들어 사용하는 것이 일반적이다." }, { "title": "Key Pad", "url": "/posts/KeyPad/", "categories": "Android, Widget", "tags": "android, keypad", "date": "2022-01-19 21:25:00 +0900", "snippet": "키패드 제어하기입력 상자에 포커스를 주면 자동으로 소프트 키패드가 생겨 입력할 수 있는 상태가 된다.이렇게 자동으로 열리고 닫힐 경우에는 별도의 코딩 없이 사용할 수 있지만 필요에 의해코드를 통해 직접 키패드를 열거나 닫을 수 도 있다.예를 들어, 로그인 화면에서 [로그인] 버튼을 눌러 성공적으로 로그인 되었을 때 열려 있던소프트 키패드를 코드에서 닫히게 만들어야 한다.키패드와 관련된 기능은 InputMethodManager 객체로 사용할 수 있다.이 객체는 시스템 서비스이므로 getSystemService 메서드로 참조 후 다음과 같은 메서드를 사용해키패드를 열거나 닫을 수 있다.boolean showSoftInput(View view, int flags)boolean hideSoftInputFromWinow(IBinder windowToken, int flags [, ResultReceiver resultReceiver ])키 패드 감추기이 상태로 화면을 구성하고 앱을 실행 시키면 키패드가 자동으로 올라온다.자동으로 올라오지 않게 하려면 /app/manifests/AndroidManifest.xml 을 아래와 같이 태그를 추가한다.AndroidManifest.xml ...&amp;lt;activity android:name=&quot;.MainActivity&quot; android:windowSoftInputMode=&quot;stateHidden&quot; ...그리고 입력 상자를 누르면 숫자 키패드가 보이게 하기 위해 입력 상자의 inputType을 number로 바꾼다.버튼을 클릭하면 키패드를 사라지게 하기 위해 아래와 같이 코드를 작성한다.MainActivity.javapublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = findViewById(R.id.button); button.setOnClickListener((v)-&amp;gt;{ if(getCurrentFocus() != null){ // InputMetho 객체 참조하기 InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(INPUT_METHOD_SERVICE); // 키 패드 감추기 inputMethodManager.hideSoftInputFromWindow(getCurrentFocus().getWindowToken(),0); } }); }}결과위처럼 버튼을 누르면 키패드가 사라진다." }, { "title": "Web View", "url": "/posts/WebView/", "categories": "Android, Widget", "tags": "android, webview, view", "date": "2022-01-19 20:55:00 +0900", "snippet": "앱 화면에 웹 브라우저앱 화면에 웹 브라우저를 넣을려면 웹 뷰를 사용하면 된다.XML 레이아웃에서는 &amp;lt;WebView&amp;gt; 태그로 정의하면 된다.또한 항상 매니페스트에 인터넷 접속 권한이 등록 되어 있어야 한다.다음은 매니페스트에 등록해야 할 인터넷 권한이다.&amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&amp;gt;&amp;lt;application:usesCleartextTraffic=&quot;true&quot;/&amp;gt;app/manifests/AndroidManifest.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.web&quot;&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&amp;gt; &amp;lt;application:usesCleartextTraffic=&quot;true&quot; ..... &amp;lt;/application&amp;gt;&amp;lt;/manifest&amp;gt;예시activity_main.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &amp;gt; &amp;lt;LinearLayout android:orientation=&quot;horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; &amp;gt; &amp;lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot; 열기 &quot; android:padding=&quot;4dp&quot; android:textSize=&quot;20sp&quot; /&amp;gt; &amp;lt;EditText android:id=&quot;@+id/editText&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;20sp&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;WebView android:id=&quot;@+id/webView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&amp;gt;&amp;lt;/LinearLayout&amp;gt;MainActivity.javapublic class MainActivity extends AppCompatActivity { EditText editText; WebView webView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText = findViewById(R.id.editText); webView = findViewById(R.id.webview); // 웹뷰 설정을 수정하기 위해 웹 설정 객체 불러오기 WebSettings webSettings = webView.getSettings(); // 자바 스크립트 사용 허용 webSettings.setJavaScriptEnabled(true); webView.setWebViewClient(new ViewClient()); Button button = findViewById(R.id.button); button.setOnClickListener((v)-&amp;gt;{ // 버튼 클릭 시 사이트 로딩하기 webView.loadUrl(editText.getText().toString()); }); } /* webView 객체에 웹페이지를 보여주기 위해서는 WebViewClient를 상속한 객체를 만들어 WebView에 설정해야함 */ private class ViewClient extends WebViewClient{ @Override public boolean shouldOverrideUrlLoading(final WebView view, final String url){ // 웹 페이지를 로딩하여 화면에 보여주기 // 이 메서드는 원격지의 웹 페이지를 열거나 로컬에 저장된 HTML 파일도 열 수 있음 view.loadUrl(url); return true; } }}결과" }, { "title": "Page Sliding", "url": "/posts/PageSlide/", "categories": "Android, Animation", "tags": "android, animation, slid, page, pageslide", "date": "2022-01-19 20:21:00 +0900", "snippet": "페이지 슬라이딩페이지 슬라이딩은 버튼을 눌렀을 때 보이지 않던 뷰가 슬라이딩 방식으로 나타나는 기능이다.여러 뷰를 중첩으로 해두었다가 하나 씩 전환하면서 보여주는 방식에서 애니메이션을 적용 시킨 것이다.대표적인 예시로 바로가기 메뉴가 있다. [출처 Do it! Android 프로그래밍]예시activity_main.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#3F51B5&quot; android:orientation=&quot;vertical&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;TextView&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;LinearLayout android:id=&quot;@+id/page&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#FFEB3B&quot; android:orientation=&quot;vertical&quot; android:visibility=&quot;gone&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:text=&quot;Area 1&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView3&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:text=&quot;Area 2&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;right|center_vertical&quot; android:orientation=&quot;vertical&quot;&amp;gt; &amp;lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt;&amp;lt;/FrameLayout&amp;gt;res/anim/translate_right&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt; &amp;lt;translate android:fromXDelta=&quot;0%p&quot; android:toXDelta=&quot;100%p&quot; android:duration=&quot;500&quot; android:repeatCount=&quot;0&quot; android:fillAfter=&quot;true&quot; /&amp;gt;&amp;lt;/set&amp;gt;res/anim/translate_left&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt; &amp;lt;translate android:fromXDelta=&quot;100%p&quot; android:toXDelta=&quot;0%p&quot; android:duration=&quot;500&quot; android:repeatCount=&quot;0&quot; android:fillAfter=&quot;true&quot; /&amp;gt;&amp;lt;/set&amp;gt;MainActivity.javapublic class MainActivity extends AppCompatActivity { boolean isPageOpen = false; Animation translateLeftAnim; Animation translateRightAnim; LinearLayout page; Button button; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); page = findViewById(R.id.page); // 애니메이션 xml 로딩 translateLeftAnim = AnimationUtils.loadAnimation(this,R.anim.translate_left); translateRightAnim = AnimationUtils.loadAnimation(this, R.anim.translate_right); // 애니메이션 리스너 등록 (End, Start, Repeat) 사용하기 위함 SlidingPageAnimationListener animListener = new SlidingPageAnimationListener(); translateLeftAnim.setAnimationListener(animListener); translateRightAnim.setAnimationListener(animListener); // 버튼 리스너 등록 button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View view){ if(isPageOpen) // 서브 페이지가 켜져 있으면 지우기 page.startAnimation(translateRightAnim); else{ // 서브 페이지를 보이게함 page.setVisibility(View.VISIBLE); page.startAnimation(translateLeftAnim); } } }); } private class SlidingPageAnimationListener implements Animation.AnimationListener{ public void onAnimationEnd(Animation animation){ if(isPageOpen){ page.setVisibility(View.INVISIBLE); button.setText(&quot;OPEN&quot;); isPageOpen = false; }else{ button.setText(&quot;Close&quot;); isPageOpen = true; } } @Override public void onAnimationStart(Animation animation) {} @Override public void onAnimationRepeat(Animation animation) {} }결과서브 페이지를 켜면 나오는 Area1 Area 2는 실제 앱을 만들 때 이 각각의 영역에 필요한 뷰를넣어 화면을 구성할 수 있다." }, { "title": "트윈 애니메이션 - 여러가지 액션 효과", "url": "/posts/TwinAnim_attr/", "categories": "Android, Animation", "tags": "android, animation, tweend", "date": "2022-01-19 01:31:00 +0900", "snippet": "트윈 애니메이션 - 여러가지 액션 효과위치이동한 곳에서 다른 곳으로 부드럽게 움직이는 효과를 주기 위해서는 translate 태그를 사용하면 된다./app/res/anim/text.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromXDelta=&quot;0%p&quot; android:toXDelta=&quot;-100%p&quot; android:duration=&quot;10000&quot; android:repeatCount=&quot;-1&quot; android:fillAfter=&quot;true&quot; /&amp;gt;fromXDelta, fromYDelta 는 시작 위치이고 toXDelta, toYDelta 는 종료 위치이다.fromXDelta가 0%이므로 원래 위치의 X좌표에서 시작하고 toXDelta가 음수 값이므로 왼쪽으로이동하게 된다. duration은 지속 시간이고 10초 동안 애니메이션이 작동한다.repeatCount는 애니메이션 반복 할 횟 수이고 -1이므로 무한 반복된다.fillAfter 속성이 false이면 애니메이션이 끝나고 원래 위치로 돌아가고 true면 원래 위치로 돌아오지 않는다.결과회전 효과 주기회전 효과를 주고 싶으면 roate 태그를 이용하면 된다./app/res/anim/text.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromDegrees=&quot;0&quot; android:toDegrees=&quot;360&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:duration=&quot;5000&quot; /&amp;gt;fromDegress는 시작 각도, toDegrees는 종료 각도이고 위처럼 0부터 360으로 설정하면 한 바퀴 회전한다.반대로 회전 시키고 싶으면 fromDegress 값을 0, toDegress값은 -360으로 설정하면 된다.여기서 pivotX, pivotY을 설정 하지 않으면 회전의 중심축이 (0,0)으로 설정된다. 아래 예시를 보자.회전하는 축을 중앙으로 잡고 싶으면 pivotX와 pivotY의 값을 50%로 설정해주면 된다.결과투명도 액션 효과 주기알파 값을 이용한 투명도 변환은 대상을 천천히 보이게 하거나 보이지 않게 하고 싶을 때 또는하나의 뷰 위에 다른 뷰를 겹쳐 보이게 할 때 사용한다./app/res/anim/text.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot; android:duration=&quot;5000&quot; /&amp;gt;알파 값의 범위는 0.0 ~ 1.0 이고 0.0은 완전히 투명 상태이다. (객체가 아예 보이지 않음)반대로 1은 완전히 보이는 상태이다. (투명 효과가 적용되지 않음)결과애니메이션 확대/축소scale 예제애니메이션 속도 조절하기애니메이션 효과를 빠르거나 느리게 주고 싶으면 Interpolator를 사용하면 된다. 속성 설명 accelerate_interpolator 애니메이션 효과를 점점 빠르게 나타나도록 만든다. decelerate_interpolator 애니메이션 효과를 점점 느리게 나타나도록 만든다. accelerate_decelerate_interpolator 애니메이션 효과를 점점 빠르다가 느리게 나타나도록 만든다. anticipate_interpolator 애니메이션 효과를 시작 위치에서 조금 뒤로 당겼다가 시작하도록 만든다. overshoot_interpolator 애니메이션 효과를 종료 위치에서 조금 지나쳤다가 종료되도록 만든다. anticipate_overshoot_interpolator 애니메이션 효과를 시작 위치에서 조금 뒤로 당겼다가 시작한 후 종료 위치에서 조금 지나쳤다가 종료되도록 만든다. bounce_interpolator 애니메이션 효과를 종료 위치에서 튀도록 만든다. 예제&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/bounce_interpolator&quot;&amp;gt; &amp;lt;alpha android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot; android:duration=&quot;5000&quot;/&amp;gt;&amp;lt;/set&amp;gt;아래 표에 나온 것 처럼 자바 코드에서 new 연산자로 직접 만들 수도 있다. 기능 객체 위치 이동 &amp;lt;translate&amp;gt; -&amp;gt; TranslateAnimation 회전 &amp;lt;rotate&amp;gt; -&amp;gt; RotateAnimation 확대/축소 &amp;lt;scale&amp;gt; -&amp;gt; ScaleAnimation 투명도 &amp;lt;alpha&amp;gt; -&amp;gt; AlphaAnimation 애니메이션 집합 &amp;lt;set&amp;gt; -&amp;gt; AnimationSet " }, { "title": "트윈 애니메이션", "url": "/posts/Tweened_Animation/", "categories": "Android, Animation", "tags": "android, animation, tweend", "date": "2022-01-18 01:13:00 +0900", "snippet": "Tweened Animation안드로이드는 애니메이션을 간편하게 적용할 수 있는 여러가지 방법을 제공한다.그중에서 트윈 애니메이션(Tweened Animation)이 가장 간단하면서 일반적인 방법으로 사용된다.이는 이동, 확대/축소, 회전과 같이 일정한 패턴으로 움직이는 애니메이션을 구현할 때 사용한다.애니메이션이 어떻게 동작할지 정의한 정보는 XML로 만든다.이렇게 만든 XML 정보는 자바 소스에서 애니메이션 객체로 로딩한 후 뷰 객체의startAnimation 메서드를 사용해서 애니메이션을 동작하게 만들 수 있다.순서를 정리하자면 아래와 같다.1. 애니메이션이 어떻게 동작하는지를 XML로 정의한다.2. XML을 자바 파일로 로딩하여 애니메이션 객체로 만든다.3. 뷰에 애니메이션을 적용하여 동작 시킨다.동작시킬 수 있는 트윈 애니메이션의 대상과 애니메이션 효과는 아래와 같다. 구분 이름 설명 대상 뷰 View는 위젯이나 레이아웃을 모두 포함한다. 예를 들어, 텍스트 뷰나 리니어 레이아웃에 애니메이션을 적용 시킬 수 있다. 대상 그리기 객체 다양한 Drawable에 애니메이션을 적용시킬 수 있다. ShapeDrawable은 캔버스에 그릴 도형을 지정할 수 있으며, BitmapDrawable은 비트맵 이미지를 지정할 수 있다. 효과 위치 이동 translate로 정의한 액션은 대상의 위치를 이동시키는 데 사용하는 효과이다. 효과 확대/축소 Scale로 정의한 액션은 대상의 크기를 키우거나 줄이는데 사용되는 효과이다. 효과 회전 Rotate로 정의한 액션은 대상을 회전 시키는데 사용되는 효과이다. 효과 투명도 Alpha로 정의한 액션은 대상의 투명도를 조절하는데 사용되는 효과이다. 트윈 애니메이션의 액션(Action) 정보는 XML 리소스로 정의하거나 소스 코드에서 직접 객체로 만들 수 있다.XML 리소스로 정의할 때는 /app/res/anim 폴더의 밑에 확장자를 xml로 해야한다.이렇게 하면 애니메이션 액션 정의는 빌드할 때 컴파일 되어 설치 파일에 포함된다.애니메이션 적용해보기애니메이션 액션 정보를 만들기 위해 /app/res 폴더안에 admin 폴더를 생성한다.폴더안에 scale.xml 파일을 만든 후 아래와 같이 대상을 두배로 확대하는 스케일 액션을 정의하자.scale.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt; &amp;lt;scale android:duration=&quot;2500&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:toXScale=&quot;2.0&quot; android:toYScale=&quot;2.0&quot; /&amp;gt; &amp;lt;scale android:startOffset=&quot;2500&quot; android:duration=&quot;2500&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:toXScale=&quot;0.5&quot; android:toYScale=&quot;0.5&quot; /&amp;gt;&amp;lt;/set&amp;gt;시작 시간은 startOffset이고 지정하지 않으면 애니메이션은 바로 시작한다.duration은 애니메이션이 지속되는 시간이고 단위는 ms이다.scale 태그는 대상을 확대하거나 축소할 때 사용되는데, 크기를 변경하려는 축의 정보는X축과 Y축에 대해 pivotX와pivotY로 지정한다.fromXScale과fromYScale은 시작할 때의 확대/축소 비율이고, toXScale과toYScale은끝날 때의 확대/축소 비율이다. 여기서는 1.0으로 시작하여 2.0으로 끝나므로 원래 크기에서 2배크기로 확대되는 애니메이션이 작동한다.그 후 버튼을 추가 한 후 아래와 같이 애니메이션을 적용 시키는 코드를 작성하자.MainActivity.javapublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { // 라소스에 정의한 애니메이션 액션 로딩 Animation anim = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.scale); // 뷰의 애니메이션 시작 view.startAnimation(anim); } }); }}XML 리소스에 정의된 애니메이션 액션 정보를 로딩하기 위해 AnimationUtils 클래스의 loadAnimation 메서드를 사용한다.loadAnimation 메서드는 아래와 같은 형태이다.public static Animation loadAnimation(Context context, int id)두번째 매개 변수 id는 XML 리소스에 정의된 애니메이션 액션의 id 값이다.결과화면이 사용자에게 보이는 시점에 애니메이션 시작하는 방법화면이 사용자에게 보이자마자 애니메이션을 시작하고 싶다면 애니메이션 시작점은onWindowFocusChanged 메서드가 호출되는 시점, 즉 윈도우가 포커스를 받는 시점이어야 한다.onWindowFocusChanged 메서드 내에서 파라미터로 전달되는 hasFocus 변수의 값이 true일 경우에각각의 애니메이션 객체에 대해 start 메서드를 호출함으로써 애니메이션이 시작되도록 하면 된다.윈도우가 다른 윈도우에 의해 가려지거나 할 때는 hasFocus 값이 false가 되므로 애니메이션 객체의rest 메서드를 호출하여 초기 상태로 되돌릴 수 있다.MainActivity.javapublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } @Override public void onWindowFocusChanged(boolean hasFocus){ super.onWindowFocusChanged(hasFocus); Button button = findViewById(R.id.button); Animation anim = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.scale); if(hasFocus == true) button.startAnimation(anim); else if(hasFocus == false) anim.reset(); }}위 처럼 어플을 키자마자 애니메이션이 작동한다.Animation Listener 메서드 설명 public void onAnimationStart(Animation animation) 애니메이션이 시작되기 전에 호출된다. public void onAnimationEnd(Animation animation) 애니메이션이 끝났을 때 호출된다. public void onAnimationRepeat(Animation animation) 애니메이션이 반복될 때 호출된다. " }, { "title": "Spinner (콤보 박스)", "url": "/posts/Spinner/", "categories": "Android, Widget", "tags": "android, spinner", "date": "2022-01-18 00:53:00 +0900", "snippet": "스피너 사용하기리스트나 격자 모양으로 여러 아이템을 보여주는 경우가 많지만 그 외에도 여러 아이템 중에서하나를 선택하는 위젯으로 스피너(Spinner)가 있다.스피너는 일반적으로 윈도우에서 콤보 박스라고 한다.아이폰이나 안드로이드 단말에서는 손가락으로 쉽게 터치할 수 있도록 별도의 창으로선택할 수 있는 데이터 아이템들이 표현된다.예제MainActivity.javapublic class MainActivity extends AppCompatActivity { TextView textView; String [] items = {&quot;mike&quot;, &quot;angel&quot;, &quot;corw&quot;, &quot;john&quot;,&quot;ginnie&quot;, &quot;sally&quot;, &quot;cohen&quot;, &quot;rice&quot; }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); Spinner spinner = findViewById(R.id.spinner); ArrayAdapter&amp;lt;String&amp;gt;adapter = new ArrayAdapter&amp;lt;String&amp;gt;(this, android.R.layout.simple_spinner_item, items); adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); spinner.setAdapter(adapter); spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() { @Override //&amp;lt;?&amp;gt;는 &amp;lt; ? extends Object &amp;gt;와 같음 public void onItemSelected(AdapterView&amp;lt;?&amp;gt; adapterView, View view, int position, long id) { textView.setText(items[position]); } @Override public void onNothingSelected(AdapterView&amp;lt;?&amp;gt; adapterView) { textView.setText(&quot;&quot;); } }); }}아이템이 하나 선택되면 onItemSelected 메서드가 자동으로 호출된다.그리고 선택된 값은 setText 메서드를 사용해 텍스트로 표시한다.스피너 객체가 아이템 선택 이벤트 처리를 할 수 있도록 사용하는 리스너는 OnItemSelectedListener이다.스피너 객체도 선택 위젯이므로 setAdapter 메서드의 매개 변수로 어댑터 객체를 전달해야 한다.여기서는 어댑터를 직접 정의 하지 않고 API에서 제공하는 기본 어댑터인 ArrayAdapter로 배열로 된데이터를 아이템으로 추가한다. ArrayAdapter를 만들때는 simpe_spinner_item이라는 레이아웃을 지정한다simple_spinner_item 레이아웃도 스피너를 간단하게 사용할 수 있도록 API에서 제공하는 레이아웃이다.그리고 스피너는 항목을 선택하기 위한 창이 따로 있기 때문에 항목을 선택하는 창을 위한 레이아웃도설정해주어야 한다. 이때 사용 하는 메서드는 setDropDownViewResource 메서드이다.ArrayAdapter 생성자의 형태는 아래와 같다.public ArrayAdapter(Context context, int textViewResourceld, T[] objects)첫 번째 매개변수는 Context 객체이므로 this를 전달하면 된다.두 번째 매개변수는 뷰를 초기화할 때 사용되는 XML 레이아웃의 리소스 ID 값이다.여기서는 android.R.layout.simple_spinner_item을 전달하였는데 이 레이아웃은 문자열을 아이템으로보여주는 단순 스피너 아이템의 레이아웃이고 이 레이아웃 안에는 텍스트 뷰 객체가 들어있다.세번째 매개변수는 아이템으로 보일 문자열 데이터들의 배열이다." }, { "title": "ViewHolder Pattern", "url": "/posts/ViewHolder/", "categories": "Java, Design_Pattern", "tags": "android, viewholder, pattern, recyclerview, adapter", "date": "2022-01-17 21:56:00 +0900", "snippet": "ViewHolder PatternRecyclerView를 공부하던 중 ViewHolder 개념이 자주 나오는데그에 대한 설명이 책에 없어서 따로 정리하고자 글을 쓴다.RecyclerView는 Adapter Pattern을 통해 리스트 형태로 표시할 데이터와 리스트 아이템 각각의 레이아웃을 연결하는 방식이다.자신만의 어댑터를 만들 때 RecyclerView.Adapter를 상속하는데 이 때 RecyclerView.ViewHolder를 넘겨 줘야 하고OnCreateViewHolder(), onBindViewHolder() 등의 추상 메소드를 반드시 구현해줘야 한다. 어댑터를 만드는 과정은 이 링크의 PersonAdapter.java를 참조필요한 이유?RecyclerView 이전에 그의 조상인 ListView가 있었다고 한다.ListView에서 특정 데이터들을 리스트 형태로 보여주는 원리는 아래와 같다.데이터 각각에 대해 아이템의 레이아웃을 구성하는 View 를 inflate 하고, Inflating 된 뷰에서 findViewById()를 통해 데이터를 끼워 맞춰주면서 리스트 형태로 만들어준다.하지만 뷰를 매번 인플레이팅하는 작업은 무거운 작업이었기 때문에 매끄로운 스크롤을 보장하지 못했다.따라서 getView() 메소드 내의 convertView라는 녀석을 활용하여, 스크롤이 내려가면서맨 위에 있던 아이템들은 화면에서 사라지고다른 새로운 아이템을 구성해야할 때 뷰를 새롭게 인플레이팅하기보다,기존에 사용하던 View 를 다시 갖다 쓰는 방법을 사용하곤 했다. 즉, 재활용성을 강조한 것이다.이렇게 재활용성을 높였지만, 뷰를 구성하기 위한 findViewById() 호출 역시 매우 많은 비용이 드는 작업이기에데이터의 개수가 늘어나는 만큼 성능 저하가 발생하게 된다.findViewById()이 고비용 작업인 이유일반 뷰 (TextView, ImageView 등 단일 뷰 자체)에 대한 findViewById()는 자기 자신의 ID만 확인하기 때문에 비용이 클 이유가 없다.findViewById() 내부 구현@Nullablepublic final &amp;lt;T extends View&amp;gt; T findViewById(@IdRes int id) { if (id == NO_ID) { return null; } return findViewTraversal(id);}protected &amp;lt;T extends View&amp;gt; T findViewTraversal(@IdRes int id) { if (id == mID) { return (T) this; } return null;}하지만 여러 개의 자식 뷰를 포함하고 있는 레이아웃은, 자식들까지 모두 확인하는 과정이 필요하다.이 과정은 DFS 탐색과 같은데 매번 자식 뷰를 모두 확인해와서 비용이 크게 발생할 수 밖에 없다.@Overrideprotected &amp;lt;T extends View&amp;gt; T findViewTraversal(@IdRes int id) { if (id == mID) { return (T) this; } final View[] where = mChildren; final int len = mChildrenCount; for (int i = 0; i &amp;lt; len; i++) { View v = where[i]; if ((v.mPrivateFlags &amp;amp; PFLAG_IS_ROOT_NAMESPACE) == 0) { v = v.findViewById(id); if (v != null) { return (T) v; } } } return null;}따라서 findViewById()의 호출 횟수를 줄이기 위해 탄생하게 된 것이 바로 ViewHolder Pattern이다.ViewHolder Pattern 개념findViewById()를 반복적으로 호출하는 것을 막기 위해 ViewHolder라는 디자인 패턴이 등장했다. ViewHolder 패턴은, 각 뷰의 객체를 ViewHolder 에 보관함으로써 뷰의 내용을 업데이트하기 위한 findViewById() 메소드 호출을 줄여 효과적으로 성능 개선을 할 수 있는 패턴이다. ViewHolder 패턴을 사용하면, 한 번 생성하여 저장했던 뷰는 다시 findViewById() 를 통해 뷰를 불러올 필요가 사라지게 된다.만약 데이터를 1번부터 10번까지 리스트 형태로 보여줄 때,스마트폰의 화면의 크기 때문에 5개까지 밖에 못 보여준다고 가정해보자.사용자가 스크롤을 하게 되면, 최상단에 있던 1번이 눈에 보이지 않게 될 것이다.그와 동시에 6번이 아이템이 화면에 새롭게 보인다. 자 ! 그러면 findViewById()를 일일히 호출하여서레이아웃에 데이터를 바인딩하지 않고, 기존 1번 아이템을 그려줄 때 사용했던 View를 재사용하여이미 불러왔던 레이아웃에 데이터만 채워주는 것이다. 이렇게 하면 재사용성을 높이고불필요한 비용을 줄이게된다.하지만 ListView에서는 일일히 ViewHolder 생성 코드를 직접 작성해줘야 하는 단점이 있었다.이러한 단점을 보완하기 위해 프레임워크 차원에서 강제로 ViewHolder 패턴을 구현하도록 해줘야하는RecyclerView라는게 탄생 했다.RecyclerView 에서의 ViewHolderRecyclerView.Adapter 를 상속하여 어댑터를 만들 때, onCreateViewHolder() 과 onBindVIewHolder(), getItemCount() 이렇게 세 추상 메소드를 반드시 구현해줘야 한다.onCreateViewHolder()ViewHolder 를 새로 만들어야 할 때 호출되는 메소드로,이를 통해 각 아이템을 위한 XML 레이아웃을 활용한 뷰 객체를 생성하고 이를 뷰 홀더 객체에 담아 리턴해준다.다만 ViewHolder 가 아직 어떠한 데이터에 바인딩된 상태가 아니기 때문에각 뷰의 내용 (TextView 의 Text 등) 은 채우지 않는다.뷰의 내용을 채워야 하는 경우 (해당 아이템이 화면에 보여지는 경우)아래 메소드에서 레이아웃의 내용들을 채우게 된다.onBindViewHolder()ViewHolder 를 어떠한 데이터와 연결할 때 호출되는 메소드로,이를 통해 뷰 홀더 객체들의 레이아웃을 채우게 된다.position 이라는 파라미터를 활용하여 데이터의 순서에 맞게 아이템 레이아웃을 바인딩해줄 수 있다.getItemCount()뷰 홀더가 관리하는 아이템의 개수를 반환하는 메소드이다." }, { "title": "Adapter Pattern", "url": "/posts/AdapterPattern/", "categories": "Java, Design_Pattern", "tags": "android, adapter", "date": "2022-01-17 01:10:00 +0900", "snippet": "Adapter 패턴Android 공부를 계속하다 보니 Adpater Class 개념이 많이 나와서 정리해보고자 한다.Adapter 패턴은 이름 그대로 어댑터 역할을 한다.만약, 직류 12볼트로 작동하는 노트북을 교류 100볼트의 AC 전원에 연결한다고 가정하자.이때 우리는 교류 100볼트를 직류 12볼트로 교환해줄 어댑터가 필요하다.adapter는 개조시키는 것 이라는 의미를 가지고 있고,어댑터의 역할은 직류 12볼트의 컴퓨터를 교류 100볼트의 환경에 맞게 바꾸는 것이다.이미 제공되어 있는 것과 필요한 것 사이의 차이를 없애주는 디자인 패턴이 Adapter 패턴이다.Adapter 패턴은 Wrapper 패턴으로 불리기도 하고 일반 상품을 예쁜 포장지로 싸서선물용 상품으로 만드는 것처럼, 무엇인가를 한번 포장해서 다른 용도로 사용할 수 있게교환해주는 것과 비유 할 수 있다.Adapter 패턴에는 다음과 같이 두가지 종류가 있다. 클래스에 의한 Adapter Pattern (상속을 사용한 Adapter 패턴) 인스턴스에 의한 Adapter Pattern (위임을 사용한 Adapter 패턴)Adapter Pattern StructureTarget(대상)의 역할 지금 필요한 메소드를 결정한다. 노트북을 작동 시키기 위한 직류 12볼트에 해당한다. Print 인터페이스 (상속)나 Print 추상 클래스 (위임)가 이역할을 한다.Client(의뢰자)의 역할 Target 역할의 메소드를 사용해서 일을 한다. 직류 12볼트로 움직이는 노트북에 해당한다. Main 클래스가 이 역할을 한다.Adaptee의 역할 이미 준비되어 있는 메소드를 가지는 역할을 한다. 교류 100볼트에 해당한다. Banner 클래스가 이 역할을 한다.Adapter의 역할 Adaptee 역할의 메소드를 사용해서 어떻게든 Target 역할을 만족시키기 위한 것이 Adapter 패턴의 목적이며, Adpter 역할에 해당하며, PrintBanner 클래스가 이 역할을 한다.왜 사용할까?이미 존재하고 있는 클래스를 이용하는 경우가 자주 있다.특히 그 클래스가 충분한 테스트를 받아서 버그가 적으며 실제로 지금까지 사용된 실적이 있다면어떻게든 그 클래스를 부품으로 재이용하고 싶을것이다.Adapter 패턴은 기존의 클래스를 개조해서 필요한 클래스를 만든다.이 패턴을 이용하여 메소드를 더욱 빠르게 만들 수 있다.만약 버그가 발생해도 기존의 클래스(Adapter의 역할)에는 버그가 없으므로Adapter 역할의 클래스를 중점적으로 조사하면 되고, 프로그램 검사도 상당히 쉬워진다.상속을 이용한 Adapter PatternBanner class는 미리 벽 단자에 붙어 준비 되어 있는 교류 100V로 생각하면 된다. (이미 제공되어 있는 것)Print Banner class는 100볼트를 12볼트로 교환해 주는 어댑터 역할을 한다.Print Interface는 직류 12볼트 역할이라고 생각하면 된다. 전원의 비유 예제 프로그램 제공되고 있는 것 (교류 100V) Banner Class (showWithParen, showWithAster) 교환장치(어댑터) PrintBanner 클래스 필요한 것직류 (12V) Print Interface (printWeak,printStrong) 구조는 아래와 같다.Banner.javapublic class Banner { private String string; public Banner(String string) { this.string = string; } public void showWithParen() { System.out.println(&quot;(&quot; + string + &quot;)&quot;); } public void showWithAster() { System.out.println(&quot;*&quot; + string + &quot;*&quot;); }}PrintBanner.javapublic class PrintBanner extends Banner implements Print{ public PrintBanner(String string) { super(string); } public void printWeak() { showWithParen(); } public void printStrong() { showWithAster(); }}Print.javapublic interface Print { public abstract void printWeak(); public abstract void printStrong();}Main.javapublic class Main { public static void main(String[] args) { Print p = new PrintBanner(&quot;Hello&quot;); p.printWeak(); p.printStrong(); }}Main Class 에서 PrintBanner의 인스턴스를 Print 인터페이스형의 변수로 대입한 것에 주의해야 한다.Banner 클래스나 showWithParen 메소드나 showWithAster 메소드는 Main 클래스의 소스 코드상에서완전히 감추어져 있습니다.마치 노트북이 직류 12볼트만 제공하면 제대로 작동하지만,제대로 작동할 수 있도록 어댑터를 통해서 교류 100볼트가 제공되고 있는것은 모르는 것과 같다.즉 Main 클래스에서 PrintBanner 클래스를 보면 이 클래스가 어떻게 구현되어 있는지 모른다.이 뜻은 Main 클래스를 전현 변경하지 않고도 PrintBanner 클래스의 구현을 바꿀 수 있다는 것이다.위임을 사용한 Adapter Pattern상속을 이용한 방법과 비슷한데 Adapter 역할을 하는 Print.java 파일이전에는 interface로 선언을 했지만 위임을 사용하는 방법에는 추상 클래스로 선언을 한다.Main.class와 Banner.class는 위와 같다.Print.classpublic abstract class Print { public abstract void printWeak(); public abstract void printStrong();}PrintBanner.classpublic class PrintBanner extends Print{ private Banner banner; public PrintBanner(String string) { this.banner = new Banner(string); } public void printWeak() { banner.showWithParen(); } public void printStrong() { banner.showWithAster(); }}" }, { "title": "Recycler View", "url": "/posts/RecyclerView/", "categories": "Android, User_Interface", "tags": "android, layout", "date": "2022-01-16 22:47:00 +0900", "snippet": "Recycler View리스트 모양으로 보여줄 수 있는 위젯으로 Recycler View가 있다.Recycler View는 기본적으로 좌우 상하 스크롤을 만들 수 있고 각각의 아이템이 화면에 보일 때메모리를 효율적으로 사용하도록 캐시(Cache) 메커니즘이 규현되어 있다.Recycler View를 이용해 리스트 모양으로 보여주기Recycler View는 선택 위젯이기 때문에 어댑터가 데이터 관리와 뷰 객체 관리를 담당한다.따라서 Recycler Vie는 껍데기 역할을 한다고 생각하면 되고, 어댑터를 만들기 전에 어댑터 안에 들어갈각 아이템의 데이터를 담아둘 클래스를 하나 정의해야 한다.여기서는 Person 클래스를 만들어 보자.Getter와 Setter를 쉽게 만드는 방법은 클래스 중괄호 안에 커서를 두고 오른쪽 마우스 버튼을 눌러[Generate-&amp;gt; Getter and Setter] 메뉴를 이용하면 더욱 쉽고 빠르게 만들 수 있다.Person.javapublic class Person { String name; String mobile; public Person(String name, String mobile){ this.name = name; this.mobile = mobile; } public String getName() { return name; } public String getMobile() { return mobile; } public void setName(String name) { this.name = name; } public void setMobile(String mobile) { this.mobile = mobile; }}어댑터 클래스도 새롭게 정의 해줍니다.PersonAdapter.javapublic class PersonAdapter extends RecyclerView.Adapter&amp;lt;PersonAdapter.ViewHolder&amp;gt;{ ArrayList&amp;lt;Person&amp;gt; items = new ArrayList&amp;lt;Person&amp;gt;(); @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int viewType) { LayoutInflater inflater = LayoutInflater.from(viewGroup.getContext()); // 인플레이션을 통해 뷰 객체를 만들기 View itemView = inflater.inflate(R.layout.person_item, viewGroup, false); // 뷰홀더 객체를 생성하면서 뷰 객체를 전달하고 그 뷰홀더 객체를 반환하기 return new ViewHolder(itemView); } @Override public void onBindViewHolder(@NonNull ViewHolder viewHolder, int position) { Person item = items.get(position); viewHolder.setItem(item); } @Override public int getItemCount() { return items.size(); } public void addItem(Person item){ items.add(item); } public void setItem(ArrayList&amp;lt;Person&amp;gt; items){ this.items = items; } public Person getItem(int position){ return items.get(position); } public void setItem(int position, Person item){ items.set(position, item); } static class ViewHolder extends RecyclerView.ViewHolder{ TextView textView; TextView textView2; public ViewHolder(View itemView){ // 뷰홀더 생성자로 전달되는 뷰 객체 참조하기 super(itemView); // 뷰 객체에 들어 있는 텍스트 뷰 참조하기 textView = itemView.findViewById(R.id.textView); textView2 = itemView.findViewById(R.id.textView2); } public void setItem(Person item){ textView.setText(item.getName()); textView2.setText(item.getMobile()); } }}리스트 형태로 보일 때 각각의 아이템은 뷰로 만들어지며각각의 아이템을 위한 뷰는 뷰홀더에 담아두게 된다.뷰홀더 역할을 하는 클래스를 PersonAdapter 클래스 안에 넣어둔다고 생각하자.setItem 메서드는 뷰홀더에 들어있는 뷰 객체의 데이터를 다른 것으로 보이도록 하는 역할을 한다.이 어댑터에 규현되어야 하는 중요한 메서드는 3가지이다.getItemCount 메서드는 어댑터에서 관리하는 아이템의 개수를 반환한다.onCreateViewHolder와 onBindViewHolder 메서드는 뷰홀더 객체가 만들어질 때와 재사용될 때 자동 호출된다.Recycler View에 보이는 여러 개의 아이템은 내부에서 캐시되기 때문에 아이템 개수만큼객체로 만들어 지지 않는다 예를 들어, 아이템이 만 개라고 하더라도 이 아이템을 위해만 개의 뷰 객체가 만들어 지지 않는다.뷰홀더가 새로 만들어지는 시점에는 onCreateViewHolder 메서드가 호출되고그 안에서는 각 아이템을 위해 정의한 XML 레이아웃을 이용해 뷰 객체를 만들어 준다.onBindViewHolder 메서드는 뷰홀더가 재사용될 때 호출되므로 뷰 객체는 기존 것을 그대로 사용하고데이터만 바꿔준다. 이제 어댑터 안에 Person 객체들을 만들어 넣어야 하므로 아래와 같이 파일을 수정한다.MainActivity.javapublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); RecyclerView recyclerView = findViewById(R.id.recyclerView); LinearLayoutManager layoutManager = new LinearLayoutManager(this,LinearLayoutManager.VERTICAL, false); recyclerView.setLayoutManager(layoutManager); PersonAdapter adapter = new PersonAdapter(); adapter.addItem(new Person(&quot;김민수&quot;,&quot;010-1000-1000&quot;)); adapter.addItem(new Person(&quot;김하늘&quot;,&quot;010-2000-2000&quot;)); adapter.addItem(new Person(&quot;홍길동&quot;,&quot;010-3000-3000&quot;)); // 리싸이클러뷰에 어댑터 설정하기 recyclerView.setAdapter(adapter); }}리싸이클러뷰에는 레이아웃 매니저를 설정할 수 있다.레이아웃 매니저는 리싸이클러뷰가 보일 기본적인 형태를 설정할 때 자주 사용하는 형태로세로 방향, 가로 방향, 격자 모양이다.LinearLayoutManager 객체를 통해 방향을 VERTICAL로 설정하여 세로 방향 스크롤로 보이게 된다. 가로 방향은 HORIZONTAL, 격자 모양은 GridLayoutManger 객체를 사용해 column 수를 지정하면 된다.인제 리스트 안에 들어갈 person_item.xml 파일을 만들어준다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&amp;gt; &amp;lt;androidx.cardview.widget.CardView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:cardBackgroundColor=&quot;#FFFFFFFF&quot; app:cardCornerRadius=&quot;10dp&quot; app:cardElevation=&quot;5dp&quot; app:cardUseCompatPadding=&quot;true&quot; &amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&amp;gt; &amp;lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;80dp&quot; android:padding=&quot;5dp&quot; app:srcCompat=&quot;@mipmap/ic_launcher&quot; /&amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_margin=&quot;5dp&quot; android:layout_weight=&quot;1&quot; android:orientation=&quot;vertical&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;이름&quot; android:textSize=&quot;30sp&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;전화번호&quot; android:textColor=&quot;#FF0000FF&quot; android:textSize=&quot;25sp&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/androidx.cardview.widget.CardView&amp;gt;&amp;lt;/LinearLayout&amp;gt;결과격자모양 RecyclerView위에서 만든 List모양 RecyclerView에서 조금만 바꾸어 주면 된다.RecyclerView가 보이는 모양은 레이아웃 매니저를 통해 결정이 되므로 MainActivity.java 파일을 수정한다.MainActivity.java @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); RecyclerView recyclerView = findViewById(R.id.recyclerView); GridLayoutManager layoutManager = new GridLayoutManager(this,2); ... }이렇게 수정해 주고 Person 객체를 추가 해주면 아래와 같이 격자모양 RecyclerView가 생성된다.뷰홀더 안에서의 클릭 이벤트를 처리어댑터 객체 밖에서 리스너를 설정하고 설정된 리스너 쪽으로 이벤트를 전달 받기 위해 인터페이스를 정의한다.OnPersonItemClickListenerpublic interface OnPersonItemClickListener { public void onItemClick(PersonAdapter.ViewHolder holder, View view,int position);}position 정보는 몇 번째 아이템인지를 구분할 수 있는 인덱스 값이다.인제 위의 인터페이스를 사용할 수 있도록 ViewHolder 클래스를 수정한다.PersonAdapter.java static class ViewHolder extends RecyclerView.ViewHolder{ TextView textView; TextView textView2; public ViewHolder(View itemView, final OnPersonItemClickListener listener){ // 뷰홀더 생성자로 전달되는 뷰 객체 참조하기 super(itemView); // 뷰 객체에 들어 있는 텍스트 뷰 참조하기 textView = itemView.findViewById(R.id.textView); textView2 = itemView.findViewById(R.id.textView2); // 아이템 뷰에 onClickListener 설정 itemView.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View view){ int position = getAdapterPosition(); // 아이템 뷰 클릭시 미리 정의한 다른 리스너의 메서드 호출하기 if(listener!=null) listener.onItemClick(ViewHolder.this,view, position); } }); } public void setItem(Person item){ textView.setText(item.getName()); textView2.setText(item.getMobile()); } }뷰 홀더 객체의 생성자가 호출될 때 리스너 객체가 파라미터로 전달된다.이렇게 전달된 리스너 객체의 onItemClick 이벤트는 뷰가 클릭되었을 때 호출된다.인제 PersonAdapter 코드를 수정해보자.PersonAdapter.javapublic class PersonAdapter extends RecyclerView.Adapter&amp;lt;PersonAdapter.ViewHolder&amp;gt; implements OnPersonItemClickListener{ ArrayList&amp;lt;Person&amp;gt; items = new ArrayList&amp;lt;Person&amp;gt;(); OnPersonItemClickListener listener; @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int viewType) { LayoutInflater inflater = LayoutInflater.from(viewGroup.getContext()); // 인플레이션을 통해 뷰 객체를 만들기 View itemView = inflater.inflate(R.layout.person_item, viewGroup, false); // 뷰홀더 객체를 생성하면서 뷰 객체를 전달하고 그 뷰홀더 객체를 반환하기 return new ViewHolder(itemView,this); } /* 외부에서 리스너를 설정할 수 있도록 메서드 추가 */ public void setOnItemClickListener(OnPersonItemClickListener listener){ this.listener = listener; } @Override public void onBindViewHolder(@NonNull ViewHolder viewHolder, int position) { Person item = items.get(position); viewHolder.setItem(item); } @Override public int getItemCount() { return items.size(); } public void addItem(Person item){ items.add(item); } public void setItem(ArrayList&amp;lt;Person&amp;gt; items){ this.items = items; } public Person getItem(int position){ return items.get(position); } public void setItem(int position, Person item){ items.set(position, item); } @Override public void onItemClick(ViewHolder holder, View view, int position) { if(listener != null) listener.onItemClick(holder, view, position); } ...OnPersonItemClickListener를 implements해서 필요 메서드를 구현해준다.onItemClick 메서드를 구현 해주었는데 이 메서드는 뷰홀더 클래스 안에서 뷰가 클릭되었을 때 호출되는 메서드이다.하지만 이 어댑터 클래스 안에서가 아니라 밖에서 이벤트 처리를 하는 것이 일반적이므로 listener라는 이름의변수를 하나 선언하고 setOnItemClickListener 메서드를 추가하여 이 메서드가 호출되었을 때 리스너 객체를변수에 할당하도록 한다. 이렇게하면 onItemClick 메서드가 호출되었을 때 다시 외부에서 설정된 메서드가호출되도록 만들 수 있다. 인제 MainActivity.java 파일을 수정해서 어댑터에 리스너 객체를 설정해보자.MainActivity.javapublic class MainActivity extends AppCompatActivity { RecyclerView recyclerView; PersonAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); recyclerView = findViewById(R.id.recyclerView); GridLayoutManager layoutManager = new GridLayoutManager(this,2); recyclerView.setLayoutManager(layoutManager); adapter = new PersonAdapter(); adapter.addItem(new Person(&quot;김민수&quot;,&quot;010-1000-1000&quot;)); adapter.addItem(new Person(&quot;김하늘&quot;,&quot;010-2000-2000&quot;)); adapter.addItem(new Person(&quot;홍길동&quot;,&quot;010-3000-3000&quot;)); adapter.addItem(new Person(&quot;테스트&quot;,&quot;010-5000-3000&quot;)); adapter.addItem(new Person(&quot;이지롱&quot;,&quot;010-5400-3000&quot;)); // 리싸이클러뷰에 어댑터 설정하기 recyclerView.setAdapter(adapter); // 어댑터에 리스너 설정하기 adapter.setOnItemClickListener(new OnPersonItemClickListener() { @Override public void onItemClick(PersonAdapter.ViewHolder holder, View view, int position) { Person item = adapter.getItem(position); Toast.makeText(getApplicationContext(),&quot;아이템 선택됨: &quot; + item.getName(),Toast.LENGTH_LONG).show(); } }); }}결과" }, { "title": "뷰들을 담는 레이아웃 정의하기", "url": "/posts/Layout/", "categories": "Android, User_Interface", "tags": "android, layout", "date": "2022-01-15 16:00:00 +0900", "snippet": "레이아웃 정의하기뷰들을 담는 레이아웃을 상속해서 새로운 레이아웃을 만들어보자.New-&amp;gt;Layout resource file만들어진 layout1.xml 파일을 아래와 같이 수정하자.layout1.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;80dp&quot; app:srcCompat=&quot;@mipmap/ic_launcher&quot; /&amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;5dp&quot; android:orientation=&quot;vertical&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;이름&quot; android:textSize=&quot;30sp&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;전화번호&quot; android:textColor=&quot;#3F51B5&quot; android:textSize=&quot;35sp&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/LinearLayout&amp;gt;위처럼 만들었으면 이 XML 파일과 매칭될 클래스 파일을 만들어주자.Layout1.javapublic class Layout1 extends LinearLayout { ImageView imageView; TextView textView; TextView textView2; public Layout1(Context context) { super(context); init(context); } public Layout1(Context context, AttributeSet attrs){ super(context, attrs); init(context); } private void init(Context context){ LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); inflater.inflate(R.layout.layout1,this,true); imageView = findViewById(R.id.imageView); textView = findViewById(R.id.textView); textView2 = findViewById(R.id.textView2); } public void setImage(int resId){ /* /app/res/drawable 폴더 안에 들어 있는 이미지 파일을 참조하는 정수 값을 파라미터로 전달 받는다. */ imageView.setImageResource(resId); } public void setName(String name){ textView.setText(name); } public void setMobile(String mobile){ textView2.setText(mobile); }}MainActivity.javapublic class MainActivity extends AppCompatActivity { Layout1 layout1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Layout1 layout1 = findViewById(R.id.layout1); // XML 레이아웃에 추가한 뷰 참조하기 Button button = findViewById(R.id.button); button.setOnClickListener((v)-&amp;gt;{ layout1.setImage(R.drawable.profile1); // 버튼 클릭했을 때 이미지 설정 layout1.setName(&quot;김민수&quot;); layout1.setMobile(&quot;999-999&quot;); }); Button button2 = findViewById(R.id.button2); button2.setOnClickListener((v)-&amp;gt;{ layout1.setImage(R.drawable.profile2); layout1.setName(&quot;박진영&quot;); layout1.setMobile(&quot;8239-999&quot;); }); }}activity_main.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;첫 번째 이미지&quot; /&amp;gt; &amp;lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;두 번째 이미지&quot; /&amp;gt; &amp;lt;org.techtown.layout.Layout1 android:id=&quot;@+id/layout1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&amp;gt;&amp;lt;/LinearLayout&amp;gt;결과카드뷰 만들기layout1.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&amp;gt; &amp;lt;androidx.cardview.widget.CardView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:cardBackgroundColor=&quot;#FFFFFFFF&quot; app:cardCornerRadius=&quot;10dp&quot; app:cardElevation=&quot;5dp&quot; app:cardUseCompatPadding=&quot;true&quot; &amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&amp;gt; &amp;lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;80dp&quot; app:srcCompat=&quot;@mipmap/ic_launcher&quot; /&amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;5dp&quot; android:orientation=&quot;vertical&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;이름&quot; android:textSize=&quot;30sp&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;전화번호&quot; android:textColor=&quot;#3F51B5&quot; android:textSize=&quot;35sp&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/androidx.cardview.widget.CardView&amp;gt;&amp;lt;/LinearLayout&amp;gt;cardCornerRadius는 모서리를 둥글게 만들어 준다.cardElevation은 뷰가 올라온 느낌이 들도록 만들어 준다.cardUseCompatPadding=”true” 기본 패딩 설정결과" }, { "title": "onDraw()", "url": "/posts/onDraw/", "categories": "Android, User_Interface", "tags": "android, ondraw, invalidate", "date": "2022-01-13 01:15:00 +0900", "snippet": "onDraw뷰가 화면에 보일 때는 onDraw 메서드가 호출된다.예를 들어, 버튼의 경우에는 그림으로 된 아이콘이나 글자가 그 위에 표시 되려면먼저 그 버튼을 담고 있는 레이아웃에 따라 버튼의 위치와 크기가 정해져야 한다.그 후 다음 버튼의 모양과 그 안의 아이콘 또는 글자를 화면상에 그려주는 과정을 거치게 된다.결국, 새로운 뷰를 클래스로 정의하고 그 안에 onDraw 메서드를 다시 정의한 후 필요한 코드를 넣어기능을 구현하면 다른 모양으로 보이는 뷰를 직접 만들 수 있다.뷰가 화면에 보이기 전에 호출 되므로 onDraw() 메서드 안에서 원하는 모양의 그래픽을 화면에 그리면그 모양대로 화면에 표현할 수 있다.예제새롭게 정의할 버튼을 위해 클래스를 하나 만든다MyButton.javapublic class MyButton extends AppCompatButton { // 필수 생성자 public MyButton(Context context) { super(context); init(context); } // 필수 생성자 public MyButton(Context context, AttributeSet attrs) { super(context, attrs); init(context); } private void init(Context context) { setBackgroundColor(Color.CYAN); setTextColor(Color.BLACK); float textSize = getResources().getDimension(R.dimen.text_size); setTextSize(textSize); } @Override // 뷰가 그려질 때 호출되는 함수에 기능 추가하기 protected void onDraw(Canvas canvas) { super.onDraw(canvas); Log.d(&quot;MyButton&quot;, &quot;onDraw 호출됨&quot;); } @Override // 뷰가 터치될 때 호출되는 함수에 기능 추가하기 public boolean onTouchEvent(MotionEvent event) { Log.d(&quot;MyButton&quot;, &quot;onTouchEvent 호출됨&quot;); int action = event.getAction(); switch (action) { case MotionEvent.ACTION_DOWN: setBackgroundColor(Color.BLUE); setTextColor(Color.RED); break; case MotionEvent.ACTION_OUTSIDE: case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_UP: setBackgroundColor(Color.CYAN); setTextColor(Color.BLACK); break; } // 화면을 다시 그려주기 위해 호출 invalidate(); return true; }}글자 크기를 조절하기 위해 XML 파일을 하나 만들어 준다./app/values/dimens.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;resources&amp;gt; &amp;lt;dimen name=&quot;text_size&quot;&amp;gt;16sp&amp;lt;/dimen&amp;gt; &amp;lt;/resources&amp;gt;새롭게 정의한 버튼을 등록하기 위해 acitvity_mani.xml을 수정한다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;org.techtown.view.MyButton android:id=&quot;@+id/button&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;80dp&quot; android:layout_centerInParent=&quot;true&quot; android:text=&quot;시작하기&quot; /&amp;gt; &amp;lt;/RelativeLayout&amp;gt;MyButton은 직접 정의한 위젯이므로 XML 레이아웃에 추가할 떄 패키지 이름까지 함께 넣어야 한다.결과" }, { "title": "NinePatch Image", "url": "/posts/Ninepatch/", "categories": "Android, Study", "tags": "android, ninepatch image", "date": "2022-01-12 18:54:00 +0900", "snippet": "나인 패치모바일 앱 내에 이미지를 적용하는 경우가 적지 않게 있다.그런데, 모바일 기기 환경 상 기기의 종류가 여러가지이고 해상도도 기기마다 다 다르다.기기마다 해상도가 다 다르다 보니 적용되는 이미지 사이즈가 늘어나거나 깨져서의도한것과는 다르게 이미지가 이상하게 보이게된다.나인 패치 이미지는 위의 이미지 왜곡 문제를 해결해주기 위한 해결책이다.위의 세개의 버튼은 일반 이미지인데, 폭이 넓어질 수록 왜곡이 생긴다.아래의 세개의 버튼은 나인 패치 이미지를 적용 시켰고, 버튼에 설정된 이미지가그대로 유지되는 효과를 확인할 수 있다.나인 패치 이미지 만들기NinePatch 이미지를 생성하려는 PNG 이미지 마우스 우클릭 -&amp;gt; Create 9-patch file 이미지 이름을 입력하고 OK 버튼을 누르면 .9.png인 이미지 파일이 생성된다.새 나인 패치 파일을 더블 클릭하여 작업공간으로 이동해서 수정후 Save reference-&amp;gt; 안드로이드 개발자" }, { "title": "Broad Cast Receiver", "url": "/posts/BroadCast/", "categories": "Android, AppComponents", "tags": "android, viewpager", "date": "2022-01-11 12:50:00 +0900", "snippet": "Broadcast안드로이드에서 브로드캐스팅 (BroadCasting)이란 메시지를 여러 객체에 전달하는 것을 말한다.예를 들어 카카오톡에서 여러 사람에게 메시지를 전달할 때 그룹 채팅방을 만들어메시지를 전달하는것을 생각해보자. 마찬가지로 안드로이드도 여러 앱 구성 요소에메시지를 전달할 때 브로드 캐스팅을 사용한다.우리가 만든 앱에서 브로드캐스팅 메시지를 받고 싶다면 브로드캐스트 수신자를만들어 앱에 등록하면 된다.브로드캐스트도 앱의 구성 요소이기 때문에 수신자를 만들면 새로 등록해야 시스템이 알 수 있다Mainfest 파일에 등록하는 Service와는 달리,Broadcast Recevier는 소스코드에서 registerReceiver 메서드를 사용해 시스템에 등록할 수 있다.브로드 캐스트 수신자 동작 방식 출처 : Do it 안드로이드 프로그래밍브로드 캐스트 수신자 등록 예시브로드 캐스트 수신자에는 onReceive 메서드를 정의해야 한다.이 메서드는 원하는 브로드캐스트 메시지가 도착하면 자동으로 호출된다.시스템의 모든 메시지를 받을 수 없기 때문에 원하는 메시지만 받으려면인텐트 필터를 사용해 시스템에 등록하면 된다.위 사진같이 브로드캐스트 클래스를 만들어주자 Class Name은 SmsReceiver로 한다.이렇게 하면 Manifest.xml 파일에 reciver태그가 자동으로 추가 되는데,브로드캐스트 수신자를 등록하기 위해 아래 처럼 수정하자. AndroidManifest.xml &amp;lt;receiver android:name=&quot;.SmsReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&quot;android.provider.Telephony.SMS_RECIVED&quot;/&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;/receiver&amp;gt;위의 intent-filter 태그는 어떤 인텐트를 받을 것인지 지정해 주고,action 태그의 android.provider.Telephony.SMS_RECIVED는 메시지가 들어간 인텐트를구분하기 위한 액션 정보이다. 즉, 단말에서 SMS를 수신했을 때 이 action 정보가 들어간인텐트를 전달 하므로 이 값을 넣어주면 SMS를 받아 볼 수 있다.인제 아래와 같이 SmsReceiver.java 파일을 수정해주자 SmsReceiver.javapublic class SmsReceiver extends BroadcastReceiver { public static final String TAG = &quot;SmsReceiver&quot;; @Override public void onReceive(Context context, Intent intent) { Log.i(TAG, &quot;onReceive() 메서드 호출됨.&quot;); Bundle bundle = intent.getExtras(); // 인텐트에서 Bundle 객체 가져오기 SmsMessage[] messages = parseSmsMessage(bundle); if(messages != null &amp;amp;&amp;amp; messages.length &amp;gt; 0){ // getOriginatingAddress() 발신자 번호 확인하는 메서드 String sender = messages[0].getOriginatingAddress(); Log.i(TAG, &quot;SMS sender : &quot; + sender); // 문자 내용을 확인하려면 getMessageBody().toString() String contents = messages[0].getMessageBody(); Log.i(TAG, &quot;SMS contents : &quot; + contents); Date receivedDate = new Date(messages[0].getTimestampMillis()); Log.i(TAG, &quot;SMS received date : &quot; + receivedDate.toString()); } throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); } private SmsMessage[] parseSmsMessage(Bundle bundle){ Object[] objs = (Object[]) bundle.get(&quot;pdus&quot;); SmsMessage[] messages = new SmsMessage[objs.length]; int smsCount = objs.length; for(int i=0; i&amp;lt;smsCount; i++){ if(Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.M){ String format = bundle.getString(&quot;format&quot;); messages[i] = SmsMessage.createFromPdu((byte[]) objs[i], format); }else messages[i] = SmsMessage.createFromPdu((byte[]) objs[i]); } return messages; }}위의 parseSmsMessage 메서드는 한 번 만들어 놓으면 다른 앱을 만들 때도 재사용할 수 있다.왜냐하면 SMS 데이터를 확인할 수 있도록 안드로이드 API에 정해둔 코드이기 때문이다.if(Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.M)에서,Build.VERSION_CODE에는 안드로이드 OS 버전별로 상수가 정의되어 있다.M은 마시멜로 버전과 같거나 그 이후 버전일 때 중괄호 안의 코드를 실행하겠다는 뜻이다.인제 SMS를 수신하려면 RECEIVE_SMS 권한이 있어야 한다.아래와 같이 코드를 수정하자.AndroidManifest.xml&amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.recevier&quot;&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&amp;gt;build.gradle(Module: SampleReceiver.app)dependencies { ... implementation &#39;com.yanzhenjie:permission:2.0.3&#39;}MainActivity.javapublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); AndPermission.with(this)// 모든 위험 권한을 자동으로 부여하는 메서드 호출 .runtime() .permission(Permission.RECEIVE_SMS) .onGranted(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;허용된 권한 갯수 : &quot; + permissions.size()); } }) .onDenied(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;거부된 권한 갯수 : &quot; + permissions.size()); } }) .start(); } public void showToast(String message) { Toast.makeText(this, message, Toast.LENGTH_LONG).show(); }}인제 앱을 실행했을 때 메인 액티비티가 화면에 보이면 권한을 요청하는 대화상자가 나타난다.Allow 버튼을 누르고 권한이 승인되고 SMS 받을 준비가 완료된다.위 사진 처럼 메시지를 작성하고 SendMessage를 누르면 Logcat창에서,onReceive 메서드가 호출되었다는 것을 알 수 있다.SMS 내용 액티비티에 나타내기app 폴더에서 New Activity -&amp;gt; Empty만들어진 activity_main은 위 처럼 꾸미고 SmsActivity.java 파일을 아래와 같이 수정.SmsActivity.javapublic class SmsActivity extends AppCompatActivity { EditText editText; EditText editText2; EditText editText3; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_sms); editText = findViewById(R.id.editText); editText2 = findViewById(R.id.editText2); editText3 = findViewById(R.id.editText3); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { finish(); // 화면을 닫는다. } }); // 전달 받은 인텐트를 처리 하는 processIntent 호출 Intent passedIntent = getIntent(); processIntent(passedIntent); } @Override protected void onNewIntent(Intent intent) { processIntent(intent); super.onNewIntent(intent); } private void processIntent(Intent intent) { // Intent가 null이 아니면 그 안에 있는 부가 데이터를 화면에 보여주기 if (intent != null) { String sender = intent.getStringExtra(&quot;sender&quot;); String contents = intent.getStringExtra(&quot;contents&quot;); String receivedDate = intent.getStringExtra(&quot;receivedDate&quot;); editText.setText(sender); editText2.setText(contents); editText3.setText(receivedDate); } }}수신한 SMS를 보여줄 화면까지 만들었으므로 SmsReceiver.java 파일을 열어SmsActivity 인텐트를 전달하는 코드를 추가한다. SmsReceiver.javapublic class SmsReceiver extends BroadcastReceiver { private static final String TAG = &quot;SmsReceiver&quot;; public SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); @Override public void onReceive(Context context, Intent intent) { Log.i(TAG, &quot;onReceive() 메서드 호출됨.&quot;); Bundle bundle = intent.getExtras(); SmsMessage[] messages = parseSmsMessage(bundle); if (messages != null &amp;amp;&amp;amp; messages.length &amp;gt; 0) { String sender = messages[0].getOriginatingAddress(); Log.i(TAG, &quot;SMS sender : &quot; + sender); String contents = messages[0].getMessageBody(); Log.i(TAG, &quot;SMS contents : &quot; + contents); Date receivedDate = new Date(messages[0].getTimestampMillis()); Log.i(TAG, &quot;SMS received date : &quot; + receivedDate.toString()); sendToActivity(context, sender, contents, receivedDate); } } private SmsMessage[] parseSmsMessage(Bundle bundle) { Object[] objs = (Object[]) bundle.get(&quot;pdus&quot;); SmsMessage[] messages = new SmsMessage[objs.length]; int smsCount = objs.length; for (int i = 0; i &amp;lt; smsCount; i++) { if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.M) { String format = bundle.getString(&quot;format&quot;); messages[i] = SmsMessage.createFromPdu((byte[]) objs[i], format); } else { messages[i] = SmsMessage.createFromPdu((byte[]) objs[i]); } } return messages; } /* SmsActivity로 인텐트를 보내기 위한 메서드 */ private void sendToActivity(Context context, String sender, String contents, Date receivedDate) { Intent myIntent = new Intent(context, SmsActivity.class); myIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_SINGLE_TOP|Intent.FLAG_ACTIVITY_CLEAR_TOP); myIntent.putExtra(&quot;sender&quot;, sender); myIntent.putExtra(&quot;contents&quot;, contents); myIntent.putExtra(&quot;receivedDate&quot;, format.format(receivedDate)); context.startActivity(myIntent); }}" }, { "title": "Dangerous Permission", "url": "/posts/Permission/", "categories": "Android, AppComponents", "tags": "android, viewpager", "date": "2022-01-11 02:27:00 +0900", "snippet": "위험 권한 부여하기브로드캐스트 수신자를 만들어 SMS 문자를 받으려면 RECEIVE_SMS 권한이 필요하다.Manifest에 넣어준 권한은 앱을 설치할 때 사용자가 허용하면 한꺼번에 권한이 부여되는데마시멜로(API32) 부터는 중요한 권한들을 분류하여 설치 시점이 아니라 앱을 실행 했을 때,사용자로부터 권한을 부여 받도록 변경 되었다.일반 권한과 위험 권한의 차이점마시멜로 버전부터는 권한을 일반 권한(Normal Permission)과 위험 권한(Dangerous Permission)으로 나뉘었다. 인터넷을 사용할 때 부여하는 INTERNET 권한 같은 일반 권한은 앱을 설치할 때사용자에게 권한이 부여되어야 함을 알려주고 설치 할 것인지 물어본다.그러나 위험 권한으로 분류되는 RECEIVE_SMS의 경우에는 설치 시에 부여한 권한은의미가 없고 실행 시에 사용자에게 권한을 부여할 것인지 물어보게 된다.즉, 권한을 부여하지 않으면 해당 기능은 동작하지 않는다.위치, 카메라, 마이크, 연락처, 전화, 문자, 일정, 센서로 대표되는 위험 권한은 다음과 같은세부 권한으로 나뉜다. 위험 권한 그룹의 분류 세부 권한 LOCATION ACESS_FINE_LOCATIONACESS_COARSE_LOCATION CAMERA CAMERA MICROPHONE RECORD_AUDIO CONTACTS READ_CONTACTSWRITE_CONTACTSGET_ACCOUNTS PHONE READ_PHONE_STATECALL_PHONEREAD_CALL_LOGWRITE_CALL_LOGADD_VOICEMAILUSE_SIPPROCESS_OUTGOING_CASLLS SMS SEND_SMSRECEVIE_SMSREAD_SMSRECEIVE_WAP_PUSHRECEIVCE_MMS CALENDAR READ_CALENDARWRITE_CALENDAR SENSORS BODY_SENSORS STORAGE READ_EXTERNAL_STORAGEWRTIE_EXTERNAL_STORAGE 기본 방법으로 위험 권한 부여하기SD 카드를 접근할 때 사용되는 두가지 위험 권한을 부여하기 위해,먼저 AndroidManifest.xml 파일을 다음과 같이 권한을 추가한다.AndroidManifest.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.permission&quot;&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&amp;gt; 기본 권한을 부여할 때는 태그를 사용한ㅂ다.이렇게 부여한 기본 권한 중에서 SD 카드를 접근하는 권한은 위험 권한이므로아래와 같이 MainActivity.java 파일에 코드를 추가해 주어야 한다.MainActivity.javapublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 위험 권한을 부여할 권한 지정하기 String [] permissions = { Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE }; checkPermissions(permissions); } public void checkPermissions(String[] permissions){ ArrayList&amp;lt;String&amp;gt; targetList = new ArrayList&amp;lt;String&amp;gt;(); for(int i=0; i&amp;lt;permissions.length; i++){ String curPermission = permissions[i]; // 권한이 부여 되어 있는지 확인 int permissionCheck = ContextCompat.checkSelfPermission(this,curPermission); if(permissionCheck == PackageManager.PERMISSION_GRANTED) Toast.makeText(this,curPermission + &quot; 권한 있음.&quot;, Toast.LENGTH_LONG).show(); else{ Toast.makeText(this,curPermission +&quot; 권한 없음.&quot;, Toast.LENGTH_LONG).show(); if(ActivityCompat.shouldShowRequestPermissionRationale(this,curPermission)) Toast.makeText(this,curPermission + &quot; 권한 설명 필요함.&quot;, Toast.LENGTH_LONG).show(); else targetList.add(curPermission); } } String[] targets = new String[targetList.size()]; targetList.toArray(targets); // 위험 권한 부여 요청 ActivityCompat.requestPermissions(this,targets,101); } @Override public void onRequestPermissionsResult(int requestCode, String permissions[], int [] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { // 요청 코드가 맞는지 확인함 case 101: if (grantResults.length &amp;gt; 0 &amp;amp;&amp;amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) Toast.makeText(this, &quot;첫 번째 권한을 사용자가 승인함.&quot;, Toast.LENGTH_LONG).show(); else Toast.makeText(this, &quot;첫 번째 권한 거부됨. &quot;, Toast.LENGTH_LONG).show(); break; } }}이렇게 설정을 해주고 나서 앱을 실행하면 다음과 같이 권한을 요청하는 대화 상자가 나타난다.이렇게 실행했을 때 부여되는 위험 권한이라고 하더라도 사용자가 한 번 수락하면앱에 부여된 권한 정보를 단말에서 알고 있기 때문에 앱을 다시 실행해도 대화상자는 더 이상나타나지 않는다.외부 라이브러리를 이용한 위험 권한 자동 부여 방법SamplePermission2 이름을 가진 프로젝트에서 build.gradle(Module:SamplePermission2.app)파일을 열어서 다음과 같이 추가한다.build.gradle(Module:SamplePermission2.app)dependencies { ... implementation &#39;com.yanzhenjie:permission:2.0.3&#39;}manifest 파일을 아래와 같이 수정하자.AndroidManifest.xml&amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.permission2&quot;&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&amp;gt;그 다음 MainActivity.java 파일에 다음 코드를 추가한다.MainActivity.javapublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); AndPermission.with(this) .runtime() .permission(Permission.READ_EXTERNAL_STORAGE,Permission.WRITE_EXTERNAL_STORAGE) .onGranted(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;허용된 권한 개수: &quot; + permissions.size()); } }) .onDenied(new Action&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { @Override public void onAction(List&amp;lt;String&amp;gt; permissions) { showToast(&quot;거부된 권한 개수: &quot; + permissions.size()); } }) .start(); } public void showToast(String message){ Toast.makeText(this,message,Toast.LENGTH_LONG).show(); }}" }, { "title": "Services", "url": "/posts/Service/", "categories": "Android, AppComponents", "tags": "android, service", "date": "2022-01-10 22:10:00 +0900", "snippet": "서비스서비스란 백그라운드에서 실행되는 앱의 구성 요소를 말한다.서비스도 앱의 구성 요소이므로 시스템에서 관리한다. 그래서 액티비티를 만들 때매니페스트 파일에 등록했던 것처럼 새로 만든 서비스도 매니페스트 파일에 꼭 등록 해야한다.실행 원리와 역할서비스를 실행하려면 메인 액티비티에서 startService 메서드를 호출하면 된다.서비스의 주요 역할 중 하나는 단말이 항상 실행되어 있는 상태로 다른 단말과 데이터를 주고 받거나필요한 기능을 백그라운드에서 실행하는 것이다.서비스를 시작시키기 위해 startSevice 메서드를 호출할 때는 인텐트 객체를 피라미터로 전달한다.이 인텐트 객체는 어떤 서비스를 실행할 것인지에 대한 정보를 담고 있으며 시스템은 서비스를 시작시킨 후인텐트 객체를 서비스에 전달한다.서비스가 실행 중이면 실행 이후에 startService 메서드를 여러 번 호출해도 서비스는이미 메모리에 만들어진 상태로 유지된다. 따라서 startService 메서드는 서비스를 시작하는 목적 이외에는인텐트를 전달하는 목적으로 자주 사용된다.액티비티에서 서비스로 데이터를 전달하려면 인텐트 객체를 만들고 부가 데이터를 넣은후startService 메서드를 호출하면서 전달하면 된다. 이 경우 이미 서비스가 메모리에 만들어져 있는 상태 이므로,onCreate 메서드가 아니라 onStartCommand 메서드를 실행한다.서비스 만들어보기app 폴더에 new -&amp;gt; Srvice를 클릭한다.Class Name에는 MyService라고 입력하자.이렇게 하면 MyService.java 파일이 만들어지고 Manifest 파일안에 service 태그도 추가된다.자동으로 만들어진 MyService.java 파일안에는 생성자와 onBind 메서드만 있다.우리는 서비스의 생명주기를 관해주기 위해,onCreate, onDestroy, onStartCommand 메서드를 만들어주자.그 후 MainActity.java 파일을 아래와 같이 수정하자.public class MainActivity extends AppCompatActivity { EditText editText; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText = findViewById(R.id.editTextText); Button button = findViewById(R.id.button); button.setOnClickListener((v)-&amp;gt;{ String name = editText.getText().toString(); /* 인텐트 객체 만들고 부가 데이터 넣기 */ Intent intent = new Intent(getApplicationContext(), MyService.class); intent.putExtra(&quot;command&quot;,&quot;show&quot;); intent.putExtra(&quot;name&quot;,name); startService(intent); // 서비스 시작하기 }); Intent passedIntent = getIntent(); processIntent(passedIntent); } @Override protected void onNewIntent(Intent intent){ processIntent(intent); super.onNewIntent(intent); } private void processIntent(Intent intent){ if(intent!=null){ String command = intent.getStringExtra(&quot;command&quot;); String name = intent.getStringExtra(&quot;name&quot;); Toast.makeText(this,&quot;command&quot; + &quot;, name : &quot; + name, Toast.LENGTH_LONG).show(); } }}서비스가 서버 역할을 하면서 액티비티와 연결될 수 있도록 만드는 것을 바인딩(Binding)이라고하고, 이를 위해서는 onBind 메서드를 재정의해야한다.하지만 여기서는 바인딩 기능을 사용하지 않으므로 수정하지 않고 그대로 놔둔다.인제 MyService.java 파일을 수정해 보자.MyService.javapublic class MyService extends Service { private static final String TAG = &quot;MyService&quot;; public MyService() { } @Override public void onCreate() { super.onCreate(); Log.d(TAG, &quot;onCreate() 호출됨.&quot;); } public int onStartCommand(Intent intent, int flags, int startId){ Log.d(TAG, &quot;onStartCommand() 호출됨.&quot;); if(intent == null) return Service.START_STICKY; else processCommand(intent); return super.onStartCommand(intent, flags, startId); } private void processCommand(Intent intent){ String command = intent.getStringExtra(&quot;command&quot;); String name = intent.getStringExtra(&quot;name&quot;); Log.d(TAG,&quot;command : &quot; + command + &quot;, name : &quot; + name); for(int i=0; i&amp;lt;5; i++){ try{ Thread.sleep(1000); }catch (Exception e){}; Log.d(TAG, &quot;Waiting &quot; + i + &quot;seconds.&quot;); } Intent showIntent = new Intent(getApplicationContext(), MainActivity.class); showIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK| Intent.FLAG_ACTIVITY_SINGLE_TOP| Intent.FLAG_ACTIVITY_CLEAR_TOP); showIntent.putExtra(&quot;command&quot;,&quot;show&quot;); showIntent.putExtra(&quot;name&quot;,name+&quot; from service.&quot;); startActivity(showIntent); } @Override public IBinder onBind(Intent intent) { // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); }}결과" }, { "title": "Navigation Drawer", "url": "/posts/NavigationDrawer/", "categories": "Android, Navigation", "tags": "android, navigation", "date": "2022-01-10 03:17:00 +0900", "snippet": "바로가기 메뉴바로가기 메뉴는 화면의 좌측 상단에 위치한 햄버거 모양 아이콘을 눌렀을 때 나타나는 화면을 말한다.웹이나 앱에서 자주 사용하는 기능이며, 안드로이드에서 NavigationDrawer라고 부른다.만들기Navigation Drawer Activity로 새로운 프로젝트를 만든다.그 다음 프로젝트를 생성하면 activity_main.xml, app_bar_main.xml, content_main.xml 파일이분리되어 있는데 합쳐 주자.activity_main.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/drawer_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; tools:openDrawer=&quot;start&quot;&amp;gt; &amp;lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;com.google.android.material.appbar.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;@style/Theme.SampleDrawer.AppBarOverlay&quot;&amp;gt; &amp;lt;androidx.appcompat.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; app:popupTheme=&quot;@style/Theme.SampleDrawer.PopupOverlay&quot; /&amp;gt; &amp;lt;/com.google.android.material.appbar.AppBarLayout&amp;gt; &amp;lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&amp;gt; &amp;lt;/FrameLayout&amp;gt; &amp;lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&amp;gt; &amp;lt;com.google.android.material.navigation.NavigationView android:id=&quot;@+id/nav_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; android:fitsSystemWindows=&quot;true&quot; app:headerLayout=&quot;@layout/nav_header_main&quot; app:menu=&quot;@menu/activity_main_drawer&quot; /&amp;gt;&amp;lt;/androidx.drawerlayout.widget.DrawerLayout&amp;gt;appbar_scrolling_view_behavior는 CoordinatorLayout 안에서 해당 레이아웃이 스크롤 등의 작업이진행될 때 차지할 면적을 자동으로 계산한다.또 NavigationView 안에 headerLayout 속성은 바로가기 메뉴의 상단에 표시되면서 사용자프로필 등을 보여줄 수 있도록 하고 menu 속성은 그 아래에 메뉴를 보여주도록 하는 역할을 한다.인제 Fragment 1,2,3 파일을 만들어 준다.Fragment 1.javapublic class Fragment1 extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { return inflater.inflate(R.layout.fragment1, container, false); }}fragment1.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/holo_blue_bright&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.Fragment1&quot;&amp;gt; &amp;lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;첫 번째&quot; /&amp;gt;&amp;lt;/LinearLayout&amp;gt;MainActivity.javaimport android.os.Bundle;import android.view.MenuItem;import android.widget.Toast;import androidx.appcompat.widget.Toolbar;import androidx.appcompat.app.ActionBarDrawerToggle;import androidx.appcompat.app.AppCompatActivity;import androidx.core.view.GravityCompat;import androidx.drawerlayout.widget.DrawerLayout;import androidx.fragment.app.Fragment;import com.google.android.material.navigation.NavigationView;import org.techtown.drawer.R;public class MainActivity extends AppCompatActivity implements NavigationView.OnNavigationItemSelectedListener, FragmentCallback{ Fragment1 fragment1; Fragment2 fragment2; Fragment3 fragment3; DrawerLayout drawer; Toolbar toolbar; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); toolbar = findViewById(R.id.toolbar); setSupportActionBar(toolbar); drawer = findViewById(R.id.drawer_layout); ActionBarDrawerToggle toggle = new ActionBarDrawerToggle( this,drawer,toolbar,R.string.navigation_drawer_open,R.string.navigation_drawer_close); drawer.addDrawerListener(toggle); toggle.syncState(); // 현재 Drawerlayout 상태와 ActionBarDrawerToggle 의 상태를 sync NavigationView navigationView = findViewById(R.id.nav_view); navigationView.setNavigationItemSelectedListener(this); fragment1 = new Fragment1(); fragment2 = new Fragment2(); fragment3 = new Fragment3(); getSupportFragmentManager().beginTransaction().add(R.id.container,fragment1).commit(); } @Override public void onBackPressed(){ if (drawer.isDrawerOpen(GravityCompat.START)) drawer.closeDrawer(GravityCompat.START); else super.onBackPressed(); } @Override public boolean onNavigationItemSelected(MenuItem item){ int id = item.getItemId(); switch(id){ case R.id.menu1: Toast.makeText(this,&quot;첫 번째 메뉴 선택됨&quot;, Toast.LENGTH_LONG).show(); onFragmentSelected(0,null); break; case R.id.menu2: Toast.makeText(this,&quot;두 번째 메뉴 선택됨&quot;, Toast.LENGTH_LONG).show(); onFragmentSelected(1,null); break; case R.id.menu3: Toast.makeText(this,&quot;세 번째 메뉴 선택됨&quot;, Toast.LENGTH_LONG).show(); onFragmentSelected(2,null); break; } drawer.closeDrawer(GravityCompat.START); return true; } @Override public void onFragmentSelected(int position, Bundle bundle){ Fragment curFragment = null; switch(position){ case 0: curFragment = fragment1; toolbar.setTitle(&quot;첫 번째 화면&quot;); case 1: curFragment = fragment2; toolbar.setTitle(&quot;두 번째 화면&quot;); case 2: curFragment = fragment3; toolbar.setTitle(&quot;세 번째 화면&quot;); } getSupportFragmentManager().beginTransaction().replace(R.id.container,curFragment).commit(); }}FragmentCallback.javaimport android.os.Bundle;public interface FragmentCallback { public void onFragmentSelected(int position, Bundle bundle);}결과" }, { "title": "뷰 페이저", "url": "/posts/ViewPager/", "categories": "Android, Navigation", "tags": "android, viewpager", "date": "2022-01-10 02:04:00 +0900", "snippet": "뷰 페이저뷰 페이저는 손가락으로 좌우 스크롤하여 넘겨볼 수 있는 기능을 제공한다.화면 전체를 뷰 페이저로 채운다면 좌우 스크롤을 통해 화면을 넘겨 볼 수 있고,화면 일부분만 차지하고 있어도 그 부분에서 좌우 스크롤이 동작한다.뷰 페이저 만들기메인 액티비티 xml을 아래와 같이 설정activity_main.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot; &amp;gt; &amp;lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;두번째 화면 보여주기&quot; /&amp;gt; &amp;lt;androidx.viewpager.widget.ViewPager android:id=&quot;@+id/pager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;androidx.viewpager.widget.PagerTitleStrip android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;top&quot; android:background=&quot;#55cedf&quot; android:textColor=&quot;#FFFFFF&quot; android:paddingTop=&quot;5dp&quot; android:paddingBottom=&quot;5dp&quot;&amp;gt; &amp;lt;/androidx.viewpager.widget.PagerTitleStrip&amp;gt; &amp;lt;/androidx.viewpager.widget.ViewPager&amp;gt;&amp;lt;/LinearLayout&amp;gt;위의 xml 파일에서 TitleStrip이란 전체 아이템의 개수와 현재 보고 있는 아이템을 보여줄 때 사용한다.layout_gravity 속성 값이 top으로 되어 있어 뷰페이저 위쪽에 보이게 된다.그 후 프레그먼트 파일 1,2,3을 준비한다.fragment.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/holo_blue_bright&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.Fragment1&quot;&amp;gt; &amp;lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;첫 번째&quot; /&amp;gt;&amp;lt;/LinearLayout&amp;gt;Fragment.javapublic class Fragment1 extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { return inflater.inflate(R.layout.fragment1, container, false); }}그 후 MainActivity.java 파일을 열고 onCreate 메서드 아래쪽에 어댑터 클래스를 추가한다.MainActivity.javapackage org.techtown.myapplication;import android.os.Bundle;import android.view.View;import android.widget.Button;import androidx.appcompat.app.AppCompatActivity;import androidx.fragment.app.Fragment;import androidx.fragment.app.FragmentManager;import androidx.fragment.app.FragmentStatePagerAdapter;import androidx.viewpager.widget.ViewPager;import java.util.ArrayList;public class MainActivity extends AppCompatActivity { ViewPager pager; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); pager = findViewById(R.id.pager); pager.setOffscreenPageLimit(3); MyPagerAdapter adapter = new MyPagerAdapter(getSupportFragmentManager()); Fragment1 fragment1 = new Fragment1(); adapter.addItem(fragment1); Fragment2 fragment2 = new Fragment2(); adapter.addItem(fragment2); Fragment3 fragment3 = new Fragment3(); adapter.addItem(fragment3); pager.setAdapter(adapter); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { pager.setCurrentItem(1); } }); } class MyPagerAdapter extends FragmentStatePagerAdapter { ArrayList&amp;lt;Fragment&amp;gt; items = new ArrayList&amp;lt;Fragment&amp;gt;(); public MyPagerAdapter(FragmentManager fm) { super(fm); } public void addItem(Fragment item) { items.add(item); } @Override public Fragment getItem(int position) { return items.get(position); } @Override public int getCount() { return items.size(); } @Override public CharSequence getPageTitle(int position) { return &quot;페이지 &quot; + position; } }}MyPagerAdapter는 내부 클래스로 만들었으며 FragmentStatePagerAdapter를 상속했다.어댑터는 뷰 페이저에 보여줄 각 프래그먼트를 관리하는 역할을 하며,뷰 페이저에 설정하면 서로 상호작용 하면서 화면을 보여주게 된다.뷰페이저는 어댑터가 가지고 있는 아이템 중에서 몇개를 로딩해 두었다가 스크롤 할 때 빠르게 보여줄 수 있다.이 값이 처음에 3보다 적기 때문에,setOffscreenPageLimit 메서드로 미리 로딩해 놓을 아이템의 개수를 세개로 늘렸다.코드로 화면을 전환 시키고 싶으면 뷰페이저 객체의 setCurrentItem 메서드를 사용하면 된다.결과" }, { "title": "상단 탭 하단 탭 만들기", "url": "/posts/TopBottomTab/", "categories": "Android, Navigation", "tags": "android, view", "date": "2022-01-09 22:51:00 +0900", "snippet": "상단 탭 하단 탭 만들기상단 탭 만들기activity_main.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;androidx.coordinatorlayout.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;com.google.android.material.appbar.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&amp;gt; &amp;lt;androidx.appcompat.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;?colorPrimaryDark&quot; android:elevation=&quot;1dp&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/titleText&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;타이틀&quot; android:textAppearance=&quot;@style/Base.TextAppearance.Widget.AppCompat.Toolbar.Title&quot; /&amp;gt; &amp;lt;/androidx.appcompat.widget.Toolbar&amp;gt; &amp;lt;com.google.android.material.tabs.TabLayout android:id=&quot;@+id/tabs&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/background_light&quot; android:elevation=&quot;1dp&quot; app:tabGravity=&quot;fill&quot; app:tabMode=&quot;fixed&quot; app:tabSelectedTextColor=&quot;?colorAccent&quot; app:tabTextColor=&quot;?colorPrimary&quot; /&amp;gt; &amp;lt;/com.google.android.material.appbar.AppBarLayout&amp;gt; &amp;lt;FrameLayout android:id=&quot;@+id/container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&amp;gt; &amp;lt;/FrameLayout&amp;gt; &amp;lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&amp;gt;&amp;lt;/RelativeLayout&amp;gt;위의 XML 구조를 정리하면 다음과 같다.&amp;lt;CoordinatorLayout&amp;gt; &amp;lt;AppBarLayout&amp;gt; &amp;lt;Toolbar&amp;gt; &amp;lt;/Toolbar&amp;gt; &amp;lt;TabLayout&amp;gt; &amp;lt;/TabLayout&amp;gt; &amp;lt;/AppBarLayout&amp;gt; &amp;lt;FrameLayout&amp;gt; &amp;lt;/FrameLayout&amp;gt; &amp;lt;/CoordinatorLayout&amp;gt;CoordinatorLayout은 액션 바 영역을 포함한 전체 화면의 위치를 잡아주는 역할을 한다.CoordinatorLayout 안에 AppBarLayout과 함께 다른 레이아웃을 넣으면 그 둘 간의 간격이나위치가 자동으로 결정된다.AppBarLayout은 액션바를 가르킨다.인제 res/layout 폴더 안에 fragment 파일들을 추가하자.Fragmnet1.java와 fragment1.xml 파일을 인플레이션 해주자.Fragment1.javapublic class Fragment1 extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState){ return inflater.inflate(R.layout.fragment1,container,false); }}Fragment1.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#00BCD4&quot;&amp;gt; &amp;lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:text=&quot;첫 번째&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt;위와 같이 Fragment2,3 파일도 만들어주자.그리고 MainActivity.java 파일을 아래와 같이 수정public class MainActivity extends AppCompatActivity { Toolbar toolbar; Fragment1 fragment1; Fragment2 fragment2; Fragment3 fragment3; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); toolbar = findViewById(R.id.toolbar); setSupportActionBar(toolbar); ActionBar actionBar = getSupportActionBar(); actionBar.setDisplayShowTitleEnabled(false); fragment1 = new Fragment1(); fragment2 = new Fragment2(); fragment3 = new Fragment3(); getSupportFragmentManager().beginTransaction().replace(R.id.container,fragment1).commit(); }}위의 자바 파일에서 setSupportActionBar 메서드는 액티비티에 디폴트로 만들어진 액션바가 없을경우에만 동작한다.우리가 테마를 액션바가 들어있는 테마로 설정 했기 때문에프로젝트가 만들어질 때 메인 액티비티에서 자동으로 액션바가 만들어진다 .액티비티에 설정된 테마를 변경하기 위해 /app/res/values 폴더 안에 있는 themes.xml 파일을 연다.그리고 아래와 같이 수정한다. &amp;lt;style name=&quot;Theme.SampleTab&quot; parent=&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;&amp;gt;이렇게 하면 이 스타일을 적용한 액티비티에는 액션바가 만들어지지 않는다.액션바를 따로 만들고 싶으면 직접 setSupportActionBar 메서드를 호출하여야 한다.하단 탭 만들기하단 탭은 BottomNavigationView 위젯으로 만들 수 있다./app/res 폴더에 menu 폴더를 만든 후 menu_bottom.xml 파일을 만든다. activity_main.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;FrameLayout android:id=&quot;@+id/container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&amp;gt; &amp;lt;com.google.android.material.bottomnavigation.BottomNavigationView android:id=&quot;@+id/bottom_navigation&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginEnd=&quot;0dp&quot; android:layout_marginStart=&quot;0dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:itemBackground=&quot;?colorPrimary&quot; app:itemIconTint=&quot;@drawable/item_color&quot; app:itemTextColor=&quot;@drawable/item_color&quot; app:menu=&quot;@menu/menu_bottom&quot; /&amp;gt;&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;Activity_main.javapublic class MainActivity extends AppCompatActivity { Fragment1 fragment1; Fragment2 fragment2; Fragment3 fragment3; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); fragment1 = new Fragment1(); fragment2 = new Fragment2(); fragment3 = new Fragment3(); getSupportFragmentManager().beginTransaction().replace(R.id.container, fragment1).commit(); BottomNavigationView bottomNavigation = findViewById(R.id.bottom_navigation); bottomNavigation.setOnNavigationItemSelectedListener(new BottomNavigationView.OnNavigationItemSelectedListener() { @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) { switch (item.getItemId()) { case R.id.tab1: Toast.makeText(getApplicationContext(), &quot;첫 번째 탭 선택됨&quot;, Toast.LENGTH_LONG).show(); getSupportFragmentManager().beginTransaction() .replace(R.id.container, fragment1).commit(); return true; case R.id.tab2: Toast.makeText(getApplicationContext(), &quot;두 번째 탭 선택됨&quot;, Toast.LENGTH_LONG).show(); getSupportFragmentManager().beginTransaction() .replace(R.id.container, fragment2).commit(); return true; case R.id.tab3: Toast.makeText(getApplicationContext(), &quot;세 번째 탭 선택됨&quot;, Toast.LENGTH_LONG).show(); getSupportFragmentManager().beginTransaction() .replace(R.id.container, fragment3).commit(); return true; } return false; } }); }}menu_bottom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; &amp;gt; &amp;lt;item android:id = &quot;@+id/tab1&quot; app:showAsAction=&quot;ifRoom&quot; android:enabled=&quot;true&quot; android:icon=&quot;@android:drawable/ic_dialog_email&quot; android:title=&quot;이메일&quot;/&amp;gt; &amp;lt;item android:id=&quot;@+id/tab2&quot; app:showAsAction=&quot;ifRoom&quot; android:icon=&quot;@android:drawable/ic_dialog_info&quot; android:title=&quot;정보&quot;/&amp;gt; &amp;lt;item android:id=&quot;@+id/tab3&quot; app:showAsAction=&quot;ifRoom&quot; android:enabled=&quot;true&quot; android:icon=&quot;@android:drawable/ic_dialog_map&quot; android:title=&quot;위치&quot;/&amp;gt;&amp;lt;/menu&amp;gt;결과하단 탭 커스텀res/drawable/custom_buttom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&amp;gt; &amp;lt;solid android:color=&quot;@color/white&quot;/&amp;gt; &amp;lt;corners android:topRightRadius=&quot;20dp&quot; android:topLeftRadius=&quot;20dp&quot;/&amp;gt; &amp;lt;stroke android:color=&quot;#F5F5F5&quot; android:width=&quot;1dp&quot;/&amp;gt;&amp;lt;/shape&amp;gt;activity.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/parent&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/base_bg&quot;&amp;gt; &amp;lt;FrameLayout android:id=&quot;@+id/container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;/&amp;gt; &amp;lt;com.google.android.material.bottomnavigation.BottomNavigationView android:id=&quot;@+id/bottom_navigation&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;70dp&quot; android:layout_gravity=&quot;bottom&quot; android:background=&quot;@drawable/bottom&quot; app:itemIconTint=&quot;@color/black&quot; app:itemPaddingTop=&quot;20dp&quot; app:itemTextColor=&quot;@drawable/item_color&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:menu=&quot;@menu/menu_bottom&quot; /&amp;gt;&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;참고 : href=” https://stackoverflow.com/questions/64234753/is-there-a-way-to-add-rounded-corners-to-an-android-material-view-bottom-navigathttps://onlyfor-me-blog.tistory.com/425" }, { "title": "Action Bar", "url": "/posts/ActionBar/", "categories": "Android, Widget", "tags": "android, fragment", "date": "2022-01-09 20:57:00 +0900", "snippet": "액션바 사용하기옵션메뉴는 액션바에 포함되어 보이도록 만들어져 있다.액션바는 액의 제목(Title)이 보이는 위쪽 부분을 말한다.옵션 메뉴와 컨텍스트 메뉴는 각각의 액티비티마다 설정할 수 있으므로 액티비티에추가하고 싶은 경우에는 다음이 두 메서드를 다시 정의하여 메뉴 아이템을 추가할 수 있다.public boolean onCreateOptionsMenu (Menu menu)pulbic void onCreateContextMenu (ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo)이 두개의 메서드를 보면 Menu나 ContextMenu 객체가 전달되는 것을 알 수 있다.이 객체의 add 메서드를 사용해서 메뉴 아이템을 추가해야한다.대표적인 add 메서드는 아래와 같다.MenuItem add (int groupId, int order, CharSequence title)MenuItem add (int groupId, int order, int titleRes)SubMenu addSubMenu(int titleRes)grupId: 아이템을 하나의 그룹으로 묶을 때 사용itemId: 아이템이 갖는 고유 ID 값아이템이 많아서 서브 메뉴를 추가하고 싶을 때는 addSubMenu 메서드를 사용한다.하지만 이렇게 코드에서 메뉴를 추가하는 것 보다는 XML에서 메뉴의 속성을 정의한 후객체로 로딩하여 참조하는 것이 더 간단하다.메뉴 기능 예제/app/res 폴더 오른쪽 마우스 -&amp;gt; New Directory -&amp;gt; menu 폴더 생성/app/res/menu 폴더를 선택한 상태에서 마우스 오른쪽 버튼 -&amp;gt; New Menu resouce file그 후 아래와 같이 xml 파일을 수정한다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&amp;gt; &amp;lt;item android:id =&quot;@+id/menu_refresh&quot; android:title=&quot;새로고침&quot; android:icon=&quot;@drawable/menu_refresh&quot; app:showAsAction=&quot;always&quot; /&amp;gt; &amp;lt;item android:id = &quot;@+id/menu_search&quot; android:title=&quot;검색&quot; android:icon=&quot;@drawable/menu_search&quot; app:showAsAction=&quot;always&quot; /&amp;gt; &amp;lt;item android:id = &quot;@+id/menu_settings&quot; android:title=&quot;설정&quot; android:icon=&quot;@drawable/menu_settings&quot; app:showAsAction=&quot;always&quot; /&amp;gt;&amp;lt;/menu&amp;gt;item 태그는 하나의 메뉴에 대한 정보를 담고 있고,showAsAction 속성은 이 메뉴를 항상 보이게 할 것인지 아닌지를 설정하는 것이다.아래는 showAsAction 속성 값을 정리한 것이다.showAsAction 속성에 설정할 수 있는 값 showAsAction 속성 값 설 명 always 항상 액션 바에 아이템을 추가하여 표시한다. never 액션바에 아이템을 추가하여 표시하지 않는다. (디폴트) ifRoom 액션바에 여유 공간이 있을 때만 아이템을 표시한다. withText title 속성으로 설정된 제목을 같이 표시한다. collapseActionView 아이템에 설정한 뷰의(actionView Layout)의 아이콘만 표시한다. 이렇게 정의한 메뉴들은 MainActivity.java에 정의된 onCreateOptionsMenu 메서드는액티비티가 만들어질 때 미리 자동 호출되어 화면에 메뉴 기능을 추가할 수 있도록 한다.인제 MainActivity.java 파일을 수정해 보자.MainActivity.javapublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } @Override public boolean onCreateOptionsMenu(Menu menu){ getMenuInflater().inflate(R.menu.menu_main, menu); return true; } @Override public boolean onOptionsItemSelected(MenuItem item){ int curId = item.getItemId(); switch(curId){ case R.id.menu_refresh: Toast.makeText(this,&quot;새로고침 메뉴가 선택 되었습니다.&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.menu_search: Toast.makeText(this, &quot;검색 메뉴가 선택 되었습니다.&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.menu_settings: Toast.makeText(this,&quot;설정 메뉴가 선택 되었습니다.&quot;, Toast.LENGTH_SHORT).show(); } return super.onOptionsItemSelected(item); }}결과액션바 좀 더 살펴보기액티비티 위쪽에 보이는 타이틀 부분과 옵션 메뉴는 액션바로 합쳐져 보이게 된다.먼저 액션바는 기본적으로 제목을 보여주는 타이틀의 기능을 해서 앱의 제목을 보여줄 수 있고,화면에 보이거나 보이지 않도록 만들 수 있다.소스 코드에서 액션바를 보이게 만들고 싶아면 다음 코드처럼 show 메서드를 호출하고감추고 싶다면 hide 메서드를 호출하면 된다.ActionBar abar = getActionBar();abar.show()abar.hide()검색 기능 추가MainActivity.javapublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public boolean onCreateOptionsMenu(Menu menu) { /* XML로 정의된 메뉴 정보를 인플레이션 하여 메모리에 로딩*/ getMenuInflater().inflate(R.menu.menu_main, menu); /* 메뉴 아이템 중에서 검색을 위해 정의한 이템을 뷰 객체로 참조*/ View v = menu.findItem(R.id.menu_search).getActionView(); if (v != null) { /*검색을 위한 메뉴 아이템 안에 정의한 입력상자 객체 참조 */ EditText editText = v.findViewById(R.id.editText); if (editText != null) { /* 입력 상자에 객체 리스너 설정 */ editText.setOnEditorActionListener(new TextView.OnEditorActionListener() { @Override public boolean onEditorAction(TextView v, int actionId, KeyEvent event) { Toast.makeText(getApplicationContext(), &quot;입력됨.&quot;, Toast.LENGTH_LONG).show(); return true; } }); } } return true; }}avtivity_main.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&amp;gt;&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;search_layout.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&amp;gt; &amp;lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;검색 :&quot; android:textColor=&quot;#ffad8745&quot; android:textSize=&quot;16sp&quot; /&amp;gt; &amp;lt;EditText android:id=&quot;@+id/editText&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;4dp&quot; android:imeActionId=&quot;1337&quot; android:imeOptions=&quot;actionDone&quot; android:inputType=&quot;text&quot; /&amp;gt;&amp;lt;/LinearLayout&amp;gt;menu_main.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&amp;gt; &amp;lt;item android:id=&quot;@+id/menu_refresh&quot; android:icon=&quot;@drawable/menu_refresh&quot; android:title=&quot;새로고침&quot; app:showAsAction=&quot;always&quot; /&amp;gt; &amp;lt;item android:id=&quot;@+id/menu_settings&quot; android:icon=&quot;@drawable/menu_settings&quot; android:title=&quot;설정&quot; app:showAsAction=&quot;always&quot; /&amp;gt; &amp;lt;item android:id=&quot;@+id/menu_search&quot; android:orderInCategory=&quot;102&quot; android:title=&quot;검색&quot; app:actionLayout=&quot;@layout/search_layout&quot; app:showAsAction=&quot;always|withText&quot; /&amp;gt;&amp;lt;/menu&amp;gt;결과" }, { "title": "프래그먼트로 화면 만들기", "url": "/posts/ViewFragment/", "categories": "Android, Navigation", "tags": "android, fragment", "date": "2022-01-09 19:41:00 +0900", "snippet": "프래그먼트로 화면 만들기MainActivity에 버튼을 3개 추가 한 후 Fragment 파일을 추가 해준다.ListFragment.java public static interface ImageSelectionCallback{ public void onImageSelected(int position); } public ImageSelectionCallback callback; @Override public void onAttach(Context context){ super.onAttach(context); if(context instanceof ImageSelectionCallback){ callback = (ImageSelectionCallback) context; } } @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState){ ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.fragment_list, container, false); Button button = rootView.findViewById(R.id.button); button.setOnClickListener((v)-&amp;gt;{ if(callback !=null) callback.onImageSelected(0); }); Button button2 = rootView.findViewById(R.id.button2); button2.setOnClickListener((v)-&amp;gt;{ if(callback !=null) callback.onImageSelected(1); }); Button button3 = rootView.findViewById(R.id.button3); button3.setOnClickListener((v)-&amp;gt;{ if(callback!=null) callback.onImageSelected(2); }); return rootView; }ViewerFragment.javapublic class ViewerFragment extends Fragment { ImageView imageView; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState){ ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.fragment_viewer, container, false); imageView = rootView.findViewById(R.id.imageView); return rootView; } public void setImage(int resId){ imageView.setImageResource(resId); }}public class MainActivity extends AppCompatActivity implements ListFragment.ImageSelectionCallback{ ListFragment listFragment; ViewerFragment viewerFragment; int images[] = {R.drawable.dream01, R.drawable.dream02, R.drawable.dream03}; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FragmentManager manager= getSupportFragmentManager(); listFragment = (ListFragment) manager.findFragmentById(R.id.listFragment); viewerFragment = (ViewerFragment) manager.findFragmentById(R.id.viewerFragment); } @Override public void onImageSelected(int position){ viewerFragment.setImage(images[position]); }}activity_main.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot; &amp;gt; &amp;lt;fragment android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:name=&quot;org.techtown.fragment.ListFragment&quot; android:id=&quot;@+id/listFragment&quot; /&amp;gt; &amp;lt;fragment android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:name=&quot;org.techtown.fragment.ViewerFragment&quot; android:id=&quot;@+id/viewerFragment&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt;" }, { "title": "Fragment", "url": "/posts/Fragment/", "categories": "Android, Navigation", "tags": "android, fragment", "date": "2022-01-09 02:48:00 +0900", "snippet": "프래그먼트같은 레이아웃을 여러 화면에 사용한다면 화면을 구성하는 XML 레이아웃 파일의 코드와 기능을동작시키는 소스 코드가 중복될 수 밖에 없다.이렇게 화면 안에 들어가는 레이아웃이 중복되는 문제를 해결 하기 위해 부분 화면을 위한 레이아웃이나소스 코드를 한 번만 정의하고 재사용할 수 있도록 만든것 이 프래그먼트이다.프래그먼트 사용 목적 분할된 화면들을 독립적으로 구성하기 위해 사용함 분할된 화면들의 상태를 관리하기 위해 사용함.프래그먼트는 다음과 같이 동작한다.왼쪽은 액티비티가 동작하는 방식인데, 액티비티는 앱 구성 요소이므로 안드로이드 시스템에서 관리한다.즉 액티비티 매니저가 액티비티의 동작 순서나 처리 방식을 결정한다.또한 액티비티가 시스템에서 관리되기 때문에 시스템이 이해하는 형식으로 명령이나 데이터를만들어 보내야 하는데, 인텐트가 그 역할을 한다.오른쪽은 프래그먼트가 동작하는 방식인데 액티비티와 유사하다.액티비티 매니저 대신 프래그먼트 매니저가 있고, 액티비티가 시스템 역할을 한다.그리고 프래그먼트에서는 인텐트를 사용하지 않는데 그 이유는 인텐트는 시스템에서 이해하는 객체여서프래그먼트와 액티비티 사이에 전달하게 만드는것은 바람직하지 않기 때문이다.대신 인텐트대신 메서드를 만들어 메서드를 호출하는 방식을 사용한다.프래그먼트는 액티비티 위에 올라가 있어 액티비티를 전환하지 않고도 훨씬 가볍게 화면 전환 효과를 낼 수 있다.프래그먼트 사용하기프래그먼트도 부분 화면이므로 화면에 뷰들을 배치할 때는 XML 레이아웃으로 만든다.그 다음에는 프래그먼트를 위한 자바 소스를 만들어주고 Fragment 클래스를 상속하여 만들 수 있다.클래스까지 만들었으면 XML 레이아웃 파일의 내용을 Java 파일과 매칭하는 과정이 필요하다.그런데 프래그먼트에는 setContentView 메서드가 없고 대신 LayoutInflater를 사용해 인플레이션을 진행해야 한다.XML 레이아웃 파일의 내용을 인플레이션 한 후 클래스에서 사용하도록 하는 코드는 onCreateView 메서드 안에들어간다. 이 메서드는 콜백 메서드로 인플레이션이 필요한 시점에 자동으로 호출 된다.프래그먼트 파일을 생성해준다이름을 설정한다최상위 레이아웃을 LinearLayout(vertical)으로 바꾸고 텍스트 뷰 삭제한다.텍스트 뷰와 버튼을 추가한 후 MainFragment.java 파일에서 onCreateView 메서드만 남겨 놓는다.public class MainFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { /*이 메서드의 매개변수에 LayoutInflater 객체가 전달되므로 inflate 메서드를 바로 호출 가능 inflate 메서드의 첫 번째 매개변수에는 XML 레이아웃 파일이되고 두 번째 매개 변수는 이 XML 레이아웃이 설정 될 뷰 그룹 객체가 된다. 즉 container가 이 프래그먼트의 가장 상위 레이아웃이다.*/ return inflater.inflate(R.layout.fragment_main, container, false); // 뷰 그룹 객체 반환 }}그 후 activity_main.xml 파일을 열과 다음과 같이 코드를 수정한다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;fragment android:id=&quot;@+id/mainFragment&quot; android:name=&quot;org.techtown.samplefragment.MainFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&amp;gt; &amp;lt;/FrameLayout&amp;gt;프래그먼트는 뷰와 달라서 뷰를 담고 있는 공간만 확보한다.따라서 태그 이름으로 프래그먼트의 이름을 사용할 수 없으며, name 속성에 새로 만든MainFragment의 이름을 설정한다. 프래그 먼트의 이름을 설정할 때는 패키지 이름을 포함한 이름으로 설정한다.결과이렇게 하면 activity_main.xml 위에 fragment_main.xml 파일이 위에 올라가게 된다.위 과정을 세 줄 요약하면 아래와 같다.1. 프래그 먼트를 위한 XML 레이아웃 파일 만들기2. 프래그먼트 클래스 만들기3. 프래그먼트를 액티비티의 XML 레이아웃에 추가하기프래그먼트 메소드 정리public final Activity getActivity() -&amp;gt; 이 프래그먼트를 포함하는 액티비티를 반환함public final FragmentManager getFragmentManager() -&amp;gt; 이 프래그먼트를 포함하는 액티비티에서 프래그먼트 객체들과 관련된 프래그먼트 매니저를 반환함.public final Fragment getParentFragment() -&amp;gt; 이 프래그먼트를 포함하는 부모가 프래그먼트일 경우 리턴함. 액티비티이면 null을 반환.public final int getId() -&amp;gt; 이 프래그먼트 ID를 반환함.public abstract FragmentTransaction() -&amp;gt; 프래그먼트를 변경하기 위한 트랜잭션을 시작함.public abstract Fragment findFragmentById (int id) -&amp;gt; ID를 이용해 프래그먼트 객체를 찾음.public abstract Fragment findFragmentByTag (String tag) -&amp;gt; 태그 정보를 사용해 프래그먼트 객체를 찾음.public abstract boolean executePendingTransactions() -&amp;gt; 트랜잭션은 commit 메서드를 호출하면 실행되지만 비동기(asynchronous) 방식으로 실행되므로 즉시 실행하고 싶다면 이 메서드를 추가로 호출함.메뉴 프래그먼트 만들고 화면 전환 예시위와 같이 메뉴 프래그먼트 파일을 생성해주고 아래와 같이 코드를 수정해준다.MainActivity.javapublic class MainActivity extends AppCompatActivity { MainFragment mainFragment; MenuFragment menuFragment; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mainFragment = (MainFragment) getSupportFragmentManager().findFragmentById(R.id.mainFragment); menuFragment = new MenuFragment(); } public void onFragmentChanged(int idx){ if (idx ==0 ) getSupportFragmentManager().beginTransaction().replace(R.id.container, menuFragment).commit(); else if (idx == 1) getSupportFragmentManager().beginTransaction().replace(R.id.container,mainFragment).commit(); }}MainFragment.javapublic class MainFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.fragment_main, container,false); Button button = rootView.findViewById(R.id.button); button.setOnClickListener((v)-&amp;gt;{ MainActivity activity = (MainActivity) getActivity(); activity.onFragmentChanged(0); }); return rootView; // 뷰 그룹 객체 반환 }}MenuFragment.javapublic class MenuFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.fragment_menu, container,false); Button button1 = rootView.findViewById(R.id.button1); button1.setOnClickListener((v)-&amp;gt;{ MainActivity activity = (MainActivity) getActivity(); activity.onFragmentChanged(1); }); return rootView; }}액티비티와 프래그먼트가 의사소통하는 방식결과프래그먼트의 생명주기프래그먼트는 액티비티를 본떠 만들어서 액티비티처럼 독립적으로 동작하도록 하는 생명주기 메서드가 있다.프래그먼트를 사용하는 목적 중의 하나가 분할된 화면들의 상태를 관리하는 것인데이것을 가능하게 하는 것이 생명주기 메서드이다.즉, 액티비티 안에 들어있는 프래그먼트도 필요할 때 화면에 보이거나 보이지 않게 되므로액티비티 처럼 각각의 상태가 관리되는 것이 필요하다.한 가지 주의 해야할 점은 프래그먼트는 액티비티 안에 추가되어 사용되면서 동시에 액티비티에종속되어 있어 프래그먼트와 액티비티가 연결되어야 초기화 될 수 있다.이 때문에 new 연산자를 사용해 프래그먼트 객체를 만드는 시점과 onCreate 메서드가 호출되는시점이 달라진다. onAttach 메서드가 호출될 때 파라미터로 전달되는 액티비티 객체 위에프래그먼트가 올라가 있게 된다.즉, 액티비티를 위해 설정해야 하는 정보들은 onAttach 메서드에서 처리해야함화면에 보이기 전에 호출되는 상태 메서드 메서드 설명 onAttach(Activity) 프래그먼트가 액티비티와 연결될 때 호출됨 onCreate(Bundle) 프래그먼트가 초기화 될 때 호출된다. 주의! new 연산자를 이용해 새로운 프래그먼트 객체를 만드는 시점이 아님! onCreateView(LayoutInflator,ViewGroup, Bundle) 프래그먼트와 관련되는 뷰 계층을 만들어 리턴함. onActivityCreated(Bundle) 프래그먼트와 연결된 액티비티가 onCreate 메서드의 작업을 완료 했을 때 호출됨. onStart() 프래그먼트와 연결된 액티비티가 onStart되어 사용자에게 프래그먼트가 보일 때 호출됨 onResume() 프래그먼트와 연결된 액티비티가 onResume되어 사용자와 상호작용할 수 있을 때 호출됨 중지되면서 호출되는 메서드 메서드 설명 onPause() 프래그먼트와 연결된 액티비티가 onPause되어 사용자와 상호작용을 중지할 때 호출됨. onStop 프래그먼트와 연결된 액티비티가 onStop되어 화면에서 더 이상 보이지 않을 때나 프래그먼트의 기능이 중지되었을 때 호출됨 onDestoryView() 프래그먼트와 관련된 뷰 리소스를 해체할 수 있도록 호출됨 onDestory() 프래그먼트의 상태를 마지막으로 정리할 수 있도록 호출됨 onDetach() 프래그먼트가 액티비티와 연결을 끊기 바로 전에 호출됨 프래그먼트 수명 주기onAttach와 onDetach는 프래그먼트가 액티비티 위에 올라갈 때와 떨어져 나올 때 호출된다.마지막으로 프래그먼트 객체가 new 연산자로 만들어 졌더라도 액티비티 위에 올라가기 전까지동작하지 않는 점을 기억하자." }, { "title": "Activity Life Cycle", "url": "/posts/LifeCycle/", "categories": "Android, AppComponents", "tags": "android, fragment", "date": "2022-01-09 00:20:00 +0900", "snippet": "프로세스와 테스크프로세스는 독립적인 하나의 상자와 같아서 다른 프로세스와 정보를 공유할 수 없다.따라서 하나의 프로세스에서 다른 프로세스의 화면을 띄우려면 시스템의 도움이 필요하다.시스템에서 액티비티의 각종 정보를 저장 해두기 위해 태스크라는 것을 만든다.시스템은 알아서 태스크를 관리하지만 우리가 직접 제어해야 하는 경우가 생긴다.이를 위해 메니페스트 파일에 액티비티를 등록할 때 태스크도 함께 설정할 수 있다.예제를 통해 알아보자텍스트뷰와 버튼이 있는 액티비티의 MainActivity.java 파일에서 버튼을 눌렀을 때인텐트를 사용해 MainActivity 화면을 띄울 수 있도록 코드를 입력해보자.public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = findViewById(R.id.button); button.setOnClickListener((v) -&amp;gt; { Intent intent = new Intent(getApplicationContext(), MainActivity.class); startActivity(intent); }); }}이렇게 하면 버튼을 누를 때마다 첫 화면이 반복해서 나오게 된다.그 후 돌아가기 버튼을 클릭하면 동일한 화면이 여러 개 중첩이 되어 있다는 것을 확인할 수 있다.AndroidManifest.xml 파일에서 MainActivity를 등록하는 태그에 launchMode 속성을 추가하고그 값을 standrad로 한 것과 같다. 다시 말하면, 태스크는 새로 뜨는 화면을 차례대로 스택에 넣어서 관리한다.이번에는 Manifiest 파일에서 activity 태그 안에 launchMode 속성을 추가해 보자.&amp;lt;activity android:name=&quot;.MainActivity&quot; android:launchMode=&quot;singleTop&quot; android:exported=&quot;true&quot;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt; &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;/activity&amp;gt;이렇게 singleTop으로 설정하면 태스크의 가장 위쪽에 있는 액티비티는 더 이상 새로 만들지 않게 되고,버튼을 여러 번 누른 후 Back 버튼을 누르면 이전과 달리 앱의 화면이 사라지게 된다.액티비티의 수명주기와 sharedPreferences액티비티는 액티비티 스택에 보관하다가 현재 화면에 보이는 액티비티가 사라지면 다시 이전 액티비티가동작하는 과정을 거친다. 이 때문에 하나의 액티비티가 화면에 보이거나 보이지 않게 되었을 때 다른액티비티의 상태에 영향을 미칠 수 있다.예를 들어, 우리가 만든 앱이 실행되는 도중에 전화가 오면 통화 앱이 화면에 나타나기 때문에 우리가 만든앱 화면은 다른 화면 뒤로 들어가 중지될 수 있다.이렇게 액티비티는 처음 실행될 때 메모리에 만들어지는 과정부터 시작해서 실행과 중지, 그리고 메모리에서 해제되는 여러 과정의 상태 정보로 갖고 있으며, 이런 상태 정보는 시스템이 관리 하면서 각각의 상태에 해당하는메서드를 자동으로 호출하게 된다.액티비티의 대표적인 상태 정보는 아래와 같다. 상태 설명 실행(Running) 화면상에 액티비티가 보이면서 실행되어 있는 상태 액티비티 스택의 최상위에 있으며 포커스를 가지고 있음 일시 정지(Paused) 사용자에게 보이지만 다른 액티비티가 위에 있어 포커스를 받지 못하는 상태 대화 상자가 위에 있어 일부가 가려진 경우에 해당함 중지(Stopped) 다른 액티비티에 의해 완전히 가려져 보이지 않는 상태 이렇게 액티비티의 상태 정보가 변화하는 것을 액티비티의 ‘수명주기(Life Cycle)’ 또는생명주기라 하며 액티비티가 처음 만들어진 후 없어질 때 까지 상태가 변화 하면서 각각에 해당하는메서드가 자동으로 호출된다.다음은 액티비티 생명주기의 다이어 그램이다.액티비티의 상태 메서드 상태메서드 설명 onCreate() 액티비티가 처음 만들어졌을 때 호출된다.화면에 보이는 뷰들의 일반적인 상태를 설정하는 부분이다.이전 상태가 저장되어 있는 경우엔 번들 객체를 참조하여 이전 상태 복원이 가능하다. onStart() 액티비티가 화면에 보이기 바로 전에 호출된다.액티비티가 화면 상에 보이면 이 메소드 다음에 onResume() 메소드가 호출된다.액티비티가 화면에서 가려지게 되면 이 메소드 다음에 onStop() 메소드가 호출된다. onResume() 액티비티가 사용자와 상호작용하기 바로 전에 호출된다.onPause()에서 저장한 데이터를 다시 복원하는 기능을 한다. onRestart() 액티비티가 중지된 이후에 호출되는 메소드로 다시 시작되기 바로 전에 호출된다. 이 메소드 다음에는 항상 onStart() 메소드가 호출된다. onPause() 또 다른 액티비티를 시작하려고 할 때 호출된다.저장되지 않은 데이터를 저장소에 저장하거나, 애니메이션 중인 작업을 중지하는 등의 기능을 수행한다.이 메소드가 리턴하기 전에는 다음 액티비티가 시작될 수 없으므로 매우 빨리 수행되어야 한다.액티비티가 이 상태에 들어가면 시스템은 액티비티를 강제 종료할 수 있다. onStop() 액티비티가 사용자에게 더 이상 보이지 않을 때 호출된다.액티비티가 소멸되거나 또 다른 액티비티가 화면을 가릴 때 호출된다.액티비티가 이 상태에 들어가면 시스템은 액티비티를 강제 종료할 수 있다. onDestroy() 액티비티가 소멸되어 없어지기 전에 호출된다.액티비티가 앱에 의해 종료되거나(finish() 메소드 호출) 시스템이 강제로 종료시키는 경우에 호출될 수 있다. onPause 메서드 안에서 데이터를 저장하고 onResum 메서드안에서 복원할 수 있지만,SharedPreferences를 사용하여 앱 안에서 간단한 데이터를 저장하거나 복원할 수 있다.상태 주기 확인 및 SharedPreferenecs 예제MainActivity.javapublic class MainActivity extends AppCompatActivity { EditText nameInput; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = findViewById(R.id.button); button.setOnClickListener((v) -&amp;gt; { Intent intent = new Intent(getApplicationContext(), MenuActivity.class); startActivity(intent); }); Toast.makeText(this, &quot;onCreate 호출됨&quot;, Toast.LENGTH_LONG).show(); println(&quot;onCreate 호출됨&quot;); } @Override protected void onStart() { super.onStart(); Toast.makeText(this, &quot;onStart 호출됨&quot;, Toast.LENGTH_LONG).show(); println(&quot;onStart 호출됨&quot;); } @Override protected void onStop() { super.onStop(); Toast.makeText(this, &quot;onStop 호출됨&quot;, Toast.LENGTH_LONG).show(); println(&quot;onStop 호출됨&quot;); } @Override protected void onDestroy() { super.onDestroy(); Toast.makeText(this, &quot;onDestroy 호출됨&quot;, Toast.LENGTH_LONG).show(); println(&quot;onDestroy 호출됨&quot;); } @Override protected void onPause() { super.onPause(); Toast.makeText(this, &quot;onPause 호출됨&quot;, Toast.LENGTH_LONG).show(); println(&quot;onPause 호출됨&quot;); saveState(); } @Override protected void onResume() { super.onResume(); Toast.makeText(this, &quot;onResume 호출됨&quot;, Toast.LENGTH_LONG).show(); println(&quot;onResume 호출됨&quot;); restoreState(); } public void println(String data) { Toast.makeText(this, data, Toast.LENGTH_LONG).show(); Log.d(&quot;Main&quot;, data); } protected void restoreState() { // 저장소 이름을 pref로 설정 // SharedPreferences를 사용하려면 getSharedPreferences로 참조 해야함 SharedPreferences pref = getSharedPreferences(&quot;pref&quot;, Activity.MODE_PRIVATE); if ((pref != null) &amp;amp;&amp;amp; (pref.contains(&quot;name&quot;))) { String name = pref.getString(&quot;name&quot;, &quot;&quot;); nameInput.setText(name); } } protected void saveState() { SharedPreferences pref = getSharedPreferences(&quot;pref&quot;, Activity.MODE_PRIVATE); SharedPreferences.Editor editor = pref.edit(); editor.putString(&quot;name&quot;, nameInput.getText().toString()); editor.commit(); } protected void clearState() { SharedPreferences pref = getSharedPreferences(&quot;pref&quot;, Activity.MODE_PRIVATE); SharedPreferences.Editor editor = pref.edit(); editor.clear(); editor.commit(); }MenuActivitypublic class MenuActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_menu); Button button = findViewById(R.id.button2); button.setOnClickListener((v)-&amp;gt;{ finish(); }); }" }, { "title": "액티비티 중복문제, 인텐트 객체 전달", "url": "/posts/Flag-ExtraData/", "categories": "Android, AppComponents", "tags": "android, flag, extradata, parcelable", "date": "2022-01-07 22:14:00 +0900", "snippet": "액티비티 중복 문제액티비티로 만든 화면이 한 번 메모리에 만들어 졌는데도 계속 startActivity나 startActivityForResult 메서드를여러번 호출하면 메모리에 동일한 액티비티가 여러개 만들어진다.왜냐하면 시스템이 인텐트별로 새 액티비티를 띄워주기 때문이다.만약 같은 액티비티에 대해 인텐트를 두 번 보내면 중복된 액티비티가 뜨게 된다.중복된 액티비티가 띄워지지 않게 할려면 어떻게 해야할까?이럴 때 사용하는게 바로 플래그이다.플래그플래그를 이해하기 전에 액티비티가 처리되는 방식을 알아보자.액티비티는 액티비티 매니저(Activity Manager)라는 객체에 의해 액티비티 스택(Acticity Stack)이 관리된다.액티비티 스택은 액티비티를 차곡차곡 쌓아두었다가 가장 상위에 있던 액티비티가 없어지면이전의 액티비티가 다시 화면에 보이게 된다.새로운 액티비티를 만들어 매니페스트 파일에 등록하면 그 액티비티 startActivity 또는 startActivityForReuslt메서드를 사용해 실행된다. 이렇게 실행된 액티비티는 화면에 띄워지고 새로운 액티비티가 화면에 띄워지면이전에 있던 액티비티는 스택에 저장되고 새로운 액티비티가 화면에 보이는 구조이다.이렇게 일반적인 스택 구조를 이용해 액티비티가 관리되는데 동일한 액티비티를 여러 번 실행하게 되면,동일한 액티비티가 여러 개 스택에 들어가게 되고 동시에 데이터를 여러 번 접근하거나 리소스를 여러 번사용하는 문제가 발생할 수 있다. 이러한 문제를 해결할 수 있는게 플래그이다.대표적인 플래그는 아래와 같다. 플래그 설명 FLAG_ACTIVITY_SINGLE_TOP 이미 생성된 액티비티가 있으면, 그 액티비티를 그대로 사용하는 플래그 FLAG_ACTIVITY_NO_HISTORY 처음 이후에 실행되는 Activity는 스택에 들어가지 않음 (알람 같은거) FLAG_ACTIVITY_CLEAR_TOP 현재 Activity 이외 Activity는 모두 종료 액티비티가 새로 만들어지지 않고 재사용된다면 액티비티의 onCreate 메서드가 호출되지 않는다.이 경우에는 새로 띄워지는 액티비티에서 인텐트를 전달 받아 처리하는 방법이 따로 있어야 한다.그것이 바로 onNewIntent 메서드이다.이 메서드를 재정의하면 액티비티가 새로 만들어지지 않았을 때 인텐트 객체만 전달 받을 수 있다.부가데이터한 액티비티에서 다른 액티비티를 띄울 때 데이터를 전달해야 하는 경우가 있다.예를 들어, 로그인 화면에서 로그인 버튼을 눌러 로그인을 성공하면 메뉴 화면으로 아이디를전달하여 표시해야 할 수도 있다.어떻게 하면 로그인 화면에서 메뉴 화면으로 아이디를 전달할 수 있을까?가장 간단한 방법은 별도의 클래스를 만든 다음 그 안에 클래스 변수를 만들어 두 개의 화면에서모두 그 변수를 참조하게 하는 방법이다.즉, 로그인 화면에서 값을 설정하고 메뉴 화면에서 로그인 화면의 변수 값을 참조하면 된다.하지만 이 경우 다른 앱에서 우리가 만든 화면을 띄울 수도 있기 떄문에 변수를 공유하는 방식으로데이터를 전달하는 것이 불가능할 수도 있다.따라서 기본적으로 액티비티를 띄울 때 전달되는 인텐트 안에부가 데이터(Extra data)를 넣어 전달하는 방법을 권장한다.인텐트 안에는 번들(Bundle) 객체가 들어 있는데, 번들 객체는 해시테이블과 유사해서putExtra와 get-기본 자료형 이름Extra 메서드로 데이터를 넣거나 빼낼 수 있다.예를 들어 문자열을 넣고 싶을 때는 putExtra 메서드를 호출하고,문자열을 다시 빼내고 싶을때는 getStringExtra 메서드를 이용하면된다.또한, getOOO() 형태를 가진 메서드는 데이터 값이 없으면 디폴트로 설정한 defaultValue 값이 반환된다.전달하고 싶은 데이터가 객체인 경우에는 객체 자체를 전달 할 순 없고, 객체 데이터를 바이트 배열로변환하거나 Serializable 인터페이스를 구현하는 객체를 만들어 직렬화한 다음 전달 해야한다.하지만 안드로이드에서는 Serializable 인터페이스와 유사한 Parcelable 인터페이스를 권장한다.Parcelable 인터페이스는 직렬화 했을 때 크기가 작아 안드로이드 내부의 데이터 전달에 자주 사용된다.이 인터페이스를 사용하려면 아래의 두 가지 메서드를 모두 구현해야 한다.public abstract int describleContents() // 객체의 유형을 구분할 때 사용/* 객체가 가지고 있는 데이터를 Parcel 객체로 만들어주는 역할 */public abstract void writeToParcel(Parcel dest, int flags) 위 두가지 메소드를 다 구현한 다음에는 CREATOR라는 상수를 만들어야 한다.CREATOR 상수는 Parcel 객체로부터 데이터를 읽어 들여 객체를 생성하는 역할을 한다.Parcelable 예제java 파일 프로젝트에 폴더에 class 하나를 아래와 같이 추가해준다.public class SimpleData implements Parcelable { int number; String message; public SimpleData(int num, String msg) { number = num; message = msg; } /* Parcel 객체에서 읽기 */ public SimpleData(Parcel src) { number = src.readInt(); message = src.readString(); } /* Creator 상수 정의 */ public static final Creator CREATOR = new Creator() { public SimpleData createFromParcel(Parcel in) { return new SimpleData(in); } public SimpleData[] newArray(int size) { return new SimpleData[size]; } }; public int describeContents(){ return 0; } /* Parcel 객체로 쓰기 */ /* Simple Data 객체 안에 있는 데이터를 Parcel 객체로 만드는 역할을 한다*/ public void writeToParcel(Parcel dest, int flags){ dest.writeInt(number); dest.writeString(message); }}MainActivity.java 코드를 수정한다.public class MainActivity extends AppCompatActivity { public static final int REQUEST_CODE_MENU = 101; public static final String KEY_SIMPLE_DATA = &quot;data&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = findViewById(R.id.button); button.setOnClickListener((v)-&amp;gt;{ Intent intent = new Intent(getApplicationContext(),MenuActivity.class); SimpleData data = new SimpleData(100, &quot;Hello Android&quot;); intent.putExtra(KEY_SIMPLE_DATA,data); startActivityForResult(intent,REQUEST_CODE_MENU); }); }}MenuActivity.java 코드를 수정한다.public class MenuActivity extends AppCompatActivity { TextView textView; public static final String KEY_SIMPLE_DATA = &quot;data&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_menu); textView = findViewById(R.id.textView); Button button = findViewById(R.id.button2); button.setOnClickListener((v)-&amp;gt;{ Intent intent = new Intent(); intent.putExtra(&quot;name&quot;,&quot;mike&quot;); setResult(RESULT_OK,intent); finish(); }); // 메인 액티비티로부터 전달 받은 인텐트 참조 Intent intent = getIntent(); processIntent(intent); } private void processIntent(Intent intent){ if(intent != null){ // getExtras() -&amp;gt; 번들 객체 반환 Bundle bundle = intent.getExtras(); /* 번들 객체 안에 SimpleData 객체가 들어 있으므로 getParcelable 메서드로 객체를 참조한다. */ SimpleData data = bundle.getParcelable(KEY_SIMPLE_DATA); if(intent != null){ textView.setText(&quot;전달 받은 데이터\\n Number : &quot; + data.number + &quot; \\nMessage : &quot; + data.message); } } }}결과이렇게 Parcelable 인터페이스를 사용하면 객체를 정의해 데이터를 전달할 수 있으므로 코드가좀 더 단순해지고 재사용성이 높아지는 장점이 생기게 된다.하지만 데이터를 담아둘 새로운 객체를 일일이 정의하는 것이 번거롭다는 단점이 있다." }, { "title": "Intent", "url": "/posts/Intent/", "categories": "Android, AppComponents", "tags": "android, intent", "date": "2022-01-07 22:14:00 +0900", "snippet": "인텐트.android.content 패키지 안에 정의되어 있는 인텐트는 앱 구성 요소 간에 작업 수행을 위한정보를 전달하는 역할을 한다.다른 앱 구성 요소에 인텐트를 전달할 수 있는 대표적인 메서드는 다음과 같다.startActivity() // 액티비티를 화면에 띄울 때 사용startActivityForResult() // startService() // 서비스를 시작할 때 사용bindService() // broadcastIntent() // 인텐트 객체를 브로드 캐스팅 방식으로 전송할 때 사용인텐트의 기본 구성 요소는 액션(Action)과 데이터(Data)이다.액션은 수행할 기능이고, 데이터는 액션이 수행될 대상의 데이터를 의미한다.액션과 데이터를 이용해 인텐트를 만들고 필요한 액티비티를 띄워주는 대표적인 경우는 다음과 같다. 속성 설명 ACTION_DIAL tel:010-9999-9999 주어진 전화번호를 이용해 전화 걸기 화면을 보여줌 ACTION_VIEW tel:010-9999-9999 주어진 전화번호를 이용해 전화 걸기 화면을 보여줌. URI 값의 유형에 따라 VIEW 액션이 다른 기능을 수행함. ACTION_EDIT content://contacts/people/2 전화번호부 데이터베이스에 있는 정보 중에서 ID 값이 2인 정보를 편집하기 위한 화면을 보여줌 ACTION_VIEW content://contacts/people 전화번호부 데이터베스의 내용을 보여줌 다음은 인텐트 생성자이다.Intent()Intent(Intent o)Intent(String action [,Uri uri])Intent(Context packageContext, Class&amp;lt;?&amp;gt; cls)Intent(String action, Uri uri, Context packageContext, Class&amp;lt;?&amp;gt; cls)인텐트에 클래스 객체나 컴포넌트 이름을 지정하여 호출할 대상을 확실히 알 수 있는 경우에는‘명시적 인텐트(Explicit Intent)라고 하며, 액션과 데이터를 지정하긴 했지만 호출할 대상이달라질 수 있는 경우에는 암시적 인텐트(Implicit Intent)라고 부른다.암시적 인텐트는 액션과 데이터로 구성되지만 그 외에도 여러 가지 속성을 가지고 있다.대표적인 것으로 Category, Type, Component, Extras(부가 데이터)가 있다.범주 액션이 실행되는 필요한 추가적인 정보를 제공한다.예를 들어 CATEGORY_LAUNCHER는 최상위 앱으로 설치된 앱들의 목록을 보여주는 애플리케이션 런처 화면에 이 앱을 보여주어야 한다는 것을 의미한다.타입 인텐트에 들어가는 데이터의 MIME 타입을 명시적으로 지정한다. 보통 MIME 타입은 데이터만으로도 구별이 가능하지만 명시적으로 지정할 경우도 있다.컴포넌트 인텐트에 사용될 컴포넌트 클래스 이름을 명시적으로 지정한다. 보통 이 정보는 인텐트의 다른 정보를 통해 결정된다. 이 속성이 지정될 경우에는 지정된 컴포넌트가 실행되도록 한다.부가데이터 인텐트는 추가적인 정보를 넣을 수 있도록 번들(Bundle) 객체를 담고 있다.이 객체를 통해 인텐트 안에 더 많은 정보를 넣어 다른 앱 구성 요소에 전달 할 수 있다. 이메일을 보내는 액션이 있다면 이메일에 들어갈 제목, 내용 등을 부가 데이터로 넣어 전달해야 이메일 앱이 그 데이터를 받아 처리할 수 다.인텐트 예시activity_main.xml -&amp;gt; 최상위 레이아웃 (리니어 레이아웃) -&amp;gt; 입력 텍스트 창 추가 -&amp;gt; 버튼 추가public class MainActivity extends AppCompatActivity { EditText editText; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 뷰 객체 참조 editText = findViewById(R.id.editText); Button button = findViewById(R.id.button); button.setOnClickListener((v)-&amp;gt;{ String data = editText.getText().toString(); // 입력 상자에 입력된 전화번호 확인 // 전화걸기 화면을 보여줄 인텐트 객체 Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(data)); startActivity(intent); // 액티비티 띄우기 }); }}" }, { "title": "화면간 전환하기", "url": "/posts/ConvertView/", "categories": "Android, AppComponents", "tags": "android, intent, activity", "date": "2022-01-07 20:20:00 +0900", "snippet": "화면 간 전환하기 새로운 액티비티 만들기 새로운 액티비티를 추가하면 XML 레이아웃 파일 하나와 자바 소스 파일 하나가 만들어지고 매니페스트 파일에 액티비티 태그가 추가된다. 새로운 액티비티의 XML 레이아웃 정의하기 새로 만들어진 XML 레이아웃을 수정하여 새로운 액티비티의 화면이 어떻게 배치될지 작성한다. 메인 액티비티에서 새로운 액티비티 띄우기 메인 액티비티의 버튼을 클릭하면 startActivityForResult 메서드로 새로운 액티비티를 띄운다. 새로운 액티비티에서 응답 보내기 새로운 액티비티가 보이고 그 안에 들어가 있는 버튼을 클릭하면 setResult 메서드로 응답을 보낸다. 응답 처리하기 메인 Activity에서 onActivityResult method를 정의하여 새로 띄웠던 액티비티에서 보내오는응답을 처리 MenuActivity 를 만들어 준 후 소스 파일을 수정한다.public class MenuActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_menu); Button button = findViewById(R.id.button2); // 버튼 객체 참조 button.setOnClickListener((v)-&amp;gt;{ Intent intent = new Intent(); // 인텐트 객체 생성 intent.putExtra(&quot;name&quot;,&quot;mike&quot;); // name의 값을 mike로 설정 setResult(RESULT_OK,intent); // 응답 보내기 finish(); // 현재 액티비티 없애기 }); }} setResult(응답 코드, 인텐트) // 새로 띄운 액티비티에서 이전 액티비티로 인텐트를 전달하고 싶을 때 사용 인제 메인 엑티비티 자바 소스를 수정한다 .public class MainActivity extends AppCompatActivity { public static final int REQUEST_CODE_MENU = 101; @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE_MENU){ Toast.makeText(getApplicationContext(), &quot;onActivityResult 메서드 호출됨. 요청코드 : &quot; + requestCode + &quot;, 결과 코드 : &quot; + resultCode, Toast.LENGTH_LONG).show(); if(resultCode == RESULT_OK){ String name = data.getStringExtra(&quot;name&quot;); Toast.makeText(getApplicationContext(), &quot;응답으로 전달된 name: &quot; + name, Toast.LENGTH_LONG).show(); } } } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = findViewById(R.id.button); button.setOnClickListener((v)-&amp;gt;{ Intent intent = new Intent(getApplicationContext(),MenuActivity.class); startActivityForResult(intent,REQUEST_CODE_MENU); }); }}새로운 액티비티를 띄울 때 startActivityForResult 메서드를 호출한다.이 메서드는 새 액티비티를 띄우지만 새 액티비티로부터 응답을 받을 수 있다.REQUEST_CODE_MENU는 새 액티비티를 띄울 때 보낼 요청 코드이다. 이 값은 마음대로 지정해도 된다.(앱에 들어갈 액티비티가 여러 개라면 중복되지 않는 값으로 지정 해야한다.)이 값은 나중에 새 액티비티로부터 응답을 받을 때 다시 전달 받을 값이다.graph LRA((액티비티 A)) ----&amp;gt; |띄우기: 요청 코드 |B((액티비티 B))B ----&amp;gt;|응답하기: 요청코드, 응답 코드 | A인텐트를 만들 때 첫 번째 피라미터로는 컨텍스트(Context) 객체가 전달 되는데,액티비티 객체는 컨텍스트가 될 수 있기 때문에 일반적으로 this 변수를 사용할 수도 있다.onActivityResult 메서드는 새로 띄웠던 메뉴 액티비티가 응답을 보내오면 그 응답을 처리하는 역할을 한다.protected void onActivityResult(int requestCode, int resultCode, Intent intent)위 메소드 첫 번째 피라미터는 액티비티를 띄울 때 전달했던 요청 코드와 같고,이 값으로 어떤 액티비티로부터 응답을 받을 것인지 구분할 수 도 있다.두 번째 피라미터는 새 액티비티로부터 전달된 응답 코드이다.응답 코드는 새 액티비티에서 처리한 결과가 정상인지 아닌지를 구분하는데 사용된다.세 번째 피라미터는 전달 받은 인텐트이고 이 인텐트 안에 새 액티비티의 데이터를 전달 할 수 있다.인텐트 객체는 주로 새 액티비티로부터 원래의 액티비티로 데이터를 전달할 때 사용하고,이 인텐트 객체에 데이터를 넣을 때 사용하는 가장 간단한 방법은 putExtra이다.putExtra는 키와 데이터 값을 쌍으로 넣어야 한다.결과" }, { "title": "Infaltion, Infalator", "url": "/posts/Inflation/", "categories": "Android, XML", "tags": "android, progressbar, bar, snakbar, toast, dialog", "date": "2022-01-07 19:05:00 +0900", "snippet": "레이아웃 인프레이션XML 레이아웃만 만들고 화면을 띄우고 앱을 실행 할 수는 없다.화면의 기능을 담당하는 소스 코드 파일이 필요하기 때문이다.XML 레이아웃 파일과 하나의 소스 코드 파일이 어디서 연결되는지 어떻게 알까 ?MainActivity 파일에서,MainActivity 클래스는 AppCompatActivity 클래스를 상속하고 이 클래스는 화면에 필요한 메서드들이 있다는데,AppCompatActivity 클래스의 setContentView 메서드가 XML 레이아웃 파일을 연결해 준다.setContentView 메서드로 전달하는 XML 레이아웃 파일 이름은 확장자 없이 지정해 주어야 한다. R.layout.레이아웃 파일명public void setContentView (int layoutResID)public void setContentView (View view, [, ViewGroup.LayoutParams params])위에서 R은 프로젝트 창에 보이는 res 폴더를 의미하고, layout은 res 폴더의 layout 폴더를 의미한다.즉 앱이 실행될 때, XML 레이아웃의 내용이 메모리에 객체화되고 객체화된 XML 레이아웃을 소스파일에서사용한다. 이렇게 XML 레이아웃의 내용이 메모리에 객체화되는 과정을 인플레이션(Inflation) 이라고 한다.XML 레이아웃은 앱이 실행되는 시점에 메모리에 객체화 되고,XML 레이아웃 파일에 Button 태그를 정의해도 앱은 자신이 실행되기 전까지 버튼이 있는지 모른다.예시이 과정을 확인하기 위해 버튼을 하나 추가하고 setContentView 메서드 위에 버튼을 찾아 변수를 할당하고setOnClickListener 메서드를 호출하는 코드를 입력해 보았다.이렇게 하면 위와 같이 앱이 실행되지 않고 오류를 발생한다.이렇게 오류가 발생하는 이유는 메모리에 객체화되지 않은 버튼 객체를 참조하려 해서이다.부분 화면을 보여주는 인플레이터setContentView 메서드는 액티비티의 화면 전체(메인 레이아웃)를 설정하는 역할만 수행한다.즉, setContentView메서드로는 부분 화면(부분 레이아웃)을 메모리에 객체화 할 수 없다.부분 화면을 메모리에 객체화 하려면 인플레이터를 사용해야 한다.안드로이드는 LayoutInlater라는 클레스를 제공하고 이 클래스는 시스템 서비스를 제공하는 클래스이므로,다음 getSystemService 메서드를 이용하여 LayoutInflater 객체를 참조한 후 사용해야 한다.getSystemService(Context.LAYOUT_INFLATER_SERVICE)메인 레이아웃은 소스 코드에서 setContentView(R.layout.activity_main)와 같은 방법으로 객체화 하여화면에 나타낸다. 그 중 일부 화면을 분리한 부분화면은 LayoutInflater 객체를 사용해 뷰 그룹 객체로객체화 (인플레이션)한 후 메인 레이아웃에 추가 해야한다.실습app -&amp;gt; New -&amp;gt; Activity -&amp;gt; Empty ActivityMenuActivity 생성이렇게 하면 activity_menu 클래스와 xml 파일이 만들어진다.그 후 menu xml 을 아래와 같이 수정한다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MenuActivity&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;TextView&quot; /&amp;gt; &amp;lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button&quot; /&amp;gt; &amp;lt;LinearLayout android:id=&quot;@+id/container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&amp;gt;&amp;lt;/LinearLayout&amp;gt; &amp;lt;/LinearLayout&amp;gt;인제 버튼을 클릭 했을 때 새로운 XML 레이아웃이 안쪽에 있는 Linear Layout에 나타나게 해볼거다.그러기 위해서는 부분 화면으로 추가할 XML 레이아웃도 만들어 줘야하는데,/app/res/layout 폴더 선택 -&amp;gt; 마우스 오른쪽 클릭 -&amp;gt; new -&amp;gt;Layout resource file 선택이름은 sub1.xml, Root element는 리니어 레이아웃으로 설정해 봅시다.그 후 sub1.xml 파일은&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;부분 화면 1&quot; android:textSize=&quot;30sp&quot;/&amp;gt; &amp;lt;CheckBox android:id=&quot;@+id/checkBox&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;동의합니다&quot;/&amp;gt; &amp;lt;/LinearLayout&amp;gt;이렇게 하면 부분 화면은 아래와 같이 나온다. 이제 전체 레이아웃에 부분 레이아웃을 추가하기 위해 activity_menu.xml 파일의 짝인 MenuActivity.java 파일을수정해 보자.public class MenuActivity extends AppCompatActivity { LinearLayout container; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_menu); container = findViewById(R.id.container); Button button = findViewById(R.id.button2); button.setOnClickListener((v)-&amp;gt;{ LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE); // container에 sub1 xml 화면을 띄워라. inflater.inflate(R.layout.sub1,container,true); CheckBox checkBox = container.findViewById(R.id.checkBox); checkBox.setText(&quot;로딩이 되었어요.&quot;); }); }}그 후 부분화면이 나올 수 있게Manifest.xml 을 아래와 같이 수정하자.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.techtown.myapplication&quot;&amp;gt; &amp;lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.MyApplication&quot;&amp;gt; &amp;lt;activity android:name=&quot;.MainActivity&quot;&amp;gt;&amp;lt;/activity&amp;gt; &amp;lt;activity android:name=&quot;.MenuActivity&quot; android:exported=&quot;true&quot;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt; &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;/activity&amp;gt; &amp;lt;/application&amp;gt; &amp;lt;/manifest&amp;gt;결과" }, { "title": "Toast, Snackbar, Dialog, Progress bar", "url": "/posts/Bar/", "categories": "Android, Widget", "tags": "android, progressbar, bar, snakbar, toast, dialog", "date": "2022-01-07 01:05:00 +0900", "snippet": "Toast, Snack bar, Dialog, Progress bar토스트는 간단한 메시지를 잠깐 보여주었다가 없어지는 뷰로 앱 위에 떠 있는 뷰라고 할 수 있다.토스트 메시지를 만들어서 보여주는 전형적인 방법Toast.makeText(Context context, String message, int duration).show()Context 객체는 일반적으로 Context 클래스를 상속한 액티비티를 사용할 수 있으며,액티비티를 참조 할 수 없는 경우에는 getApplicationContext 메서드를 호출하면 Context 객체가 반환된다.토스트는 그 위치나 모양을 바꿀 수 있는데 다음의 두 메서드는 토스트의 위치와 여백을 지정할 수 있도록 한다.public void setGravity(int gravity, int xOffset, intyOffset) // Toast 뷰가 보이는 위치를 지정하는 사용public void setMargin(float horizontalMargin, float verticalMargin) // 외부 여백을 지정한다.토스트 모양과 위치 바꿔 보여주기와 스낵바 보여주기MainActivity에서 onButton1Clicked 메서드를 추가해 준다.public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void onButton1Clicked(View v) { LayoutInflater inflater = getLayoutInflater(); View layout = inflater.inflate( // 레이아웃 인플레이터 객체 참조 R.layout.toastborder, (ViewGroup) findViewById(R.id.toast_layout_root)); TextView text = layout.findViewById(R.id.text); Toast toast = new Toast(this); // 토스트 객체 생성 text.setText(&quot;모양 바꾼 토스트&quot;); toast.setGravity(Gravity.CENTER, 0, -100); toast.setDuration(Toast.LENGTH_SHORT); toast.setView(layout); // 토스트가 보이는 뷰 설정 toast.show(); } public void onButton2Clicked(View v) { Snackbar.make(v, &quot;스낵바입니다.&quot;, Snackbar.LENGTH_LONG).show(); }}/app/res/layout 폴더에 toastborder.xml 파일을 추가해준다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/toast_layout_root&quot; android:orientation=&quot;horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:padding=&quot;10dp&quot; &amp;gt; &amp;lt;TextView android:id=&quot;@+id/text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;20dp&quot; android:textSize=&quot;32sp&quot; android:background=&quot;@drawable/toast&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt;위 XML 레이아웃은 새롭게 만들 토스트의 형태를 정의한 것으로,이 레이아웃을 이용해 토스트 메시지가 보이게 된다.이 레이아웃 안에는 텍스트뷰 태그가 하나 정의되어 있고 ID는 text로 되어 있는데,토스트 뷰를 위한 레이아웃은 항상 이 형태로 정의되어야 한다.위에서 배경으로 지정된 그리기 객체는 @drawable/toast 이므로 /app/res/drawable 폴더 안에toast라는 xml 파일이 있어야 한다. 이 XML 파일을 drawable 폴더에 추가 한 후 아래처럼 작성한다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt; &amp;lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot; &amp;gt; &amp;lt;stroke android:width=&quot;4dp&quot; android:color=&quot;#ffffff00&quot; /&amp;gt; &amp;lt;solid android:color=&quot;#ff883300&quot; /&amp;gt; &amp;lt;padding android:left=&quot;20dp&quot; android:top=&quot;20dp&quot; android:right=&quot;20dp&quot; android:bottom=&quot;20dp&quot; /&amp;gt; &amp;lt;corners android:radius=&quot;15dp&quot; /&amp;gt; &amp;lt;/shape&amp;gt;알람 대화상자 보여주기토스트와 함께 많이 사용되는 알림 대화상자는 사용자에게 확인을 받거나 선택하게 할 때 사용한다.보통 알림 대화상자는 사용자에게 입력을 받기보다는 일방적으로 메세지를 전달하는 역할을 주로 하며,예, 아니오와 같은 전형적인 응답을 처리한다.public class MainActivity extends AppCompatActivity { TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); Button btn = findViewById(R.id.button); btn.setOnClickListener((v) -&amp;gt; { // 리스너 람다식 showMessage(); }); } private void showMessage(){ // 대화상자를 만들기 위한 빌더 객체 생성 AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(&quot;안내&quot;); builder.setMessage(&quot;종료 하시겠습니까?&quot;); builder.setIcon(android.R.drawable.ic_dialog_alert); //예 버튼 추가 builder.setPositiveButton(&quot;예&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { String message = &quot;예 버튼이 눌렸습니다.&quot;; textView.setText(message); } }); // 취소 버튼 추가 builder.setNeutralButton(&quot;취소&quot;, new DialogInterface.OnClickListener(){ @Override public void onClick(DialogInterface dialog, int which){ String message = &quot;취소 버튼이 눌렸습니다.&quot;; textView.setText(message); } }); // 아니오 버튼 추가 builder.setNegativeButton(&quot;아니오&quot;, new DialogInterface.OnClickListener(){ @Override public void onClick(DialogInterface dialog, int which){ String message = &quot;아니오 버튼이 눌렸습니다.&quot;; textView.setText(message); } }); // 대화상자 객체 생성 후 보여주기 AlertDialog dialog = builder.create(); dialog.show(); }프로그레스바 (진행 상태 바)어떤 일의 진행 상태를 중간 중간 보여 줄 수 있는 가장 좋은 방법 중 하나가 프로그레스바 이다.프로그레바는 작업의 진행 정도를 표시하거나 작업이 진행중임을 사용자에 알려준다.프로그레스바의 대표적인 두 가지 형태는 아래와 같다. 속성 설명 막대 모양 작업의 진행 정도를 알려 줄 수 있도록 막대 모양으로 표시한다. style 속성 값을 ‘android:attr/progressBarStyleHorizontal’로 설정한다. 원 모양 작업이 진행 중임을 알려준다. 원 모양으로 된 프로그레스바가 반복적으로 표시 된다. XML 레이아웃에 프로그레스바를 추가할 때는 태그가 사용되는데,프로그레스바가 갖는 값의 최대 범위는 max 속성으로 설정하고 현재 값은 progress 속성으로 설정한다.예를 들어, 값의 최대 범위가 100 이면 max 값을 100 으로 설정하고 현재 진행률이 50%라면 max 값이 100 이므로progress 값을 50으로 설정하면 된다. 진행률이 변경 되면 progress 속성으로 설정되었던 값을 바꾸면 된다.자바 코드에서 프로그레스 바의 현재 값을 바꿀 때 사용하는 메서드void setProgress(int progress) // 정수 값을 받아 프로그레스바의 현재 값으로 설정한다.void incrementProgressBy(itn diff) // 현재 설정되어 있는 값을 기준으로 값을 더하거나 뺄 때 사용한다. 타이틀 바에 프로그레스바를 표시 할 수 있는데 이 기능은 윈도우 속성으로 정의되어 있고 메서드는 다음과 같다.requestWindowFeature(Window.FEATURE_PROGRESS);타이틀 부분에 표시 되는 프로그레스 바의 범위는 따로 지정 할 수 없고 디폴트 값으로 0부터 10000사이의 값을 가질 수 있다.프로그레스 바 사용하기xml 디자인 창-&amp;gt; Widget 창 -&amp;gt; Progress바 드로그 앤 드롭public class MainActivity extends AppCompatActivity { ProgressDialog dialog; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ProgressBar progressBar = findViewById(R.id.progressBar); // 프로그래스 바 객체 불러오기 progressBar.setIndeterminate(false); progressBar.setProgress(80); // 진행 상태 80으로 설정 Button button = findViewById(R.id.button2); button.setOnClickListener((v)-&amp;gt; { // 프로그레스 대화상자 객체 만들고 설정하기 dialog = new ProgressDialog(MainActivity.this); // 프로그레스 바를 대화상자에 보여주기 위해 dialog 객체 안에 SPINNER로 설정 dialog.setProgressStyle(ProgressDialog.STYLE_SPINNER); dialog.setMessage(&quot;데이터를 확인하는 중 입니다.&quot;); dialog.show(); }); Button button2 = findViewById(R.id.button3); button2.setOnClickListener((v)-&amp;gt; { if(dialog != null) // 프로그래스 대화상자 없애기 dialog.dismiss(); }); }}" }, { "title": "Rotate View Event", "url": "/posts/roate-view/", "categories": "Android, Event", "tags": "android, event, key", "date": "2022-01-06 22:05:00 +0900", "snippet": "단말 방향을 전환 했을 때 이벤트 처리res 폴더 밑에 새 디렉토리 만들기 -&amp;gt; layout-land 만든다.layout-land 폴더는 layout 폴더와 같은 역할을 하지만 단말이 가로 방향으로 보일 때는 layout-land 폴더 안에들어 있는 XML 레이아웃 파일이 사용된다.즉, 세로 방향일 때는 layout 폴더의 activity_main.xml 파일이 사용되고가로 방향일 때는 layout-land 폴더의 activity_main.xml 파일이 사용된다.폴더 이름은 layotu-land로 설정 후 land 폴더의 activity.xml 파일을 복사 후 layout-land 폴더로 붙혀 넣기그러면 이렇게 가로 모드일 때 화면이 적용된다.단말기를 돌렸는데 변화가 없다면 Auto - rotate가 켜져 있는지 확인하자.onSaveInstanceState이렇게 하면 단말의 방향을 바꿨을 때 다른 화면이 보이게 할 수 있다.근데 이러면 한가지 문제점이 있다.단말의 방향이 바뀔 때 액티비티가 메모리에서 없어졌다가 새로 만들어진다는 점이다.이 경우 액티비티 안에 선언 해 두었던 변수 값이 사라지므로 변수의 값을 저장 했다가 복원하는 방법이 있어야 한다.이런 문제를 해결하는 방법이 onSaveInstanceState 콜백 메서드를 이용하는 것이다.이 메서드는 액티비티가 종료되기 전의 상태를 저장하고, 저장한 상태는 onCreate 메서드가 호출될 때 전달되는 번들 객체로 복원 할 수 있다.onSaveInstanceState 예시public class MainActivity extends AppCompatActivity { String name; EditText editText; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText = findViewById(R.id.editText); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { name = editText.getText().toString(); // 버튼을 클릭했을 때 사용자가 입력한 값을 name 변수에 할당 showToast(&quot;Save Value&quot; + name); } }); if(savedInstanceState != null) { // 이 화면이 초기화 될 때 name 변수의 값 복원 name = savedInstanceState.getString(name); showToast(&quot;Return Value&quot; + name); } } public void showToast(String data){ Toast.makeText(this,data,Toast.LENGTH_LONG).show(); } @Override protected void onSaveInstanceState(@NonNull Bundle outState) { super.onSaveInstanceState(outState); outState.putString(&quot;name&quot;,name); // name 변수의 값 저장 } }*에디트 텍스트에 표시되는 값은 복원하지 않아도 그대로 유지 된다." }, { "title": "Key Event", "url": "/posts/KeyEvent/", "categories": "Android, Event", "tags": "android, event, key", "date": "2022-01-06 21:25:00 +0900", "snippet": "Key Event키 입력은 onkeyDown 메서드를 재정의하여 처리할 수 있다.onKeyDown 메서드로 전달되는 피라미터는 두 개이며,KeyCode는 어떤 키가 사용되는지 구별할 때 사용되고 keyEvent는 키 입력 이벤트에 대한 정보를알고 싶을 때 사용 된다.키 입력 이벤트는 하드웨어 키보드나 소프트 키패드 상관 없이 동일한 이벤트로 전달된다.Referenceboolean onKeyDown (int keyCode, KeyEvent event)boolean onKey (View v, int keyCode, KeyEvent event)키를 눌렀을 때 전달되는 대표적인 키 값 키 코드 설명 KEYCODE_DPAD_LEFT 왼쪽 화살표 KEYCODE_DPAD_RIGHT 오른쪽 화살표 KEYCODE_DPAD_UP 위쪽 화살표 KEYCODE_DPAD_DOWN 아래쪽 화살표 KEYCODE_DPAD_CENTER 중앙 버튼 KEYCODE_CALL 통화 버튼 KEYCODE_ENDCALL 통화 종료 버튼 KEYCODE_HOME 홈 버튼 KEYCODE_BACK 뒤로가기 버튼 KEYCODE_VOLUME_UP 소리 크게 버튼 KEYCODE_VOLUME_DOWN 소리 작게 버튼 KEYCODE_0 ~ KEYCODE_9 숫자 0~9까지의 키값 KEYCODE_A ~ KEYCODE_Z 알파벳 A~Z까지의 키값 예시 @Override public boolean onKeyDown(int keyCode, KeyEvent event){ if (keyCode == KeyEvent.KEYCODE_BACK){ Toast.makeText(this,&quot;시스템 [BACK] 버튼이 눌렸습니다.&quot;,Toast.LENGTH_LONG).show(); return true; } return false; }" }, { "title": "Gesture Event", "url": "/posts/GestureEvent/", "categories": "Android, Event", "tags": "andorid, event, gesture", "date": "2022-01-06 21:05:00 +0900", "snippet": "제스처 이벤트 처리하기제스처 이벤트는 터치 이벤트 중에서 스크롤 등을 구별한 후 알려주는 이벤트이다.제스처 이벤트를 처리해주는 클래스는 GestureDetector이며,객체를 만들고 터치 이벤트를 전달하면 GestureDectector 객체에서 각 상황에 맞는 메소드를 호출한다.제스처 이벤트 만들기public class MainActivity extends AppCompatActivity { TextView textView; GestureDetector detector; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); View view = findViewById(R.id.view); view.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View view, MotionEvent motionEvent) { int action = motionEvent.getAction(); float curX = motionEvent.getX(); float curY = motionEvent.getY(); if (action == MotionEvent.ACTION_DOWN) { println(&quot;손가락 눌림 : &quot; + curX + &quot;, &quot; + curY); } else if (action == MotionEvent.ACTION_MOVE) { println(&quot;손가락 움직임 : &quot; + curX + &quot;, &quot; + curY); } else if (action == MotionEvent.ACTION_UP) { println(&quot;손가락 뗌 : &quot; + curX + &quot;, &quot; + curY); } return true; } }); detector = new GestureDetector(this, new GestureDetector.OnGestureListener() { @Override public boolean onDown(MotionEvent motionEvent) { println(&quot;onDown() 호출됨.&quot;); return true; } @Override public void onShowPress(MotionEvent motionEvent) { println(&quot;onShowPress() 호출됨.&quot;); } @Override public boolean onSingleTapUp(MotionEvent motionEvent) { println(&quot;onSingleTapUp() 호출됨.&quot;); return true; } @Override public boolean onScroll(MotionEvent motionEvent, MotionEvent motionEvent1, float v, float v1) { println(&quot;onScroll() 호출됨 : &quot; + v + &quot;, &quot; + v1); return true; } @Override public void onLongPress(MotionEvent motionEvent) { println(&quot;onLongPress() 호출됨.&quot;); } @Override public boolean onFling(MotionEvent motionEvent, MotionEvent motionEvent1, float v, float v1) { println(&quot;onFling() 호출됨 : &quot; + v + &quot;, &quot; + v1); return true; } }); View view2 = findViewById(R.id.view2); view2.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View view, MotionEvent motionEvent) { detector.onTouchEvent(motionEvent); return true; } }); } public void println(String data) { textView.append(data + &quot;\\n&quot;); } @Override public boolean onKeyDown(int keyCode, KeyEvent event) { if (keyCode == KeyEvent.KEYCODE_BACK) { Toast.makeText(this, &quot;시스템 [BACK] 버튼이 눌렸습니다.&quot;, Toast.LENGTH_LONG).show(); return true; } return false; }}&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;View android:id=&quot;@+id/view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:background=&quot;#8BC34A&quot; /&amp;gt; &amp;lt;View android:id=&quot;@+id/view2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:background=&quot;#FF9800&quot; /&amp;gt; &amp;lt;ScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;&amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/ScrollView&amp;gt;&amp;lt;/LinearLayout&amp;gt; 메서드 이벤트 유형 onDown() 화면이 눌림 onShowPress() 화면이 눌렸다 떼어짐 onSingleTapUp() 화면이 한 손가락으로 눌렸다 떼어짐 onSingleTapConfirmed() 화면이 한 손가락으로 눌림 onDoubleTap() 화면이 두 손가락으로 눌림 onScroll() 화면이 눌린 채 일정 속도와 방향으로 움직임 onFling() 화면이 눌린 채 가속도를 붙여 손가락을 움직였다 뗌 onLongPress() 화면이 오랫동안 눌림 " }, { "title": "Touch Event", "url": "/posts/TouchEvent/", "categories": "Android, Event", "tags": "android, event, touch, listener", "date": "2022-01-06 20:00:00 +0900", "snippet": "터치 이벤트 처리하기가장 두개의 뷰를 가장 상단에 배치,스크롤 뷰 안에 텍스트 뷰를 넣어서 가장 위에 있는 뷰를 터치하면 이벤트가발생하게 처리 해보았다. 밑에 있는 뷰의 이벤트도 처리 하고 싶으면,View view = findViewById(R.id.view2);로 뷰 객체를 불러와서불러온 객체에 리스너 등록 처리를 해주면 된다.public class MainActivity extends AppCompatActivity { TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); //Text 뷰 객체 불러오기 View view = findViewById(R.id.view); // View 객체 불러오기 view.setOnTouchListener(new MyListener()); } class MyListener implements View.OnTouchListener { @SuppressLint(&quot;ClickableViewAccessibility&quot;) @Override public boolean onTouch(View view, MotionEvent motionEvent){ // 발생한 이벤트 가져옴 // 이벤트는 상수 값으로 정의 되어 있음 int action = motionEvent.getAction(); // 이벤트가 발생한 좌표 얻어오기 float curX = motionEvent.getX(); float curY = motionEvent.getY(); if (action == MotionEvent.ACTION_DOWN) println(&quot;손가락 눌림 : &quot; + curX + &quot;, &quot; + curY); else if (action == MotionEvent.ACTION_MOVE) println(&quot;손가락 움직임: &quot; + curX + &quot;, &quot; + curY); else if (action == MotionEvent.ACTION_UP) println(&quot;손가락 뗌 : &quot;+ curX + &quot;, &quot; + curY); return true; } public void println(String data){ textView.append(data+&quot;\\n&quot;); } }}&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;View android:id=&quot;@+id/view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:background=&quot;#8BC34A&quot; /&amp;gt; &amp;lt;View android:id=&quot;@+id/view2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:background=&quot;#FF9800&quot; /&amp;gt; &amp;lt;ScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;&amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/ScrollView&amp;gt; &amp;lt;/LinearLayout&amp;gt; MotionEvent.ACTION_DOWN -&amp;gt; 손가락이 눌렸을 때 MotionEvent.ACTION_MOVE -&amp;gt; 손가락이 눌린 상태로 움직일 때 MotionEvent.ACTION_UP -&amp;gt; 손가락이 떼졌을 때" }, { "title": "Event", "url": "/posts/Event/", "categories": "Android, Event", "tags": "andorid, buuton", "date": "2022-01-06 19:08:00 +0900", "snippet": "이벤트 처리하기모바일에서는 주로 손가락으로 화면을 터치하며, 그 순간 터치 이벤트(Touch Evnet)가 발생한다.또한, 안드로이드 폰의 주요 이벤트로는 실제 버튼이나 소프트 키패드를 누르면 발생하는 KeyEvent도 있다.그리고 소스 코드에서 클릭 이벤트를 처리하도록 하려면 버튼의 setOnClickListener 메서드를 이용해리스너를 설정할 수 있습니다.이와 같은 이벤트 처리 방식은 화면에서 발생하는 이벤트를 버튼과 같은 위젯 객체에 전달한 후그 이후의 처리 과정을 버튼에 위임한다고 해서 위임 모델(Delegation Model) 이라고 부른다.이렇게 하면 코드가 복잡해지지 않고 이벤트를 위젯마다 개별적으로 처리하는 객체 지향 코드를 만들 수 있다.graph LRB[public void onClick]--&amp;gt;|설정|A(Button 객체)B--&amp;gt;|구현|C(OnClickListener 인터페이스)boolean onTouchEvent(MotionEvent event)boolean onKeyDown(int key, KeyEvent event)boolean onKeyUP(int keyCode, keyEvent event)기존의 뷰 객체에서 이벤트를 처리하려면 리스너를 설정하는 메소드를 호출해야 한다.다음은 기존의 뷰 클래스를 그대로 사용하면서 그 객체에 설정하여 사용하는 메서드이며,모두 리스너 인터페이스를 구현하도록 만들어져 있다.View.OnTouchListener: boolean onTouch(View v, MotionEvent event)View.OnKeyListener: boolean onKey (View v, int keyCode, KeyEvent event)View.OnClickListenr: void onClick (View v)View.OnFocusChangeListener : void onFocusChange(View v, boolean hasFoucus)OnTouchListener는 버튼과 같은 객체에 자주 사용하고, OnClickListenr는 버튼 뿐만 아니라,일반적인 뷰 객체에도 사용할 수 있다.대표적인 이벤트 유형 속성 설명 터치 이벤트 화면을 손가락으로 누를 때 발생하는 이벤트 키 이벤트 키 패드나 하드웨어 버튼을 누를 때 발생하는 이벤트 제스처 이벤트 터치 이벤트 중에서 스크롤과 같이 일정 패턴으로 구분되는 이벤트 포커스 뷰 마다 순서대로 주어지는 포커스 화면 방향 변경 화면의 방향이 가로와 세로로 바뀜에 따라 발생하는 이벤트 제스처 이벤트 유형 메서드 이벤트 유형 onDown() 화면이 눌림 onShowPress() 화면이 눌렸다 떼어짐 onSingleTapUp() 화면이 한 손가락으로 눌렸다 떼어짐 onSingleTapConfirmed() 화면이 한 손가락으로 눌림 onDoubleTap() 화면이 두 손가락으로 눌림 onScroll() 화면이 눌린 채 일정 속도와 방향으로 움직임 onFling() 화면이 눌린 채 가속도를 붙여 손가락을 움직였다 뗌 onLongPress() 화면이 오랫동안 눌림 " }, { "title": "이미지뷰와 이미지 버튼", "url": "/posts/ImageViewAndImageButton/", "categories": "Android, Widget", "tags": "android, layout, imgae, button", "date": "2022-01-06 12:32:00 +0900", "snippet": "이미지 뷰와 이미지 버튼이미지 뷰와 이미지 버튼의 차이점은 이미지를 버튼처럼 사용 할 수 있는지의 여부이다.이미지 뷰에 이미지를 보여주려면 먼저 /app/res/drawable 폴더에 이미지 파일을 넣은 후app:srcCompat 속성 값을 다음과 같은 방법으로 지정하면 된다. @drawable/이미지 파일명여기서 주의할 점은 이미지 파일명은 확장자를 제외하고 작성 해야한다!이렇게 이미지 파일을 지정하는 방식을 ‘이미지 리소스 지정 방식’이라고 한다.왜냐하면 이미지 파일은 res 폴더 안에 들어 있는 리소스 중의 하나이기 때문이다.이 방식 이외에도 이미지 파일을 소스 코드에서 직접 로딩하여 비트맵으로 만든 후 설정하는 방법도 있다.drawable 폴더 제대로 사용하기 해상도 폴더 이름 초고해상도 /app/res/drawable-xhdpi/app/res/drawable-xxhdpi/app/res/drawable-xxxhdpi 고해상도 /app/res/drawable-hdpi 중간 해상도 /app/res/drawable-mdpi 저 해상도 /app/res/drawable-Idpi drawable 폴더에 이미지를 그냥 넣으면 일반적으로 사용되는 이미지로 인식한다.하지만 위의 표에 있는대로 해상도에 맞게 넣으면 화면에 자동으로 적용된다.maxWidth, maxHeight두 속성은 이미지가 표시되는 최대 폭, 높이를 설정한다.이 속성을 설정하지 않으면 원본 이미지 크기 그대로 나타난다.tinttint 속성은 이미지 뷰에 보이는 이미지의 색상을 설정할 수 있다.색상은 #AARRGGBB 포맷으로 적용하면 된다.scaleTypescaleType 속성은 이미지 뷰의 크기에 맞게 원본 이미지의 크기를 자동으로 늘리거나 줄여서보여줄 때 사용한다." }, { "title": "Drawable ", "url": "/posts/Drawable/", "categories": "Android, Button, XML", "tags": "andorid, buuton", "date": "2022-01-06 01:30:00 +0900", "snippet": "Drawable이미지나 그래픽을 사용해서 좀 더 다양한 효과를 줄 수 있다 예를 들어,버튼의 배경을 이미지로 지정하고 버튼을 클릭하면 그 이미지는 아무런 변화가 없다.이럴 때 버튼을 클릭한것 같은 효과를 주는게 드로어블이다.종류 드로어블 설명 Bitmap Drawable 이미지 파일을 보여줄 때 사용함 StateList Drawable 상태별로 다른 비트맵 그래픽을 참조함 Transition Drawable 두 개의 드러어블을 서로 전환할 수 있음 Shape Drawable 색상과 그라데이션을 포함하여 도형 모양을 정의할 수 있음 Inset Drawable 지정된 거리만큼 다른 드러어블을 들어서 보여 줄 수 있음 Clip Drawable 레벨 값을 기준으로 다른 드로어블을 클리핑할 수 있음 Scale Drawable 레벨 값을 기준으로 다른 드로어블의 크기를 변경할 수 있음 가장 많이 사용되는 드로어블은 상태 드로어블과 셰이프 드로어블이다.StateList Drawable 만들기새로운 Drawable resource file을 만들어준다.그 후 xml 코드를 아래와 같이 수정한다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt; &amp;lt;item android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/finger_pressed&quot; /&amp;gt; &amp;lt;item android:drawable=&quot;@drawable/finger&quot; /&amp;gt;&amp;lt;/selector&amp;gt;selector 태그 안에 item 태그를 넣을 수 있으며,item 태그의 drawable 속성에는 이미지나 다른 그래픽을 설정하여 화면에 보여 줄 수 있다.state_로 시작하는 속성은 상태를 나타내는 간단한 예로 state_pressed 속성은 눌린 상태를 의미하고sate_focused는 포커스를 받은 상태를 의미한다.그 후 activity_main.xml 파일에서 background 속성의 값을 @drawable/finger_drawable로 변경한다.&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;Button android:id=&quot;@+id/button6&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/finger_drawable&quot; android:text=&quot;&quot; /&amp;gt;&amp;lt;/RelativeLayout&amp;gt;결과Shape Drawble 만들기위의 상태 드로어블 만든것 처럼 xml 파일을 만들어 준 뒤 아래와 같이 수정한다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&amp;gt; &amp;lt;size android:width=&quot;200dp&quot; android:height=&quot;120dp&quot;/&amp;gt; &amp;lt;stroke android:width=&quot;1dp&quot; android:color=&quot;#0000ff&quot;/&amp;gt; &amp;lt;solid android:color=&quot;#aaddff&quot;/&amp;gt; &amp;lt;padding android:bottom=&quot;1dp&quot;/&amp;gt;&amp;lt;/shape&amp;gt;shape 태그의 속성값을 rectangle로 입력하였는데 이렇게 하면 사각형을 그릴 수 있다.size 태그는 도형의 크기를 지정하는 태그이고, stroke 태그는 테두리선 속성을 지정하는 것 이고solid 태그는 도형의 안쪽을 채울 때 사용한다.padding 태그는 테두리 안쪽 공간을 띄우고 싶을 때 사용한다.XML 파일을 수정 하였으면 activity_main.xml 파일에서 backgroud 속성을 @drawale/rect_drawable로 설정한 후,backgroundTint 속성 값은 #00000000, backgroundTintMode 속성 값은 Add로 설정하면 버튼의 모양이 바뀌는것을 확인 할 수 있다." }, { "title": "Text View", "url": "/posts/TextView/", "categories": "Android, Widget", "tags": "android, text, view", "date": "2022-01-06 00:12:00 +0900", "snippet": "텍스트 뷰string.xml에 작성한 문자열 지정 방법안드로이드 스튜디오의 왼쪽 프로젝트 창에서 /app/res/values 폴더 안에 있는string.xml 파일을 열어서 resources 태그 안에 string 태그를 이용해 원하는 문자열을 넣는다.&amp;lt;resources&amp;gt; &amp;lt;string name=&quot;app_name&quot;&amp;gt;SampleWidget&amp;lt;/string&amp;gt; &amp;lt;string name=&quot;person_name&quot;&amp;gt;박세영&amp;lt;/string&amp;gt; &amp;lt;/resources&amp;gt;그런 후 text 속성을 찾아 @string/string name 으로 바꾸어 준다.maxLines텍스트뷰에서 표시하는 문자열의 최대 줄 수를 설정한다.만약 1로 설정하면 한 줄의 영역을 넘어가는 부분은 표시되지 않는다.커서 관련 속성 이름 기능 public int geSelectionStart() 선택된 영역의 시작 위치를 알려줍니다. public int getSelectionEnd() 끝 위치를 알려준다. public void setSelection(int start, int stop) 선택 영역을 지정한다. public void setSelection(int index) 선택 영역을 지정한다. public void selectAll() 전체 문자열이 선택 된다. public void extendSelection(int index) 선택 영역을 확장한다. 줄 간격 조정 관련 속성 이름 기능 lineSpacingMultiplier 줄 간격을 기본 줄 간격의 배수로 설정할 때 사용 lineSpaceingExtra 여유 값으로 설정 할 때 사용 힌트 표시 관련 속성에디트 텍스트에 어떤 내용을 입력하라고 안내문으로 알려주고 싶을 때는 hint 속성을 사용하면 된다.문자열 변경 처리 관련 속성에디트텍스트에 입력된 문자를 확인하거나 입력된 문자가 필요한 포멧과 맞는지 확인할 때 getText 메서드를 사용한다.이 메서드가 리턴하는 것은 Editable 객체인데 이 객체의 toString 메서드를 이용하면 일반 String 타입의 문자열을 확인 할 수 있다.문자열이 바뀔 때 마다 확인하는 기능을 넣고 싶다면public void addTextChangedListener(TextWatcher watcher)위 메소드를 이용하면 TextWatcher 객체를 설정 할 수 있다.TextWatcher 객체는 텍스트가 변경될 때 마다 발생하는 이벤트를 처리한다.TextWatcher 인터페이스에는 다음과 같은 메서드들이 정의되어 있다.public void beforeTextChange(CharSequence s, int start, int count, int after) public void afterTextChanged(Editable s)public void onTextChanged(CharSequence s, int start, int before, int count)" }, { "title": "SMS 입력 화면", "url": "/posts/SMS-Input/", "categories": "Android, User_Interface", "tags": "anroid, view, input, text, sms", "date": "2022-01-05 22:22:00 +0900", "snippet": "SMS 입력 화면XML&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &amp;gt; &amp;lt;RelativeLayout android:id=&quot;@+id/inputlayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_above=&quot;@+id/buttonLayout&quot; &amp;gt; &amp;lt;EditText android:id=&quot;@+id/inputMessage&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_above=&quot;@+id/inputCount&quot; android:layout_alignParentTop=&quot;false&quot; android:layout_marginLeft=&quot;5dp&quot; android:layout_marginRight=&quot;5dp&quot; android:cacheColorHint=&quot;#00000000&quot; android:gravity=&quot;top&quot; android:listSelector=&quot;#00000000&quot; android:maxLength=&quot;80&quot; android:textSize=&quot;48sp&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/inputCount&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_alignParentRight=&quot;true&quot; android:text=&quot;0 / 80 바이트&quot; android:textColor=&quot;#ffff00ff&quot; android:layout_marginRight=&quot;10dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:textSize=&quot;18sp&quot; /&amp;gt; &amp;lt;/RelativeLayout&amp;gt; &amp;lt;LinearLayout android:id=&quot;@+id/buttonLayout&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; &amp;gt; &amp;lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:orientation=&quot;horizontal&quot;&amp;gt; &amp;lt;Button android:id=&quot;@+id/sendButton&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;20dp&quot; android:paddingLeft=&quot;20dp&quot; android:paddingRight=&quot;20dp&quot; android:text=&quot;전송&quot; android:textSize=&quot;18sp&quot; /&amp;gt; &amp;lt;Button android:id=&quot;@+id/closeButton&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;20dp&quot; android:paddingLeft=&quot;20dp&quot; android:paddingRight=&quot;20dp&quot; android:text=&quot;닫기&quot; android:textSize=&quot;18sp&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/RelativeLayout&amp;gt;JAVApublic class MainActivity extends AppCompatActivity { EditText inputMessage; TextView inputCount; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); inputMessage = findViewById(R.id.inputMessage); inputCount = findViewById(R.id.inputCount); Button sendButton = findViewById(R.id.sendButton); sendButton.setOnClickListener(new View.OnClickListener() { public void onClick(View v) { String message = inputMessage.getText().toString(); Toast.makeText(getApplicationContext(), &quot;전송할 메시지\\n\\n&quot; + message, Toast.LENGTH_LONG).show(); } }); Button closeButton = findViewById(R.id.closeButton); closeButton.setOnClickListener(new View.OnClickListener() { public void onClick(View v) { finish(); } }); TextWatcher watcher = new TextWatcher() { public void onTextChanged(CharSequence str, int start, int before, int count) { byte[] bytes = null; try { bytes = str.toString().getBytes(&quot;KSC5601&quot;); int strCount = bytes.length; inputCount.setText(strCount + &quot; / 80바이트&quot;); } catch (UnsupportedEncodingException ex) { ex.printStackTrace(); } } public void beforeTextChanged(CharSequence s, int start, int count, int after) { } public void afterTextChanged(Editable strEditable) { String str = strEditable.toString(); try { byte[] strBytes = str.getBytes(&quot;KSC5601&quot;); if (strBytes.length &amp;gt; 80) { strEditable.delete(strEditable.length() - 2, strEditable.length() - 1); } } catch (Exception ex) { ex.printStackTrace(); } } }; inputMessage.addTextChangedListener(watcher); }}" }, { "title": "View Listener 구현 방법", "url": "/posts/ViewEvent/", "categories": "Android, Event", "tags": "anroid, view, event, listener", "date": "2022-01-05 21:58:00 +0900", "snippet": "View의 Event와 Listener각각의 View들은 고유한 이벤트를 가지고 있다.이벤트 발생시 이를 처리하는 Listener에 대해 알아 보면, Event : 뷰에서 다양한 동작이 발생하거나 상태가 변경될 때 발생하는 함수. Listener : 뷰의 이벤트 발생시, 이를 받아 처리할 수 있는 인터페이스. 처리 방식을 알아보기 위해버튼을 클릭했을 때 발생하는 OnClick() 이벤트로 예를 들어 보자.Listener를 구현하는 방법 XML에서 속성을 정의하고 메소드를 호출하는 방법 익명클래스를 이용하는 방법 람다식을 이용하는 방법 별도의 인터페이스 클래스를 이용하는 방법 Activity에서 인터페이스를 정의하는 방법XML에서 속성을 정의하고 메소드를 호출하는 방법XML 정의&amp;lt;Button android:layout_width=&quot;wrap_context&quot; android:layout_height=&quot;wrap_context&quot; android:text=&quot;버튼&quot; android:onClick=&quot;button_OnClick&quot; /&amp;gt; Java - Activity classpublic void button_OnClick(View v) { TextView textView = findViewById(R.id.txtName); textView.setText(&quot;클릭되었습니다.&quot;);}익명클래스 Anonymous-class를 이용하는 방법Button btn = findViewById(R.id.btn);btn.setOnClickListener(new View.onClickListener() { @Override public void onClick(View v) { TextView textView = findViewById(R.id.txtName); textVew.setText(&quot;클릭되었습니다.&quot;); } }); 람다식을 이용하는 방법Button btn = findViewById(R.id.btn); btn.setOnClickListener((v)-&amp;gt; { TextView textView = findViewById(R.id.txtName); textVew.setText(&quot;클릭되었습니다.&quot;); }); 별도의 인터페이스 이용 방법class MyListener implements View.OnClickListener { @Override public void onClick(View v) { TextView textView = findViewById(R.id.txtName); textVew.setText(&quot;클릭되었습니다.&quot;); } } Activity에서 인터페이스를 정의하는 방법public class MainActivity extends AppCompatActivity implements View.OnClickListener { public void onCreate() { Button btn = findViewById(R.id.btn); btn.setOnClickListener(this); } } @Override public void onClick(View v) { TextView textView = findViewById(R.id.txtName); textVew.setText(&quot;클릭되었습니다.&quot;); } " }, { "title": "두개의 이미지 뷰에 이미지 번갈아 보여주기", "url": "/posts/UpDownImage/", "categories": "Android, User_Interface", "tags": "anroid, view, scroll, layout", "date": "2022-01-05 09:44:00 +0900", "snippet": "두개의 이미지 뷰에 이미지 번갈아 보여주기&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &amp;gt; &amp;lt;HorizontalScrollView android:id=&quot;@+id/scrollView01&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_above=&quot;@+id/buttonLayout&quot; android:layout_alignParentTop=&quot;true&quot; &amp;gt; &amp;lt;ScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;ImageView android:id=&quot;@+id/imageView01&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;matrix&quot; /&amp;gt; &amp;lt;/ScrollView&amp;gt; &amp;lt;/HorizontalScrollView&amp;gt; &amp;lt;LinearLayout android:id=&quot;@+id/buttonLayout&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; &amp;gt; &amp;lt;LinearLayout android:orientation=&quot;horizontal&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; &amp;gt; &amp;lt;Button android:id=&quot;@+id/button01&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;10dp&quot; android:text=&quot; ▲ &quot; android:textSize=&quot;18sp&quot; /&amp;gt; &amp;lt;Button android:id=&quot;@+id/button02&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;10dp&quot; android:text=&quot; ▼ &quot; android:textSize=&quot;18sp&quot; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;HorizontalScrollView android:id=&quot;@+id/scrollView02&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_below=&quot;@+id/buttonLayout&quot; android:layout_alignParentBottom=&quot;true&quot; &amp;gt; &amp;lt;ScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;ImageView android:id=&quot;@+id/imageView02&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;matrix&quot; /&amp;gt; &amp;lt;/ScrollView&amp;gt; &amp;lt;/HorizontalScrollView&amp;gt; &amp;lt;/RelativeLayout&amp;gt;package org.techtown.myapplication; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.ImageView; import androidx.appcompat.app.AppCompatActivity; import org.techtown.myapplication.R; public class MainActivity extends AppCompatActivity { ImageView imageView01; ImageView imageView02; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView01 = findViewById(R.id.imageView01); imageView02 = findViewById(R.id.imageView02); Button button01 = findViewById(R.id.button01); button01.setOnClickListener(new View.OnClickListener() { public void onClick(View v) { moveImageUp(); } }); Button button02 = findViewById(R.id.button02); button02.setOnClickListener(new View.OnClickListener() { public void onClick(View v) { moveImageDown(); } }); moveImageUp(); } private void moveImageDown() { imageView01.setImageResource(0); imageView02.setImageResource(R.drawable.one); imageView01.invalidate(); imageView02.invalidate(); } private void moveImageUp() { imageView01.setImageResource(R.drawable.one); imageView02.setImageResource(0); imageView01.invalidate(); imageView02.invalidate(); } } invalidate()는 draw를 다시 하도록 요청하고 requestLayout()은 measure를 통한 사이즈 체크부터 다시 시작한다." }, { "title": "테이블 레이아웃", "url": "/posts/TableLayout/", "categories": "Android, User_Interface", "tags": "android, layout, tablelayout", "date": "2022-01-04 18:23:00 +0900", "snippet": "테이블 레이아웃테이블 레이아웃(Table Layout)은 그 안에 들어가는 뷰들을 격자 형태로만들어 주는 레이아웃이다.테이블 레이아웃은 HTML에서 사용하는 방식과 유사하여 실용적이지만 제약 레이아웃과리니어 레이아웃만으로도 화면 배치를 할 수 있어 자주 사용하지는 않는다. 직관적으로 격자 형태를 만들고 싶을 때 사용하는 경우도 있으니 사용 방법을 알아두자.테이블 레이아웃 사용하기Component Tree -&amp;gt; Convert view -&amp;gt; LinearLayout -&amp;gt; 팔레트창 -&amp;gt; TableLayout Covert view 메뉴에는 TableLayout이 없다.이렇게 Table Row를 설정해주면 layout_height값은 match_parent이고 테이블 레이아웃에 포함된,TableRow의 높이 값은 내부적으로 항상 wrap_content로 설정되어 있어서 화면을 꽉 채울 수 없다.반대로 layout_width는 wrap_content로 설정되어 있어서 가로 공간을 꽉 채운다.첫 번째, 두 번째, TableRow에 버튼을 세 개씩 추가하면 아래와 같은 상태가 된다.이 상태에서 오른쪽에 남는 공간이 없도록 만들고 싶을 경우에는,TableLayout의 stretchColumns 속성 값을 설정하면 된다. 이 속성은 가로 방향으로 여유 공간이 있다면,그 여유 공간까지 모두 채워서 column을 설정 할 수 있다.예를 들어 stretch 값을 0이라고 적어주면 첫 번째 컬럼에 있는 버튼들이 0 컬럼의 남은 공간을 다 채우게 된다.0,1,2를 입력하면 아래와 같은 상태가 된다.또한, 테이블 레이아웃의 대표적인 속성으로 shrinkColumns, stretchColumns가 있다.shrinkColumns은 부모 컨테이너의 폭에 맞추도록 각 열의 폭을 강제로 축소한다.stretchColumns는 부모 컨테이너의 여유 공간을 모두 채우기 위해 각 열의 폭을 강제로 늘린다.layout_span뷰가 여러 column에 걸쳐 있도록 만들기 위한 속성이며,뷰가 몇 개의 칼럼을 차지하게 할 것인지 숫자로 지정한다.위와 같이 layout_span 값을 2로 지정하면 입력 상자가 두 개의 column 영역을 차지하게 된다." }, { "title": "프레임 레이아웃", "url": "/posts/FrameLayout/", "categories": "Android, User_Interface", "tags": "android, layout, framelayout", "date": "2022-01-04 18:23:00 +0900", "snippet": "프레임 레이아웃프레임 레이아웃(FrameLayout)은 가장 위에 있는 하나의 뷰만 화면에 보여준다.만약 그 안에 여러개의 뷰나 뷰 그룹을 추가했다면 나머지는 그 아래에 중첩되어 쌓인다. 자주 사용될거 같지 않지만, 생각보다 상당히 많이 사용된다고 한다.그 이유는 한번에 하나의 뷰만 보여주면서 나머지는 보이지 않게 그 아래에 중첩 시켜 놨다가그 중에 특정 뷰를 보이거나 보이지 않도록 하면 손 쉽게 뷰를 바꾸면서 보여줄 수 있기 때문이다.프레임 레이아웃 안에서 새 개의 버튼을 추가한다면,가장 상위에 있는 버튼만 보이게 된다. (버튼의 크기는 화면 전체를 차지하도록 만들어야 한다.)만약 가장 상위에 있는 버튼이 화면 전체를 차지하지 않으면그 아래에 있는 뷰의 일부분이 보일 수 있다.가시성 속성프레임 레이아웃에서 가장 위에 있는 뷰를 보이지 않게 하면 그 다음 뷰가 보이는데,이렇게 보이거나 보이지 않게 하는 속성이 가시성(Visibility) 속성이다.가시성 속성을 사용하여 특정 뷰를 보이거나 보이지 않게 하면 화면에 보이는 뷰가전환되는 효과도 만들 수 있다. 속성의 이름은 visibility로 되어 있다.자바 코드에서 설정하고 싶으면 setVisibility 메서드를 사용하면 된다.프레임 레이아웃 사용하기drawable 폴더에 사진을 넣고 아래 이미지 같이 세팅 해줍니다.그 후 이미지 뷰 두개를 프레임 레이아웃에 추가한 후 visibility 속성에서 첫 번째 이미지는 invisible,나중에 추가한 이미지는 visible 값을 설정한다.인제 자바 소스 코드에서 버튼을 누를 때마다 두 개의 이미지 뷰가 가지는 visibility 속성을 바꿔주면 두개의 이미지가서로 전환되는 효과를 만들 수 있다.public class MainActivity extends AppCompatActivity { ImageView image1; // 첫 번째 이미지 뷰를 담을 변수 ImageView image2; // 두 번째 이미지 뷰를 담을 변수 int imageIdx = 0; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); image1 = findViewById(R.id.imageView); // id가 imageView 인 것을 찾아 image1에 넘겨줌 image2 = findViewById(R.id.imageView2); // id가 imageView2 인 것을 찾아 image1에 넘겨줌 } public void onbutton1Clicked(View v){ // 버튼이 클릭했을때 발생하는 이벤트 changeImage(); } private void changeImage(){ if(imageIdx==0){ // 첫 번째 이미지 전환 image1.setVisibility(View.VISIBLE); image2.setVisibility(View.INVISIBLE); imageIdx=1; }else if(imageIdx==1){ // 두 번째 이미지 전환 image1.setVisibility(View.INVISIBLE); image2.setVisibility(View.VISIBLE); imageIdx=0; } }}&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;onButton1Clicked&quot; android:text=&quot;Button&quot; /&amp;gt; &amp;lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;invisible&quot; app:srcCompat=&quot;@drawable/one&quot; /&amp;gt; &amp;lt;ImageView android:id=&quot;@+id/imageView2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;visible&quot; app:srcCompat=&quot;@drawable/two&quot; /&amp;gt; &amp;lt;/FrameLayout&amp;gt;&amp;lt;/LinearLayout&amp;gt;결과" }, { "title": "상대 레이아웃", "url": "/posts/RelativeLayout/", "categories": "Android, User_Interface", "tags": "android, layout, relativelayout", "date": "2022-01-04 18:07:00 +0900", "snippet": "상대 레이아웃상대 레이아웃(RelativeLayout) 은 제약 레이아웃이 안드로이드 스튜디오에서사용 되기 전까지 디폴트 레이아웃으로 사용되었다.하지만 지금은 상대 레이아웃보다 제약 레이아웃을 더 권장한다.이유는 제약 레이아웃은 상대 레이아웃의 특성은 그대로 가지고 있으면서더 많은 기능을 제공하기 때문이다.위의 글만 보면 상대 레이아웃은 많이 사용하지 않을거라고 오해 할 수 있는데,실제 앱 개발할 때 단순하고 이해하기 쉬운 레이아웃이라 아직도 사용하는 경우가 있다고 한다.상대 레이아웃은 부모 컨테이너, 즉 부모 레이아웃과의 상대적 위치 또는같은 레이아웃 안에 들어 있는 다른뷰와의 상대적 위치를 이용해 화면을배치하는 레이아웃이다. 왼쪽 그림에서 버튼이 부모 컨테이너의 위쪽에 붙어 있다.이건 버튼의 상대 레이아웃 속성으로 부모 컨테이너 위쪽에 붙힌거다. 오른쪽 그림은 상대 레이아웃의 속성(Right)으로 첫 번째 버튼 오른쪽에 두 번째 버튼을 붙인거다.속성부모 컨테이너와의 상대적 위치를 이용해 뷰를 배치할 수 있는 속성 속성 설명 layout_alignParentTop 부모 컨테이너의 위쪽과 뷰를 맞춤 layout_alignParentBottom 부모 컨테이너의 아래쪽과 뷰의 아래쪽을 맞춤 layout_alignParentLeft 부모 컨테이너의 왼쪽 끝과 뷰의 왼쪽 끝을 맞춤 layout_alignParentRight 부모 컨테이너의 오른쪽 끝과 뷰의 오른쪽 끝을 맞춤 layout_centerHorizontal 부모 컨테이너의 수평 방향 중앙에 배치함 layout_centerVertical 부모 컨테이너의 수직 방향 중앙에 배치함 layout_centerlnParent 부모 컨테이너의 수평과 수직 방향 중앙에 배치함 다른 뷰와의 상대적 위치를 이용해 뷰를 배치할 수 있는 속성 속성 설명 layout_above 지정한 뷰의 위쪽에 배치함 layout_below 지정한 뷰의 아래쪽에 배치함 layout_toLeftOf 지정한 뷰의 왼쪽에 배치함 layout_toRightOf 지정한 뷰의 오른쪽에 배치함 layout_alignTop 지정한 뷰의 위쪽과 맞춤 layout_alignBottom 지정한 뷰의 아래쪽에 맞춤 layout_alignLeft 지정한 뷰의 왼쪽과 맞춤 layout_alignRight 지정한 뷰의 오른쪽과 맞춤 layout_alignBaseline 지정한 뷰와 내용물의 아래쪽 기준선을 맞춤 " }, { "title": "안드로이드 레이아웃 종류 ", "url": "/posts/Android-Layout/", "categories": "Android, User_Interface", "tags": "android, layout", "date": "2022-01-04 17:48:00 +0900", "snippet": "레이아웃의 종류 레이아웃 이름 설명 제약 레이아웃 (ConstarintLayout) 제약 조건 기반 모델 연결선을 제약 조건으로 하여 화면을 구성하는 방법안드로이드 스튜디오에서 자동으로 설정하는 디폴트 레이아웃 리니어 레이아웃 (LinearLayout) 박스 모델(BOX) 한 쪽 방향으로 차례대로 뷰를 추가하며 화면을 구성하는 방법 뷰가 차지할 수 있는 사각형 영역을 할당 상대 레이아웃 (RelativeLayout) 규칙(Rule) 기반 모델부모 컨테이너나 다른 뷰와의 상대적 위치로 화면을 구성하는 방법 권장하지 않음 프레임 레이아웃 (ConstarintLayout) 싱글(Single)모델 가장 상위에 있는 하나의 뷰 또는 뷰 그룹만 보여주는 방법여러개의 뷰가 중첩하여 쌓게 됨 가장 단순하지만 여러개의 뷰를 중첩한 후 각 뷰를 전환하여 보여주는 방식 대표적인 레이아웃제약 레이아웃 제약 레이아웃 리니어 레이아웃 리니어 레이아웃 상대 레이아웃 상대 레이아웃 프레임 레이아웃 프레임 레이아웃 테이블 레이아웃 테이블 레이아웃 스크롤 뷰란?하나의 뷰나 뷰 그룹을 넣을 수 있고 어떤 뷰의 내용물이 넘치면 스크롤을 만들 수 있게 도와준다.예를 들어 스크롤뷰에 넣은 뷰 안에 글자를 넣었을 때 그 글자가 많아서화면을 벗어나면 자동으로 스크롤이 만들어 진다.스크롤 뷰 사용하기public class MainActivity extends AppCompatActivity { ScrollView scrollView; ImageView imageView; BitmapDrawable bitmap; int imageIdx = 0; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); scrollView = findViewById(R.id.scrollView); // 레이아웃에 정의된 뷰 객체 참조 imageView = findViewById(R.id.imageView); // 레이아웃에 정의된 뷰 객체 참조 scrollView.setHorizontalScrollBarEnabled(true); // 수평 스크롤바 사용 긴으 설정 /* 리소스 이미지 참조 */ Resources res = getResources(); bitmap = (BitmapDrawable) res.getDrawable(R.drawable.one); int bitmapWidth = bitmap.getIntrinsicWidth(); int bitmapHeight = bitmap.getIntrinsicHeight(); /* 이미지 리소스와 이미지 크기 설정 */ imageView.setImageDrawable(bitmap); imageView.getLayoutParams().width = bitmapWidth; imageView.getLayoutParams().height = bitmapHeight; } public void onButton1Clicked(View v) { // 버튼이 클릭했을때 발생하는 이벤트 changeImage(); } /* 다른 이미지 리소스로 변경 */ private void changeImage() { Resources res = getResources(); // 현재 패키지에 있는 디렉토리 정보를 다 가져오는듯 bitmap = (BitmapDrawable) res.getDrawable(R.drawable.two); // Drawable 디렉토리에 two 파일을 가져와서 객체에 저장하는듯 ? int bitmapWidth = bitmap.getIntrinsicWidth(); // 사진의 크기를 가져옴 int bitmapHeight = bitmap.getIntrinsicHeight(); imageView.setImageDrawable(bitmap); // 위에서 가져온 이미지를 보여줌 imageView.getLayoutParams().width=bitmapWidth; // 현재 레이아웃 요소의 속성객체를 얻어와서 width값 설정 imageView.getLayoutParams().height=bitmapHeight; // 현재 레이아웃 요소의 속성객체를 얻어와서 hegiht 값 설정 ㄴ }}&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&amp;gt; &amp;lt;Button android:id=&quot;@+id/button&quot; android:onClick=&quot;onButton1Clicked&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:text=&quot;이미지 바꾸어 보여주기&quot; /&amp;gt; &amp;lt;HorizontalScrollView android:id=&quot;@+id/horScrollView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &amp;gt; &amp;lt;ScrollView android:id=&quot;@+id/scrollView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt; &amp;lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:srcCompat=&quot;@drawable/one&quot; /&amp;gt; &amp;lt;/ScrollView&amp;gt; &amp;lt;/HorizontalScrollView&amp;gt;&amp;lt;/LinearLayout&amp;gt;결과res/drawable 에 있는 이미지를 bitmap으로 가져오기프로젝트에 추가된 이미지들을 getDrawable 메서들 이용해 BitmapDrawable 객체로 만든다." }, { "title": "XML Size", "url": "/posts/XML-Size/", "categories": "Android, XML", "tags": "android, XML, size, dp, sp, px, in, mm, em", "date": "2022-01-03 22:02:00 +0900", "snippet": "XML 크기 단위 단위 단위 표현 설명 px 픽셀 화면 픽셀의 수 dp 또는 dip 밀도 독립적 픽셀 160dpi 화면을 기준으로 한 픽셀 ex) 1인치당 160개의 점이 있는 디스플레이 화면에서 1dp는 1px와 같음. sp 또는 sip 축적 독립적 픽셀 텍스트 크기를 지정할때 사용하는 단위 가변 글꼴 기준으로 한 픽셀로 dp와 유사 mm 밀리미터 1밀리미터로 된 물리적 길이 in 인치 1인치로 된 물리적 길이 em 텍스트 크기 글꼴과 상관없이 동일한 텍스트 크기 표시 dp나 sp와 같은 단위를 사용하면 해상도가 다른 단말에서도 뷰의 크기를 비슷하게 보이도록 할 수 있다 dp나 dip는 해상도에 비례하는 비슷한 크기로 보이게 할 때 사용한다.이 단위를 사용하면 해상도가 160dpi인 작은 화면에서는 20픽셀이던,버튼 크기를 320dip인 큰 화면에서는 40픽셀의 크기로 보이게 한다. 뷰에는 dp, 글자에는 sp 단위를 사용하는게 좋다." }, { "title": "프로젝트를 생성하면 나오는 기본 XML 코드 ", "url": "/posts/XML1/", "categories": "Android, XML", "tags": "android, XML, guidline, constraint_layout", "date": "2022-01-03 21:45:00 +0900", "snippet": "안드로이드 스튜디오 XML 기초안드로이드 스튜디오에서 프로젝트를 만들면 아래 XML 파일이 만들어 진다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt;&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;위의 xml 파일을 하나씩 분석해 보자. &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; 첫째줄에 있는 줄은 XML 파일에 일반적으로 추가하는 정보이며,이 파일이 XML 형식으로 된 것임을 알려준다.&amp;lt;androidx.constraintlayout.widget.ConstraintLayout &amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;두번째 줄과 마지막 줄에 있는 태그는 화면 전체를 감싸고 있는 최상위 레이아웃 이며,Component Tree 창의 계층도에서 가장 위쪽에 있는걸 확인할 수 있다.자세히 보면 ConstraintLayout 앞에 패키지 이름이 있는데 (androidx.constraintlayout.widget)만약 위젯이나 레이아웃이 안드로이드 기본 API에 포함되어 있다면 위젯이나 레이아웃이름만 입력하면 된다. 하지만 외부 라이브러리를 사용할 경우 위처럼 패키지 이름까지다 적어야 한다.네임 스페이스xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&amp;gt;위의 xml 코드를 보면 xmlns: 이 있는데 이것을 네임 스페이스라고 하고,XML에서는 접두사(prefix)를 이용하여 같은 이름의 충돌을 방지한다. 전역변수 이름을 중복 되게 사용하면 안되는 것처럼 비슷하게 생각하면 될 것 같다.xmlns 앞에 android 가 있는데 이건 접두어이다.위의 xml 코드에서 xmlns 뒤에 있는 접두어의 의미는 아래와 같다.android, app, tools 접두어 의미 접두어 의미 xmlns:android 안드로이드 기본 SDK에 포함되어 있는 속성을 사용한다. xmlns:app 프로젝트에서 사용하는 외부 라이브러리에 포함되어 있는 속성을 사용한다. xmlns:tools 안드로이드 스튜디오의 디자이너 도구 등에서 화면을 보여줄 때 사용. 이 속성은 앱이 실행될때 적용되지 않고 안드로이드 스튜디오에서만 적용됨 android:id 뷰를 구분하는 구분자 역할을 한다. 네임 스페이스를 사용하는 문법&amp;lt;요소이름 xmlns:prefix=&quot;URI&quot;&amp;gt;URI란?URI란 통합 자원 식별자를 의미하며, 인터넷에 있는 자원을 나타내는 유일한 주소를 의미한다.인터넷에서 요구되는 기본조건으로서 인터넷 프로토콜에도 항상 명시된다.가장 잘 알려진 URI로는 인터넷 도메인 주소를 나타내는URL(Uniform Resource Locator)가 있고,또 다른 URI로는 URN(Universal Resource Name)가 있다.URI 는 네임 스페이스 식별자이다.제약 레이아웃에서 다른 뷰와 연결 layout_constraint[소스 뷰의 연결점]_[타킷 뷰의 연결점]=&quot;[타깃 뷰의 id]&quot;버튼과 버튼 2 ID를 가진 버튼 두개를 연결할 때 graph BT 버튼2&amp;amp;nbsp-&amp;amp;nbspbutton&amp;amp;nbsp2 --&amp;gt; 버튼1&amp;amp;nbsp-&amp;amp;nbspbuttonapp:layout_constraintTop_toBottomOf=&quot;@+id/button&quot; /&amp;gt;버튼 1 = 타깃 뷰버튼 2 = 소스 뷰 @+id/아이디값 형식으로 사용이외의 여러가지 속성layout_constraintTop_toTopOf layout_constraintLeft_toLeftOflayout_constraintTop_BottonOf layout_constraintLeft_toRightOflayout_constraintBottom_toTopOf layout_constraintRight_toTopOflayout_constraintBotton_toBottomOf layout_constraintRight_toBottomOflayout_constraintLeft_toTopOf layout_constraintRight_toLeftOflayout_constraintLeft_toBottomOf layout_constraintRight_toRightOfGuidLine XML&amp;lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_begin=&quot;20dp&quot; /&amp;gt;layout_constraintGuid_begin -&amp;gt; 부모 레이아웃의 벽면에서 얼마나 떨어트려 배치할지 속성 설명 layout_constraintGuid_begin 세로 방향- 왼쪽부터, 가로 방향일 경우 위쪽부터 거리 지정 layout_constraintGuid_end 세로 방향- 오른쪽부터, 가로 방향일 경우 아래쪽부터거리 지정 layout_constraintGuid_percent layout_constraint_begin 속성 대신 % 단위로 거리 지정 제약 조건을 설정하는 속성은 외부 라이브러리 속성이므로 앞에 모두 app: 접두어가 붙어있다.Button XML &amp;lt;Button android:id=&quot;@+id/button3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button&quot; tools:layout_editor_absoluteX=&quot;135dp&quot; tools:layout_editor_absoluteY=&quot;253dp&quot; /&amp;gt; 속성 설명 text 뷰에 들어갈 텍스트 layout_marginTop 뷰의 위쪽을 얼마나 띄울지 지정함 layout_marginBottom 뷰의 아래쪽을 얼마나 띄울지 지정함 layout_marginLeft 뷰의 왼쪽을 얼마나 띄울지 지정함 layout_marginRight 뷰의 오른쪽을 얼마나 띄울지 지정함 layout_margin 뷰의 위, 아래, 왼쪽, 오른쪽을 얼마나 띄울지 한꺼번에 지정함 " }, { "title": "가이드 라인 (Guid Line)", "url": "/posts/GuidLine/", "categories": "Android, Widget", "tags": "android, layout, guidline", "date": "2022-01-03 20:30:00 +0900", "snippet": "가이드 라인이란?여러개의 뷰를 일정한 기준 선에서 정렬할 때 사용하는 것 입니다.하나의 가이드 라인 선을 기준으로 정렬을 하면 더 쉽게 요소를 배치 할 수 있습니다.가이드 라인 만들기디자인 화면에서 가이드 라인 아이콘 선택 후 사용하고 싶은 가이드라인 선택" }, { "title": "제약 레이아웃(Constraint Layout)", "url": "/posts/Constraint-Layout/", "categories": "Android, User_Interface", "tags": "android, layout, constraint", "date": "2022-01-03 18:49:00 +0900", "snippet": "제약 레이아웃이란?안드로이드 스튜디오에서는 기본적인 레이아웃을제약 레이아웃(Constraint Layout)으로 자동 설정합니다. 제약 레이아웃 이전에 사용하던 상대 레이아웃과 비슷한 점이 많으면서도 제약 레이아웃의 장점이 더 많습니다.제약 레이아웃의 가장 큰 특징은 뷰의 위치를 결정할 때,제약조건(Constaint)을 사용한다는 것 입니다.제약 조건이란? 뷰가 레이아웃 안의 다른 요소와 어떻게 연결되는지 알려주는 것으로, 뷰의 연결점과, 대상을 연결합니다. 이름 그대로 제약 조건을 활용하는 레이아웃 입니다. Swift의 오토 레이아웃과 유사합니다. 위의 사진을 보시면,버튼 왼쪽 동그라미가 연결선으로 부모 레이아웃의 왼쪽 벽면과 연결이 되어 있습니다.이러한 상태를 부모 레이아웃이 타깃이 되어,연결점과 해당 타깃이(부모 레이아웃) 연결 되었다고 보면 되겠습니다.버튼이 레이아웃 안에서 어디에 위치하고 있는지 결정하려면 적어도,왼쪽과 위쪽에 연결되어 있어야 합니다.따라서 버튼의 위쪽 연결점을 부모 레이아웃의 위쪽 벽면까지 연결하는 것을진행하면 버튼의 제약 조건이 완성되게 됩니다.제약 조건이 완성되면 위의 사진처럼 속성 창에 제약 조건이 표시 됩니다.72라고 적혀 있는 숫자를 Margin 이라고 하고 연결점과 타킷의 거리를 나타냅니다.타깃이 될 수 있는것들 같은 부모 레이아웃 안에 들어 있는 다른 뷰의 연결점 부모 레이아웃의 연결점 가이드 라인연결점이 될 수 있는것들 위쪽(Top), 아래쪽(Bottom), 왼쪽(Left), 오른쪽(Right) 가로축의 가운데 (Center X), 세로축의 가운데 (Center Y) 베이스라인(Baseline) -&amp;gt; 텍스트를 보여주는 뷰의 경우에만 적용Button 두개일때 제약 조건 예시버튼을 새로 추가해서 기존 버튼의 왼쪽에 배치 하였는데요,새로 배치한 버튼의 왼쪽 연결점을 기존 버튼과 연결하면서기존 버튼이 타킷이 되면서 새로운 연결선이 만들어 지게 됩니다.여기서 마진을 적절하게 조절하면 두 개의 버튼이 적절한 위치에 배치 되도록 만들 수 있습니다.화면 가운데에 뷰 배치하기왼쪽 팔레트에서 버튼을 드래그 앤 드롭으로 화면 정 가운데에 배치하게 되면,위 사진과 같이 자동으로 왼쪽과 오른쪽 모두 자동으로 연결선이 만들어지게 됩니다.자석 모양이 비활성화가 되어 있다면 직접 연결선을 연결해 주어야 합니다.위의 사진에서 왼쪽 빨간 박스는 세로 방향 바이어스 (Vertical Bias)이고, 아래쪽 끝에 있는 줄이 가로 방향 (Horizontal Bias) 입니다. 바이어스는 한쪽으로 얼마나 치우쳐 있는지를 나타내는것 입니다. 보통 0부터 1사이의 값이고 75% 지점은 XML에서 0.75로 설정할 수 있는데, 디자인 화면에서는 % 단위로 표시 됩니다.제약 조건 표시 그림의 선 모양아래의 그림은 버튼의 크기를 바꾸어 주었는데,잘 보시면 옆에 제약 설정 창에서의 연결선 모양이 바뀌었습니다.이렇게 width,height 값을 무엇을 주느냐에 따라 모양이 바뀌게 됩니다.부모 여유 공간 채우기 연결선이 구불구불한 선으로 표시 Layout width 값은 Match constraint나 0dp로 표시뷰의 내용물 채우기 연결선이 »로 표시 Layout width 값이 Wrap content로 설정됨고정 크기 연결선이 직선으로 표시 Layout width 값과 Layout height 값은 지정한 값으로 설정됨제약 레이아웃에서 사용한 xml 코드 분석 바로가기 " }, { "title": "뷰와 레이아웃 ", "url": "/posts/View-And_LayOut/", "categories": "Android, User_Interface", "tags": "android, view, layout", "date": "2022-01-02 17:44:00 +0900", "snippet": "View 이름 설명 뷰(View) 화면 구성 요소 위젯 사용자 눈에 보이면서 컨트롤 역할을 하는 뷰 뷰 그룹 뷰를 담고 있는 그릇 레이아웃 뷰그룹 안에 뷰를 배치하는것 LayOut레이아웃은 레이아웃이 담고 있는 위젯이 어디에 배치되어야 할지 정해줍니다. 따라서 레이아웃 안에 레이아웃을 넣으면 각각의 레이아웃 안에서 버튼과 위젯의 위치를 잡을 수 있습니다.　　　　　 　　　　　 　　　　　       Button과 LinearLayOut의 계층도 graph TD; View--&amp;gt;Object; TextView--&amp;gt;View; ViewGroup--&amp;gt;View; Button--&amp;gt;TextView; LinearLayOut--&amp;gt;ViewGroup; 뷰의 크기 속성뷰는 화면의 일정 영역을 차지하기 때문에 모든 뷰는 반드시 크기 속성을 가지고 있어야 합니다.뷰의 가로, 세로 크기 속성이 없으면 안드로이는 XML 레이아웃이 잘못 되었다고 판단하고,오류를 출력 하게 됩니다.화면에 글자를 보여주는 텍스트뷰 XML &amp;lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World&quot; /&amp;gt; 텍스트 뷰는 끝에 /&amp;gt; 하나만 붙혀서 사용 가능하다. 이름 설명 wrap_content 내용물의 크기에 따라 뷰의 크기를 결정합니다. mathch_parent 뷰를 담고 있는 뷰 그룹의 여유 공간을 꽉 채웁니다. 숫자로 크기 지정 뷰의 크기를 고정된 값으로 만들고 싶을때 사용합니다. 뷰를 담고 있는 레이아웃이 어떤 것인지에 따라서 뷰에 적용되는 방식이 달라집니다. 또한 각각의 레이아웃마다 필수 속성도 약간씩 다를 수 있습니다.다른 뷰들을 담고 있는 레이아웃&amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; ... &amp;lt;생략&amp;gt; &amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;ConstraintLayout는 안에 뷰를 위한 태그들이 들어가야 해서 시작 태그와 끝 태그를 분리해서 사용할 수 밖에 없습니다.여기서 anroid:은 안드로이드의 기본 API에서 정의한 속성입니다.직접 정의 하거나 외부 라이브러리를 사용할때 그 안에 정의된 속성이라면 다른 단어가 붙을 수도 있습니다.Layout 쉽게 바꾸는 방법왼쪽 하단의 Component Tree -&amp;gt; Convert View -&amp;gt; 원하는 레이아웃 선택 -&amp;gt; Apply뷰 영역Margin: 테두리 바깥쪽 공간Padding: 테두리 안쪽 공간뷰 정렬하기 정렬 속성 설명 layout_gravity 부모의 여유 공간에 뷰가 모두 채워지지 않아 여유 공간이 생겼을 때 여유 공간안에서 뷰를 정렬함 gravity 뷰 안에 표시하는 내용물을 정렬함 layout_gravitylayout_gravity는 뷰의 layout_width나 layout_height 속성을 wrap_content로 만든 후에 같이 사용할 수 있다.예를 들어, 세로 방향으로 설정된 리니어 레이아웃에 추가된 버튼들의 layout 속성을 warp_content로 하면각각의 버튼들은 한 줄에 한 개씩 추가되면서 글자가 보이는 만큼만 가로 공간을 차지하므로나머지 가로 공간은 여유 공간으로 남게 된다.이렇게 여유 공간이 있을 때는 안드로이드는 일반적으로 왼쪽 정렬을 하게 되는데 layout_gravity 속성을 직접설정하면 왼쪽,중앙 또는 오른쪽 정렬 도 할 수 있다.gravitygravity 속성은 뷰의 위치가 아니라 뷰 안에 들어 있는 내용물의 위치를 결정하는 것이다.gravity는 ㅣ 연산자를 이용해 여러 개의 값을 같이 설정할 수 있다.주의할 점은 ㅣ 연산자 양쪽에 공백이 없어야 한다." }, { "title": "Android Studio 단축키 및 기능", "url": "/posts/Android-function/", "categories": "Android, Settings", "tags": "android, roadmap", "date": "2022-01-02 17:05:00 +0900", "snippet": "Android Studio 단축키 및 기능Ctrl + P 소괄호 안에 들어갈 수 있는 피라미터를 알려준다.Ctrl + Shift + F 프로젝트에 들어 있는 내용 중에서 어떤 글자를 검색하고 싶을 때코드 생성 기능새로운 클래스를 만들고 생성자를 입력할때 생성자의 이름과 형태는 이미 정해져 있으므로 자동으로 생성자 메서드가 만들어지게 할 수 있습니다.또한 클래스를 상속해서 만든 경우 메서드를 재정의 하는 코드를 자동으로 만들 수 있습니다. 오른쪽 마우스 클릭 -&amp;gt; [Generate] -&amp;gt; Override Methods위의 메뉴를 선택하면 부모 클래스의 메서드들을 보여주는 대화 상자가 나타납니다.그 후 Override 하고자 하는 메소드를 선택하고 OK 버튼을 누르게 되면 생성이 됩니다." }, { "title": "코드를 수정하고 반영이 안될때", "url": "/posts/Sync/", "categories": "Android, Settings", "tags": "android, roadmap", "date": "2022-01-02 16:41:00 +0900", "snippet": "Sync Project with Gradle Files안드로이드 스튜디오는 자동으로 변경 사항을 반영 해주지만,자동으로 모든 파일의 내용을 반영하지는 않습니다.코드를 수정했는데도 이전에 발생했던 에러가 그대로 있다고 뜨면밑에 있는 이미지 대로 Sync Project with Grandle Files 아이콘을 클릭 해주면 됩니다. 아니면 왼쪽 상단에서 File -&amp;gt; Sync Project with Gradle Files 클릭하시면 됩니다.오류가 없는데도 제대로 빌드가 되지 않을때는 이 메뉴를 한번 씩 눌러서 확인해 보는게 좋습니다." }, { "title": "Load Map", "url": "/posts/Android-Road_Map/", "categories": "Android, Study", "tags": "android, roadmap", "date": "2022-01-02 08:22:00 +0900", "snippet": "이 블로그는 로드맵을 따라 학습한 내용을 기록하기 위해 개설 되었습니다.블로그 방문 해주시는 분들 모두,더욱 성장하는 개발자가 되길 바라겠습니다.🙏🏻 로드맵 이미지는 계속 최신화 하므로 이전과 다를 수 있습니다." }, { "title": "Connet Decive to Studio", "url": "/posts/Android-Connet-Device/", "categories": "Android, Settings", "tags": "device, setting, android", "date": "2022-01-02 06:00:00 +0900", "snippet": "단말기 연결하는 방법 단말기의 연결 방법은 단말기마다 다릅니다, 따라서 삼성전자 단말기 기준으로 설명합니다.삼성전자 단말기위 사이트를 접속하시면 유용한 소프트 웨어라는 제목이 보입니다.[통합 USB 드라이버]를 클릭하여 설치를 진행합니다.플레이 스토어에 배포된 앱이 아니라면 단말기의 개발자 모드 설정이 있어야 설치하고 실행 할 수 있다.개발자 모드 켜는 방법단말기 마다 차이가 있을 수 있습니다.USB 디버깅 허용이렇게하여 준비는 끝났고 USB를 이용하여 PC와 디바이스를 연결하여 줍니다.그 후 안드로이드 스튜디오 프로젝트 창을 열어 밑의 사진 처럼 단말 파일 탐색창이 보이도록 해줍니다.이렇게 하면 단말기의 내부 파일들을 볼 수 있는 창이 열립니다.그 후 USB 디버깅 허용을 누르고 Run을 하면 단말기에서 앱을 실행해 볼 수 있습니다." }, { "title": "Deploy Error", "url": "/posts/Deploy_Erro/", "categories": "삽질_일기", "tags": "git, error", "date": "2022-01-01 10:27:00 +0900", "snippet": "Deploy Erorr블로그 테마 적용을 마치고 게시글을 올릴려고 했는데 Automatic build 오류가 났다. 그 후 여러가지 변수를 바꾸어 보기도 하고 계속 구글링을 해보았지만 나오는건 없었다. 😥 그래서 차분히 오류 메세지를 보니 Deploy 과정 중 경로를 제대로 읽지 못하는것 같았다. 밑에 이미지에서 /&amp;amp;quto; 가 들어가 있는데 따움표가 마지막에 왜 들어가지 곰곰히 생각해보다 문제의 파일을 찾기 위해 VsCode로 data-toogle 을 검색하여 post-sharing.html 파일이 문제인 걸 확인하였는데, post-sharing 파일은 변수로 link를 읽어 오므로 해당 파일은 문제가 없는것 같았다. 따라서 링크를 던져주는 파일 중 하나가 문제 인데 곰곰히 찾아보니 글을 작성할때 title: 제목 “ &amp;lt;- “ 콜론이 하나 빠져 있었다. title: “제목” 로 수정해주니 정상적으로 Deploy가 되었다." }, { "title": "Android Auto Import", "url": "/posts/Android-Auto-import/", "categories": "Android, Settings", "tags": "andorid, import, auto", "date": "2022-01-01 00:31:00 +0900", "snippet": "Android Studio Auto ImoprtFile -&amp;gt; Settings -&amp;gt; Editor -&amp;gt; General -&amp;gt; Auto Import 선택 오른쪽 설정 화면에서 Add unambiguous imports on the fly와 Optimize imports on the fly 항목을 체크 후 OK 버튼 클릭." }, { "title": "안드로이드 버튼 추가하기 ", "url": "/posts/Android-day-2/", "categories": "Android, Button", "tags": "andorid, buuton", "date": "2022-01-01 00:19:00 +0900", "snippet": "버튼 추가하기디자인 화면의 왼쪽에는 팔레트(Paletee)가 있습니다. 팔레트안에는 (버튼, 메세지) 등이 들어 있는데 이 요소를 마우스로 끌어 화면에 추가할 수 있습니다. 화면에 버튼을 끌어다 놓기 전에 디자인 화면 위쪽에는 있는 자석 모양 아이콘을 클릭하여 금지 모양을 없애 주어야 화면 요소를 쉽게 배치 할 수 있습니다.그 후 위의 이미지대로 클릭을 하여 버튼을 추가해주면 버튼이 생기게 됩니다.버튼 이벤트 처리public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void OnButtonClicked(View v){ Toast.makeText(this,&quot;확인1 버튼이 눌렸어요.&quot;,Toast.LENGTH_LONG).show(); }}** 자동으로 추가되는 context:와 text:는 안드로이드 스튜디오가 자동으로 보여주는 글자이므로 입력하지 않도록 주의하자 ! 자 인제 소스 파일에 함수를 추가 하였으니 버튼이 클릭되면 함수가 호출 되게 설정을 바꿔주면 끝난다. 확인1 버튼을 선택한 상태로 속성 창에서 onClick 속성 값으로 onButtonClicked를 선택하면 된다. 위 과정을 문제 없이 잘 했다면 영상처럼 버튼을 클릭하면 메세지가 나타났다 사라지게 된다.여러개의 버튼 추가하기위에 버튼을 추가 했던것 처럼 버튼을 추가한다 -&amp;gt; 왼쪽, 오른쪽, 위, 아래 동그라미 버튼이 생기는데, 위에 있는 동그라미는 위의 버튼의 밑에 경계선과 연결하고, 밑에 있는 동그라미는 밑에 있는 바닥 경계선과 연결해 준다 디자인 화면에서 단말 변경하기여러가지 버튼 이벤트 추가 public void onButton2Clicked(View v){ Intent myIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;http://m.naver.com&quot;)); startActivity(myIntent); } public void onButton3Clicked(View v){ Intent myIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;tel:010-9999-9999&quot;)); startActivity(myIntent); }인텐트는 간단하게 안드로이드 플랫폼에게 원하는것을 말할 때 전달하는 우편물 같은것 이다. 예를 들어 ‘웹 페이지를 띄우고 싶어’라고 편지를 쓰면 안드로이드 단말은 그 편지를 웹 브라우저에게 전달하면 웹 브라우저는 그 편지를 보고 내용에 맞게 웹 페이지를 띄어준다.소스파일을 추가해준 뒤 속성 창에서 onClick 속성 값으로 버튼에 맞는 함수를 넣어준다. 이렇게 하면 밑의 영상처럼 네이버로 연결, 전화 연결을 할 수 있게 된다. android 기능 setContentView 화면에 무엇을 보여줄지 결정하는 메서드 R.layout.acticity_main res/layout/activity_main_xml 파일 Intent 어떤 기능을 실행할 것인지 지정할 때 사용 Toast 화면에 잠깐 보였다 없어지는 메시지를 간단하게 보여주고 싶을때 사용 " }, { "title": "Linear Layout", "url": "/posts/Android_day_1/", "categories": "Android, User_Interface", "tags": "anroid, view, linear layout, layout", "date": "2021-12-29 19:52:00 +0900", "snippet": "LinerLayoutLiner Layout은 view를 수평 또는 수직 방향으로 배치할 수 있는 레이아웃이다. android:orientation = “vertical” (하위 뷰들을 수직 방향으로 배치) android:orientation = “horizontal” (하위 뷰들을 수평방향으로 배치) android:orientation = &quot;vertical&quot;android:orientation = &quot;horizontal&quot; Features android 기능 math_parent 부모 컨테이너의 남아있는 모든 여유 공간을 채움 wrap_content 뷰 안에 들어있는 내용물의 크기에 맞게 뷰의 크기가 결정 dp 임의로 원하는 길이를 지정한다. id 뷰나 레이아웃의 아이디를 지정한다. background 뷰의 배경을 설정한다. &amp;lt;LinearLayout android:layout_width = &quot;match_parent&quot; android:layout_height = &quot;wrap_content&quot; &amp;lt;/LinearLayout&amp;gt;&amp;lt;LinearLayout android:layout_width = &quot;wrap_content&quot; android:layout_height = &quot;match_parent&quot; &amp;lt;/LinearLayout&amp;gt;backgoroundandroid:background = &quot;#FF0000&quot;dpandroid:layout_width = &quot;200dp&quot;android:layout_height = &quot;100dp&quot;idandroid:id = &quot;@+id/linearlayout&quot;android:id = &quot;@+id/textview&quot;리니어 레이아웃 사용하기ComponetTree-&amp;gt; 현재 레이아웃 우 클릭 -&amp;gt; Convert ViewCommon Attributes에서 oriantation 지정Vertical로 하면 아래 이미지 처럼 세로로 쌓인다.Horizontal로 바꾸게 되면 버튼 두개가 사라지게 되는데,그 이유는 layout_wdith 속성 값이 match_parent로 되어서 그런다.wrap_content로 바꾸게 되면 버튼 세개가 다시 생기게 된다.Linearlayout 자바 코드Main Activity 코드를 복사후 같은 폴더에 소스 코드 복붙 후 아래 자바 코드 작성public class LayoutCodeActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); LinearLayout mainLayout = new LinearLayout(this); // Linear 레이아웃 객체 생성 mainLayout.setOrientation(LinearLayout.VERTICAL); // 방향 설정 /* new 연산자로 레이아웃 안에 추가될 뷰들에 설정할 피라미터 생성 */ LinearLayout.LayoutParams params = new LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT ); /* 버튼 생성 및 설정하고 레이아웃에 추가 */ Button button1 = new Button(this); // 여기서 this는 Context 객체 button1.setText(&quot;Button1&quot;); button1.setLayoutParams(params); mainLayout.addView(button1); setContentView(mainLayout); // 새로 만든 레이아웃을 화면에 설정 }} Context란?일반적으로 어떤 일이 발생한 상황을 의미하는 말인데, 프로그래밍 언어에서는 객체의 정보를담고 있는 객체를 의미하는 경우가 많다. 안드로이드는 UI 구성 요소인 뷰에 대한 정보를 손쉽게확인하거나 설정할 수 있도록 뷰의 생성자에 Context 객체를 전달한다.그 후 프로젝트 탐색창 -&amp;gt; app -&amp;gt; src -&amp;gt; main -&amp;gt; res -&amp;gt; AndroidManifest.xml -&amp;gt; 아래 코드로 수정 &amp;lt;activity android:name=&quot;.LayoutCodeActivity&quot; android:exported=&quot;true&quot;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt; &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;/activity&amp;gt;" } ]
